{"task_id": "Mbpp/2", "solution": "def similar_elements(list1, list2):\n    return set(list1) & set(list2)"}
{"task_id": "Mbpp/3", "solution": "def is_not_prime(n):\n    if n <= 1:\n        return True\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return True\n    return False"}
{"task_id": "Mbpp/4", "solution": "import heapq\ndef heap_queue_largest(nums, n):\n    \"\"\"\n    Find the n largest integers from a given list of numbers, returned in descending order.\n    \"\"\"\n    return heapq.nlargest(n, nums)"}
{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(num1, num2):\n    \"\"\"\n    Check whether the two numbers differ at one bit position only or not.\n    \"\"\"\n    xor_result = num1 ^ num2\n    return xor_result != 0 and (xor_result & (xor_result - 1)) == 0"}
{"task_id": "Mbpp/7", "solution": "def find_char_long(s):\n    return [word for word in s.split() if len(word) >= 4]"}
{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    return [num ** 2 for num in nums]"}
{"task_id": "Mbpp/9", "solution": "def find_Rotations(s):\n    \"\"\"\n    Find the minimum number of rotations (greater than 0) required to get the same string.\n\n    Args:\n        s (str): Input string\n\n    Returns:\n        int: Minimum number of rotations required\n    \"\"\"\n    if len(s) == 0:\n        return 0\n\n    # Concatenate the string with itself\n    doubled_s = s + s\n\n    # Find the index of the first occurrence of the original string in the doubled string\n    index = doubled_s.find(s)\n\n    # If the original string is not found, return 0\n    if index == -1:\n        return 0\n\n    # Calculate the minimum number of rotations required\n    rotations = len(s) - index\n\n    return rotations"}
{"task_id": "Mbpp/11", "solution": "def remove_Occ(string, char):\n    first_occurrence = string.find(char)\n    last_occurrence = string.rfind(char)\n    if first_occurrence != -1 and last_occurrence != -1:\n        return string[:first_occurrence] + string[first_occurrence+1:last_occurrence] + string[last_occurrence+1:]\n    else:\n        return string"}
{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)"}
{"task_id": "Mbpp/14", "solution": "def find_Volume(base, height, length):\n    \"\"\"\n    Calculate the volume of a triangular prism.\n\n    Args:\n        base (float): The base length of the triangular prism.\n        height (float): The height of the triangular prism.\n        length (float): The length of the triangular prism.\n\n    Returns:\n        float: The volume of the triangular prism.\n    \"\"\"\n    return 0.5 * base * height * length"}
{"task_id": "Mbpp/16", "solution": "def text_lowercase_underscore(text):\n    \"\"\"\n    Returns True if the input string contains sequences of lowercase letters joined with an underscore, False otherwise.\n    \"\"\"\n    return bool(re.search(r'[a-z]+_[a-z]+', text))"}
{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    \"\"\"\n    Returns the perimeter of a square given its side length as input.\n    \"\"\"\n    return 4 * side_length"}
{"task_id": "Mbpp/18", "solution": "def remove_dirty_chars(s1, s2):\n    \"\"\"\n    Remove characters from the first string which are present in the second string.\n\n    Args:\n        s1 (str): The first string.\n        s2 (str): The second string.\n\n    Returns:\n        str: The modified first string with characters removed.\n    \"\"\"\n    return ''.join([char for char in s1 if char not in s2])"}
{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    \"\"\"\n    This function takes an array of integers as input and returns True if the array contains any duplicate elements, otherwise False.\n    \"\"\"\n    # Create an empty set to store unique elements\n    unique_elements = set()\n\n    # Iterate through the array\n    for num in arr:\n        # If the element is already in the set, it's a duplicate\n        if num in unique_elements:\n            return True\n        # Otherwise, add the element to the set\n        unique_elements.add(num)\n\n    # If no duplicates were found, return False\n    return False"}
{"task_id": "Mbpp/20", "solution": "def is_woodall(n):\n    \"\"\"\n    Check if the given number is woodball or not.\n    \"\"\"\n    if n < 1:\n        return False\n    for i in range(1, n+1):\n        if 2**i * (i - 1) == n:\n            return True\n    return False"}
{"task_id": "Mbpp/56", "solution": "def reverse_number(n):\n    return int(str(n)[::-1])\ndef check(n):\n    return n == 2 * reverse_number(n) - 1"}
{"task_id": "Mbpp/57", "solution": "def find_Max_Num(digits):\n    digits.sort(reverse=True)\n    return int(''.join(map(str, digits)))"}
{"task_id": "Mbpp/58", "solution": "def opposite_Signs(a, b):\n    return (a > 0) != (b > 0)"}
{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    \"\"\"\n    Calculate the nth octagonal number.\n    \"\"\"\n    return n * (3 * n - 2)"}
{"task_id": "Mbpp/61", "solution": "def count_substrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            substring = s[i:j+1]\n            if sum(int(digit) for digit in substring) == len(substring):\n                count += 1\n    return count\n\nassert count_substrings('112112') == 6"}
{"task_id": "Mbpp/62", "solution": "def smallest_num(lst):\n    \"\"\"\n    Find the smallest number in a list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The smallest number in the list.\n    \"\"\"\n    return min(lst)"}
{"task_id": "Mbpp/63", "solution": "def max_difference(tuples):\n    \"\"\"\n    Find the maximum difference between available pairs in the given tuple list.\n\n    Args:\n        tuples (list): A list of tuples containing integer pairs.\n\n    Returns:\n        int: The maximum difference between available pairs.\n\n    Examples:\n        >>> max_difference([(3, 5), (1, 7), (10, 3), (1, 2)])\n        7\n    \"\"\"\n    max_diff = 0\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            diff = abs(tuples[i][0] - tuples[j][0]) + abs(tuples[i][1] - tuples[j][1])\n            max_diff = max(max_diff, diff)\n    return max_diff"}
{"task_id": "Mbpp/64", "solution": "def sort_tuples_by_second_value(tuples_list):\n    return sorted(tuples_list, key=lambda x: x[1])\n\n# Test the function\nassert sort_tuples_by_second_value([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)]) == [('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]"}
{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(lst):\n    total = 0\n    for element in lst:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total"}
{"task_id": "Mbpp/66", "solution": "def pos_count(lst):\n    \"\"\"\n    Count the number of positive numbers in a list.\n\n    Args:\n        lst (list): A list of numbers.\n\n    Returns:\n        int: The count of positive numbers in the list.\n    \"\"\"\n    return sum(1 for num in lst if num > 0)"}
{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]"}
{"task_id": "Mbpp/68", "solution": "def is_Monotonic(arr):\n    \"\"\"\n    Check whether the given array is monotonic or not.\n    \"\"\"\n    if len(arr) < 2:\n        return True\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i-1]:\n            decreasing = False\n        elif arr[i] < arr[i-1]:\n            increasing = False\n    return increasing or decreasing"}
{"task_id": "Mbpp/69", "solution": "def is_sublist(main_list, sub_list):\n    \"\"\"\n    Check whether a list contains the given sublist or not.\n\n    Args:\n        main_list (list): The main list to be checked.\n        sub_list (list): The sublist to be searched for.\n\n    Returns:\n        bool: True if the sublist is found in the main list, False otherwise.\n    \"\"\"\n    return all(item in main_list for item in sub_list)"}
{"task_id": "Mbpp/70", "solution": "def get_equal(tuples):\n    \"\"\"\n    This function takes a list of tuples as input and returns True if all tuples have equal length, False otherwise.\n    \"\"\"\n    if not tuples:\n        return True  # An empty list of tuples is considered to have equal length\n\n    # Get the length of the first tuple\n    first_tuple_length = len(tuples[0])\n\n    # Check if all tuples have the same length as the first tuple\n    for tup in tuples:\n        if len(tup) != first_tuple_length:\n            return False\n\n    return True"}
{"task_id": "Mbpp/71", "solution": "def comb_sort(arr):\n    gap = len(arr)\n    shrink_factor = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink_factor)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n\n        i = 0\n        while i + gap < len(arr):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                sorted = False\n            i += 1\n\n    return arr"}
{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    for i in range(1, int(n**0.5) + 1):\n        if (n + i**2) % (2*i) == 0:\n            return True\n    return False"}
{"task_id": "Mbpp/74", "solution": "def is_samepatterns(patterns, colors):\n    color_to_pattern = {}\n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n    return True"}
{"task_id": "Mbpp/75", "solution": "def find_tuples(tuples_list, k):\n    result = []\n    for tup in tuples_list:\n        if all(x % k == 0 for x in tup):\n            result.append(tup)\n    return result"}
{"task_id": "Mbpp/77", "solution": "def is_Diff(num):\n    \"\"\"\n    Function to check if a number is divisible by 11.\n    \"\"\"\n    return num % 11 == 0"}
{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    return len(word) % 2 != 0"}
{"task_id": "Mbpp/80", "solution": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) // 6"}
{"task_id": "Mbpp/82", "solution": "import math\ndef volume_sphere(radius):\n    \"\"\"\n    Calculate the volume of a sphere given its radius.\n\n    Args:\n        radius (float): The radius of the sphere.\n\n    Returns:\n        float: The volume of the sphere.\n    \"\"\"\n    return (4/3) * math.pi * (radius ** 3)"}
{"task_id": "Mbpp/84", "solution": "def sequence(n):\n    if n == 1 or n == 2:\n        return 1\n    else:\n        return sequence(sequence(n - 1)) + sequence(n - sequence(n - 1))"}
{"task_id": "Mbpp/85", "solution": "import math\ndef surfacearea_sphere(radius):\n    \"\"\"\n    Calculate the surface area of a sphere given its radius.\n\n    Args:\n        radius (float): The radius of the sphere.\n\n    Returns:\n        float: The surface area of the sphere.\n    \"\"\"\n    return 4 * math.pi * radius**2"}
{"task_id": "Mbpp/86", "solution": "def centered_hexagonal_number(n):\n    return 3 * n * (n - 1) + 1"}
{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict"}
{"task_id": "Mbpp/88", "solution": "def freq_count(lst):\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    return freq_dict"}
{"task_id": "Mbpp/89", "solution": "def closest_num(n):\n    return n - 1"}
{"task_id": "Mbpp/90", "solution": "def len_log(words):\n    \"\"\"\n    Write a python function to find the length of the longest word.\n    assert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7\n    \"\"\"\n    return max(len(word) for word in words)"}
{"task_id": "Mbpp/91", "solution": "def find_substring(lst, substring):\n    return any(substring in s for s in lst)"}
{"task_id": "Mbpp/92", "solution": "def is_undulating(num):\n    num_str = str(num)\n    if len(num_str) < 3:\n        return False\n    for i in range(1, len(num_str) - 1):\n        if num_str[i] != num_str[i - 1] and num_str[i] != num_str[i + 1]:\n            return False\n    return True"}
{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    return a ** b"}
{"task_id": "Mbpp/94", "solution": "def index_minimum(tuples_list):\n    \"\"\"\n    Given a list of tuples, returns the first value of the tuple with the smallest second value.\n    \"\"\"\n    return min(tuples_list, key=lambda x: x[1])[0]"}
{"task_id": "Mbpp/95", "solution": "def Find_Min_Length(list_of_lists):\n    \"\"\"\n    Find the length of the smallest list in a list of lists.\n\n    Args:\n        list_of_lists (list): A list of lists.\n\n    Returns:\n        int: The length of the smallest list.\n    \"\"\"\n    if not list_of_lists:\n        return 0\n\n    min_length = float('inf')\n    for lst in list_of_lists:\n        if len(lst) < min_length:\n            min_length = len(lst)\n\n    return min_length"}
{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/97", "solution": "def frequency_lists(lists):\n    \"\"\"\n    Write a function to find frequency of each element in a flattened list of lists, returned in a dictionary.\n    \"\"\"\n    # Flatten the list of lists\n    flattened_list = [item for sublist in lists for item in sublist]\n    \n    # Create a dictionary to store the frequency of each element\n    frequency_dict = {}\n    \n    # Iterate through the flattened list and update the frequency dictionary\n    for item in flattened_list:\n        if item in frequency_dict:\n            frequency_dict[item] += 1\n        else:\n            frequency_dict[item] = 1\n    \n    return frequency_dict"}
{"task_id": "Mbpp/98", "solution": "import math\ndef multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)"}
{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(decimal):\n    \"\"\"\n    Convert the given decimal number to its binary equivalent, represented as a string with no leading zeros.\n    \"\"\"\n    if decimal == 0:\n        return '0'\n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary"}
{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome(n):\n    n += 1\n    while str(n) != str(n)[::-1]:\n        n += 1\n    return n"}
{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    \"\"\"\n    Find the kth element in the given array using 1-based indexing.\n\n    Args:\n        arr (list): The input array.\n        k (int): The kth position to find.\n\n    Returns:\n        int: The kth element in the array.\n\n    Raises:\n        IndexError: If k is out of bounds.\n\n    Examples:\n        >>> kth_element([12, 3, 5, 7, 19], 2)\n        3\n    \"\"\"\n    if k < 1 or k > len(arr):\n        raise IndexError(\"k is out of bounds\")\n    return arr[k - 1]"}
{"task_id": "Mbpp/102", "solution": "def snake_to_camel(snake_str):\n    components = snake_str.split('_')\n    return components[0] + ''.join(x.title() for x in components[1:])"}
{"task_id": "Mbpp/103", "solution": "def eulerian_num(n, m):\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return ((n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m))"}
{"task_id": "Mbpp/104", "solution": "def sort_sublists(lst):\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/105", "solution": "def count_true_booleans(lst):\n    \"\"\"\n    Count the number of True booleans in the given list.\n\n    Args:\n        lst (list): A list of boolean values.\n\n    Returns:\n        int: The count of True booleans in the list.\n    \"\"\"\n    return sum(lst)\n\n# Test cases\nassert count_true_booleans([True, False, True]) == 2\nassert count_true_booleans([False, False, False]) == 0\nassert count_true_booleans([True, True, True]) == 3\nassert count_true_booleans([]) == 0"}
{"task_id": "Mbpp/106", "solution": "def add_lists(lst, tup):\n    return tup + tuple(lst)"}
{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    merged_list = list1 + list2 + list3\n    merged_list.sort()\n    return merged_list"}
{"task_id": "Mbpp/109", "solution": "def odd_Equivalent(s, n):\n    count = 0\n    for i in range(n):\n        s = s[-1] + s[:-1]\n        if s.count('1') % 2 == 1:\n            count += 1\n    return count"}
{"task_id": "Mbpp/111", "solution": "def common_in_nested_lists(nested_lists):\n    \"\"\"\n    Find the common elements in given nested lists.\n\n    Args:\n        nested_lists (list): A list of nested lists.\n\n    Returns:\n        set: A set of common elements found in all nested lists.\n    \"\"\"\n    if not nested_lists:\n        return set()\n\n    common_elements = set(nested_lists[0])\n\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n\n    return common_elements"}
{"task_id": "Mbpp/113", "solution": "def check_integer(s):\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/116", "solution": "def tuple_to_int(tup):\n    return int(''.join(map(str, tup)))"}
{"task_id": "Mbpp/118", "solution": "def string_to_list(input_string):\n    return input_string.split()"}
{"task_id": "Mbpp/119", "solution": "def search(nums):\n    left, right = 0, len(nums) - 1\n    while left < right:\n        mid = (left + right) // 2\n        if (mid % 2 == 0 and nums[mid] == nums[mid + 1]) or (mid % 2 == 1 and nums[mid] == nums[mid - 1]):\n            left = mid + 1\n        else:\n            right = mid\n    return nums[left]"}
{"task_id": "Mbpp/120", "solution": "def max_product_tuple(lst):\n    max_product = float('-inf')\n    for tup in lst:\n        product = abs(tup[0] * tup[1])\n        if product > max_product:\n            max_product = product\n    return max_product"}
{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum(n):\n    def sum_of_divisors(num):\n        return sum(i for i in range(1, num) if num % i == 0)\n\n    amicable_sum = 0\n    for a in range(1, n + 1):\n        b = sum_of_divisors(a)\n        if a != b and sum_of_divisors(b) == a:\n            amicable_sum += a\n    return amicable_sum"}
{"task_id": "Mbpp/124", "solution": "import math\ndef angle_complex(real, imag):\n    \"\"\"\n    Calculate the angle of a complex number.\n\n    Args:\n        real (float): The real part of the complex number.\n        imag (float): The imaginary part of the complex number.\n\n    Returns:\n        float: The angle of the complex number in radians.\n    \"\"\"\n    return math.atan2(imag, real)"}
{"task_id": "Mbpp/125", "solution": "def find_length(s):\n    max_diff = 0\n    current_diff = 0\n    for char in s:\n        if char == '0':\n            current_diff += 1\n        else:\n            current_diff -= 1\n        max_diff = max(max_diff, current_diff)\n    return max_diff"}
{"task_id": "Mbpp/126", "solution": "def sum_common_divisors(a, b):\n    \"\"\"\n    Find the sum of common divisors of two given numbers.\n\n    Args:\n        a (int): First number\n        b (int): Second number\n\n    Returns:\n        int: Sum of common divisors of a and b\n    \"\"\"\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n\n    def divisors(n):\n        divs = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divs.add(i)\n                divs.add(n // i)\n        return divs\n\n    common_divisors = divisors(a) & divisors(b)\n    return sum(common_divisors)\n\n# Test cases\nassert sum_common_divisors(10, 15) == 6\nassert sum_common_divisors(24, 36) == 12\nassert sum_common_divisors(100, 200) == 110"}
{"task_id": "Mbpp/127", "solution": "def multiply_int(a, b):\n    return a * b"}
{"task_id": "Mbpp/128", "solution": "def long_words(n, words):\n    return [word for word in words.split() if len(word) > n]"}
{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    n = len(matrix)\n    if any(len(row) != n for row in matrix):\n        return False\n\n    # Calculate the sum of the first row\n    magic_sum = sum(matrix[0])\n\n    # Check the sum of each row\n    for row in matrix:\n        if sum(row) != magic_sum:\n            return False\n\n    # Check the sum of each column\n    for col in range(n):\n        if sum(matrix[row][col] for row in range(n)) != magic_sum:\n            return False\n\n    # Check the sum of the main diagonal\n    if sum(matrix[i][i] for i in range(n)) != magic_sum:\n        return False\n\n    # Check the sum of the secondary diagonal\n    if sum(matrix[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n\n    return True"}
{"task_id": "Mbpp/130", "solution": "def max_occurrences(lst):\n    \"\"\"\n    Find the item with maximum frequency in a given list.\n\n    Args:\n        lst (list): The input list.\n\n    Returns:\n        int: The item with maximum frequency in the list.\n    \"\"\"\n    frequency = {}\n    for item in lst:\n        if item in frequency:\n            frequency[item] += 1\n        else:\n            frequency[item] = 1\n    max_item = max(frequency, key=frequency.get)\n    return max_item"}
{"task_id": "Mbpp/131", "solution": "def reverse_vowels(s):\n    vowels = \"aeiouAEIOU\"\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] in vowels and s[right] in vowels:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        elif s[left] in vowels:\n            right -= 1\n        elif s[right] in vowels:\n            left += 1\n        else:\n            left += 1\n            right -= 1\n    return \"\".join(s)"}
{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    return ''.join(tup)"}
{"task_id": "Mbpp/133", "solution": "def sum_negativenum(numbers):\n    \"\"\"\n    Calculate the sum of the negative numbers of a given list of numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        int: The sum of the negative numbers in the list.\n    \"\"\"\n    return sum(num for num in numbers if num < 0)"}
{"task_id": "Mbpp/135", "solution": "def hexagonal_num(n):\n    return n * (2 * n - 1)"}
{"task_id": "Mbpp/137", "solution": "import math\ndef zero_count(arr):\n    \"\"\"\n    Function to find the ratio of zeroes to non-zeroes in an array of integers.\n    \"\"\"\n    zero_count = sum(1 for num in arr if num == 0)\n    non_zero_count = len(arr) - zero_count\n    return zero_count / non_zero_count"}
{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two(n):\n    while n > 0:\n        if n & 1 == 1:\n            n -= 1\n        else:\n            n >>= 1\n    return n == 0"}
{"task_id": "Mbpp/139", "solution": "import math\ndef circle_circumference(radius):\n    \"\"\"\n    Calculate the circumference of a circle given its radius.\n\n    Args:\n        radius (float): The radius of the circle.\n\n    Returns:\n        float: The circumference of the circle.\n    \"\"\"\n    return 2 * math.pi * radius"}
{"task_id": "Mbpp/140", "solution": "def extract_singly(list_of_lists):\n    \"\"\"\n    Flatten the list of lists into a single set of numbers.\n\n    Args:\n        list_of_lists (list): A list of lists containing numbers.\n\n    Returns:\n        set: A set containing all the unique numbers from the input list of lists.\n    \"\"\"\n    return set(num for sublist in list_of_lists for num in sublist)"}
{"task_id": "Mbpp/141", "solution": "def pancake_sort(arr):\n    def flip(arr, i):\n        arr[:i+1] = arr[:i+1][::-1]\n\n    n = len(arr)\n    for size in range(n, 1, -1):\n        max_index = arr.index(max(arr[:size]))\n        if max_index != size - 1:\n            if max_index != 0:\n                flip(arr, max_index)\n            flip(arr, size - 1)\n    return arr"}
{"task_id": "Mbpp/142", "solution": "def count_samepair(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count"}
{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    \"\"\"\n    Find the maximum absolute difference between any two elements in a given array.\n\n    Args:\n        arr (list): A list of integers.\n\n    Returns:\n        int: The maximum absolute difference between any two elements in the array.\n    \"\"\"\n    if len(arr) < 2:\n        return 0\n\n    min_val = max_val = arr[0]\n    for num in arr:\n        if num < min_val:\n            min_val = num\n        elif num > max_val:\n            max_val = num\n\n    return max_val - min_val"}
{"task_id": "Mbpp/160", "solution": "def find_solution(a, b, n):\n    \"\"\"\n    Returns integers x and y that satisfy ax + by = n as a tuple, or returns None if no solution exists.\n    \"\"\"\n    if n % gcd(a, b) != 0:\n        return None\n    else:\n        x, y = extended_euclidean(a, b)\n        return (x * (n // gcd(a, b)), y * (n // gcd(a, b)))\ndef gcd(a, b):\n    \"\"\"\n    Returns the greatest common divisor of a and b.\n    \"\"\"\n    while b != 0:\n        a, b = b, a % b\n    return a\ndef extended_euclidean(a, b):\n    \"\"\"\n    Returns integers x and y such that ax + by = gcd(a, b).\n    \"\"\"\n    if a == 0:\n        return (0, 1)\n    else:\n        x, y = extended_euclidean(b % a, a)\n        return (y - (b // a) * x, x)"}
{"task_id": "Mbpp/161", "solution": "def remove_elements(lst1, lst2):\n    return [x for x in lst1 if x not in lst2]"}
{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    \"\"\"\n    Calculate the sum (n - 2*i) from i=0 to n // 2.\n\n    Args:\n        n (int): The input integer.\n\n    Returns:\n        int: The sum of the series.\n    \"\"\"\n    return sum(n - 2 * i for i in range(n // 2 + 1))"}
{"task_id": "Mbpp/165", "solution": "def count_char_position(s):\n    count = 0\n    for i, char in enumerate(s.lower()):\n        if char.isalpha() and (ord(char) - ord('a')) == i:\n            count += 1\n    return count"}
{"task_id": "Mbpp/166", "solution": "def find_even_pair(nums):\n    \"\"\"\n    Counts the number of pairs of integers in a list that xor to an even number.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The count of pairs that xor to an even number.\n    \"\"\"\n    count = 0\n    for i in range(len(nums)):\n        for j in range(i + 1, len(nums)):\n            if (nums[i] ^ nums[j]) % 2 == 0:\n                count += 1\n    return count"}
{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    if n == 0:\n        return 1\n    else:\n        return 2 ** ((n - 1).bit_length())"}
{"task_id": "Mbpp/168", "solution": "def frequency(lst, num):\n    return lst.count(num)"}
{"task_id": "Mbpp/170", "solution": "def sum_range_list(lst, start, end):\n    return sum(lst[start-1:end])"}
{"task_id": "Mbpp/171", "solution": "def perimeter_pentagon(side_length):\n    \"\"\"\n    Calculate the perimeter of a regular pentagon from the length of its sides.\n\n    Args:\n        side_length (float): The length of each side of the pentagon.\n\n    Returns:\n        float: The perimeter of the pentagon.\n    \"\"\"\n    return 5 * side_length"}
{"task_id": "Mbpp/172", "solution": "def count_occurance(s):\n    return s.count('std')"}
{"task_id": "Mbpp/222", "solution": "def check_type(tup):\n    \"\"\"\n    Check if all elements in the tuple have the same data type.\n\n    Args:\n        tup (tuple): Input tuple to be checked.\n\n    Returns:\n        bool: True if all elements have the same data type, False otherwise.\n    \"\"\"\n    if not tup:  # Check if the tuple is empty\n        return True  # An empty tuple is considered to have the same data type\n\n    first_element_type = type(tup[0])  # Get the data type of the first element\n\n    for element in tup[1:]:  # Iterate through the remaining elements\n        if type(element) != first_element_type:  # Compare data types\n            return False  # Return False if any element has a different data type\n\n    return True  # Return True if all elements have the same data type"}
{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, element):\n    \"\"\"\n    Write a function that takes in a sorted array, its length (n), and an element and returns whether the element is the majority element in the given sorted array. (The majority element is the element that occurs more than n/2 times.)\n    \"\"\"\n    # Check if the element occurs more than n/2 times\n    if arr[n//2] == element:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/224", "solution": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count"}
{"task_id": "Mbpp/226", "solution": "def odd_values_string(input_string):\n    return input_string[::2]"}
{"task_id": "Mbpp/227", "solution": "def min_of_three(a, b, c):\n    return min(a, b, c)"}
{"task_id": "Mbpp/230", "solution": "def replace_blank(string, character):\n    return string.replace(\" \", character)"}
{"task_id": "Mbpp/232", "solution": "def larg_nnum(lst, n):\n    return sorted(lst, reverse=True)[:n]"}
{"task_id": "Mbpp/233", "solution": "import math\ndef lateralsuface_cylinder(radius, height):\n    \"\"\"\n    Calculate the lateral surface area of a cylinder.\n\n    Args:\n        radius (float): The radius of the cylinder's base.\n        height (float): The height of the cylinder.\n\n    Returns:\n        float: The lateral surface area of the cylinder.\n    \"\"\"\n    return 2 * math.pi * radius * height"}
{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    \"\"\"\n    Calculate the volume of a cube given its side length.\n\n    Args:\n        side_length (float): The length of a side of the cube.\n\n    Returns:\n        float: The volume of the cube.\n    \"\"\"\n    return side_length ** 3"}
{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(n):\n    \"\"\"\n    Set all even bits of a given number.\n    \"\"\"\n    # Create a mask with all even bits set to 1\n    mask = 0xAAAAAAAA\n    # Set all even bits of the number using the mask\n    return n | mask"}
{"task_id": "Mbpp/237", "solution": "def check_occurrences(tuples_list):\n    \"\"\"\n    This function takes in a list of tuples and returns a dictionary mapping each unique tuple to the number of times it occurs in the list.\n\n    Args:\n    tuples_list (list): A list of tuples.\n\n    Returns:\n    dict: A dictionary mapping each unique tuple to the number of times it occurs in the list.\n    \"\"\"\n    occurrences = {}\n    for tup in tuples_list:\n        if tup in occurrences:\n            occurrences[tup] += 1\n        else:\n            occurrences[tup] = 1\n    return occurrences\n\n# Test the function\nassert check_occurrences([(3, 1), (1, 3), (2, 5), (5, 2), (6, 3)]) == {(1, 3): 2, (2, 5): 2, (3, 6): 1}"}
{"task_id": "Mbpp/238", "solution": "def number_of_substrings(s):\n    \"\"\"\n    Count the number of non-empty substrings of a given string.\n\n    Args:\n        s (str): The input string.\n\n    Returns:\n        int: The number of non-empty substrings.\n    \"\"\"\n    return len(s) * (len(s) + 1) // 2"}
{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    \"\"\"\n    This function calculates the total number of sequences of length n, where each element is a positive integer and is greater than or equal to twice the previous element but less than or equal to m.\n\n    Args:\n    m (int): The maximum value for each element in the sequence.\n    n (int): The length of the sequence.\n\n    Returns:\n    int: The total number of possible sequences.\n    \"\"\"\n    # Initialize a 2D array to store the number of sequences for each length and maximum value\n    dp = [[0 for _ in range(m + 1)] for _ in range(n + 1)]\n\n    # Base case: There is only one sequence of length 1 for each value from 1 to m\n    for i in range(1, m + 1):\n        dp[1][i] = 1\n\n    # Fill the dp array using dynamic programming\n    for i in range(2, n + 1):\n        for j in range(1, m + 1):\n            for k in range(1, j // 2 + 1):\n                dp[i][j] += dp[i - 1][k]\n\n    return dp[n][m]"}
{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1"}
{"task_id": "Mbpp/242", "solution": "def count_charac(string):\n    return len(string)"}
{"task_id": "Mbpp/244", "solution": "import math\ndef next_Perfect_Square(n):\n    \"\"\"\n    Write a python function to find the next perfect square greater than a given number.\n    assert next_Perfect_Square(35) == 36\n    \"\"\"\n    root = math.ceil(math.sqrt(n))\n    return root * root"}
{"task_id": "Mbpp/245", "solution": "def max_sum(arr):\n    n = len(arr)\n    inc = [0] * n\n    dec = [0] * n\n    inc[0] = arr[0]\n    dec[n-1] = arr[n-1]\n    for i in range(1, n):\n        inc[i] = max(inc[i-1], arr[i])\n    for i in range(n-2, -1, -1):\n        dec[i] = max(dec[i+1], arr[i])\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n    return max_sum"}
{"task_id": "Mbpp/247", "solution": "def lps(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j = i+cl-1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n    return dp[0][n-1]"}
{"task_id": "Mbpp/250", "solution": "def count_X(tup, element):\n    return tup.count(element)"}
{"task_id": "Mbpp/251", "solution": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.extend([element, item])\n    return result"}
{"task_id": "Mbpp/252", "solution": "import cmath\ndef convert(complex_num):\n    \"\"\"\n    Convert a complex number to polar coordinates.\n\n    Args:\n        complex_num (complex): The complex number to be converted.\n\n    Returns:\n        tuple: A tuple containing the magnitude and phase angle of the complex number.\n    \"\"\"\n    magnitude, phase_angle = cmath.polar(complex_num)\n    return magnitude, phase_angle"}
{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    return sum(isinstance(x, int) for x in lst)"}
{"task_id": "Mbpp/255", "solution": "from itertools import product\ndef combinations_colors(colors, n):\n    return list(product(colors, repeat=n))"}
{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    if n <= 2:\n        return 0\n    primes = [True] * n\n    primes[0] = primes[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if primes[i]:\n            for j in range(i*i, n, i):\n                primes[j] = False\n    return sum(primes)"}
{"task_id": "Mbpp/257", "solution": "def swap_numbers(a, b):\n    return (b, a)"}
{"task_id": "Mbpp/259", "solution": "def maximize_elements(tup1, tup2):\n    \"\"\"\n    This function takes two tuples of tuples as input and returns a new tuple of tuples\n    where each element is the maximum of the corresponding elements in the input tuples.\n    \"\"\"\n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over the tuples in the input tuples\n    for t1, t2 in zip(tup1, tup2):\n        # Create a new tuple with the maximum of each element in the corresponding tuples\n        max_tuple = tuple(max(x, y) for x, y in zip(t1, t2))\n        # Append the new tuple to the result list\n        result.append(max_tuple)\n    \n    # Convert the result list to a tuple and return it\n    return tuple(result)"}
{"task_id": "Mbpp/260", "solution": "def newman_prime(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    def newman_shanks_williams(n):\n        if n == 1:\n            return 3\n        else:\n            return 2 * newman_shanks_williams(n - 1) + 1\n\n    count = 0\n    num = 1\n    while count < n:\n        num = newman_shanks_williams(num)\n        if is_prime(num):\n            count += 1\n    return num"}
{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    \"\"\"\n    This function takes in two tuples and performs mathematical division operation element-wise across the given tuples.\n    \"\"\"\n    return tuple(a / b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    return (lst[:L], lst[L:])"}
{"task_id": "Mbpp/264", "solution": "def dog_age(age):\n    return age * 7"}
{"task_id": "Mbpp/265", "solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]"}
{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side_length):\n    \"\"\"\n    Calculate the lateral surface area of a cube given its side length.\n\n    Args:\n        side_length (float): The length of a side of the cube.\n\n    Returns:\n        float: The lateral surface area of the cube.\n    \"\"\"\n    return 4 * side_length ** 2"}
{"task_id": "Mbpp/267", "solution": "def square_Sum(n):\n    \"\"\"\n    Write a python function that takes in an integer n and returns the sum of the squares of the first n odd natural numbers.\n    assert square_Sum(2) == 10\n    \"\"\"\n    return sum((2 * i + 1) ** 2 for i in range(n))"}
{"task_id": "Mbpp/268", "solution": "def find_star_num(n):\n    return 6 * n * (n - 1) + 1"}
{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    return ord(char)"}
{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(lst):\n    \"\"\"\n    Write a python function to find the sum of even numbers at even positions of a list.\n    assert sum_even_and_even_index([5, 6, 12, 1, 18, 8]) == 30\n    \"\"\"\n    return sum(num for i, num in enumerate(lst) if i % 2 == 0 and num % 2 == 0)"}
{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    \"\"\"\n    This function takes in an integer n and finds the sum of the first n even natural numbers that are raised to the fifth power.\n    \"\"\"\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**5\n    return sum"}
{"task_id": "Mbpp/272", "solution": "def rear_extract(tuples_list):\n    \"\"\"\n    This function takes in a list of tuples and returns a list containing the rear element of each tuple.\n    \"\"\"\n    return [tup[-1] for tup in tuples_list]"}
{"task_id": "Mbpp/273", "solution": "def substract_elements(tuple1, tuple2):\n    return tuple(a - b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/274", "solution": "def even_binomial_Coeff_Sum(n):\n    \"\"\"\n    This function calculates the sum of even index binomial coefficients for a given positive integer n.\n    \"\"\"\n    # Initialize the sum of even index binomial coefficients\n    sum_even_index = 0\n\n    # Iterate through the range of n\n    for i in range(n + 1):\n        # Check if the index is even\n        if i % 2 == 0:\n            # Calculate the binomial coefficient for the even index\n            binomial_coefficient = math.comb(n, i)\n            # Add the binomial coefficient to the sum\n            sum_even_index += binomial_coefficient\n\n    return sum_even_index"}
{"task_id": "Mbpp/276", "solution": "import math\ndef volume_cylinder(radius, height):\n    return math.pi * radius**2 * height"}
{"task_id": "Mbpp/277", "solution": "def dict_filter(dictionary, n):\n    return {key: value for key, value in dictionary.items() if value >= n}"}
{"task_id": "Mbpp/278", "solution": "def count_first_elements(tup):\n    count = 0\n    for i in tup:\n        if isinstance(i, tuple):\n            break\n        count += 1\n    return count"}
{"task_id": "Mbpp/279", "solution": "def is_num_decagonal(n):\n    \"\"\"\n    Calculate the nth decagonal number.\n    \"\"\"\n    return 4 * n * (3 * n - 2)"}
{"task_id": "Mbpp/280", "solution": "def sequential_search(arr, element):\n    for i in range(len(arr)):\n        if arr[i] == element:\n            return True, i\n    return False, -1"}
{"task_id": "Mbpp/281", "solution": "def all_unique(lst):\n    return len(lst) == len(set(lst))"}
{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    return [a - b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/283", "solution": "def validate(num):\n    num_str = str(num)\n    for digit in num_str:\n        if num_str.count(digit) > int(digit):\n            return False\n    return True"}
{"task_id": "Mbpp/284", "solution": "def check_element(lst, element):\n    return all(item == element for item in lst)"}
{"task_id": "Mbpp/285", "solution": "import re\ndef text_match_two_three(text):\n    pattern = r'a(b{2,3})'\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/286", "solution": "def max_sub_array_sum_repeated(arr, n, k):\n    max_sum = float('-inf')\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, i + n):\n            current_sum += arr[j % n]\n            max_sum = max(max_sum, current_sum)\n    return max_sum * k"}
{"task_id": "Mbpp/287", "solution": "def square_Sum(n):\n    return sum([i**2 for i in range(2, 2*n+1, 2)])"}
{"task_id": "Mbpp/290", "solution": "def max_length(list_of_lists):\n    \"\"\"\n    Find the list of maximum length in a list of lists.\n\n    Args:\n        list_of_lists (list): A list of lists.\n\n    Returns:\n        tuple: A tuple containing the length of the longest list and the longest list itself.\n    \"\"\"\n    max_length = 0\n    longest_list = []\n\n    for lst in list_of_lists:\n        if len(lst) > max_length:\n            max_length = len(lst)\n            longest_list = lst\n\n    return max_length, longest_list"}
{"task_id": "Mbpp/292", "solution": "def find(a, b):\n    return a // b"}
{"task_id": "Mbpp/293", "solution": "import math\ndef otherside_rightangle(a, b):\n    \"\"\"\n    Calculate the length of the third side of a right-angled triangle given the lengths of the other two sides.\n\n    Args:\n        a (float): Length of one side of the triangle.\n        b (float): Length of the other side of the triangle.\n\n    Returns:\n        float: Length of the third side of the triangle.\n\n    Raises:\n        ValueError: If either a or b is not a positive number.\n\n    Examples:\n        >>> otherside_rightangle(3, 4)\n        5.0\n        >>> otherside_rightangle(5, 12)\n        13.0\n        >>> otherside_rightangle(7, 8)\n        10.63014581273465\n    \"\"\"\n    if a <= 0 or b <= 0:\n        raise ValueError(\"Both sides must be positive numbers.\")\n    return math.sqrt(a**2 + b**2)"}
{"task_id": "Mbpp/294", "solution": "def max_val(lst):\n    max_val = None\n    for item in lst:\n        if isinstance(item, (int, float)):\n            if max_val is None or item > max_val:\n                max_val = item\n    return max_val"}
{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    \"\"\"\n    Count inversions in an array.\n    \"\"\"\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count"}
{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    \"\"\"\n    Flattens a given nested list structure.\n\n    Args:\n        nested_list (list): The nested list to be flattened.\n\n    Returns:\n        list: The flattened list.\n    \"\"\"\n    flattened_list = []\n    for item in nested_list:\n        if isinstance(item, list):\n            flattened_list.extend(flatten_list(item))\n        else:\n            flattened_list.append(item)\n    return flattened_list"}
{"task_id": "Mbpp/299", "solution": "def max_aggregate(tuples_list):\n    \"\"\"\n    Calculate the maximum aggregate from the list of tuples.\n\n    Args:\n        tuples_list (list): List of tuples containing names and scores.\n\n    Returns:\n        tuple: Tuple containing the name with the maximum aggregate and the maximum aggregate score.\n    \"\"\"\n    max_aggregate = 0\n    max_name = \"\"\n    for name, score in tuples_list:\n        aggregate = score\n        if name in [n for n, _ in tuples_list]:\n            aggregate += sum(score for n, score in tuples_list if n == name)\n        if aggregate > max_aggregate:\n            max_aggregate = aggregate\n            max_name = name\n    return max_name, max_aggregate"}
{"task_id": "Mbpp/300", "solution": "import math\ndef count_binary_seq(n):\n    \"\"\"\n    Function to find the count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.\n    \"\"\"\n    # Initialize a list to store the count of binary sequences for each sum\n    count = [0] * (n + 1)\n    count[0] = 1  # There is one way to have a sum of 0 (all zeros)\n\n    # Iterate through the possible sums\n    for i in range(1, n + 1):\n        # Iterate through the possible sums for the first n bits\n        for j in range(i, 0, -1):\n            # Update the count for the current sum\n            count[j] += count[j - 1]\n\n    # The count of binary sequences is the sum of counts for all possible sums\n    return sum(count)"}
{"task_id": "Mbpp/301", "solution": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + max(dict_depth(v) for v in d.values()) if d else 0\n    return 0"}
{"task_id": "Mbpp/305", "solution": "def start_withp(words):\n    p_words = [word for word in words if word.startswith('p') or word.startswith('P')]\n    return p_words[0], p_words[1]"}
{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize a list to store the maximum sum of increasing subsequence\n    dp = [0] * n\n\n    # Initialize the maximum sum of increasing subsequence for the first element\n    dp[0] = arr[0]\n\n    # Iterate through the array to find the maximum sum of increasing subsequence\n    for j in range(1, n):\n        # If the current element is greater than the previous element, update the maximum sum\n        if arr[j] > arr[j - 1]:\n            dp[j] = max(dp[j], dp[j - 1] + arr[j])\n        else:\n            dp[j] = max(dp[j], arr[j])\n\n    # Return the maximum sum of increasing subsequence including the kth element\n    return dp[k - 1]"}
{"task_id": "Mbpp/308", "solution": "def large_product(list1, list2, n):\n    \"\"\"\n    Find the specified number of largest products from two given lists, selecting one factor from each list.\n\n    Args:\n        list1 (list): The first list of numbers.\n        list2 (list): The second list of numbers.\n        n (int): The number of largest products to find.\n\n    Returns:\n        list: A list of the specified number of largest products.\n\n    Raises:\n        ValueError: If the input lists are empty or if n is greater than the product of the lengths of the input lists.\n\n    \"\"\"\n    if not list1 or not list2:\n        raise ValueError(\"Input lists cannot be empty.\")\n    if n > len(list1) * len(list2):\n        raise ValueError(\"n cannot be greater than the product of the lengths of the input lists.\")\n\n    products = [a * b for a in list1 for b in list2]\n    products.sort(reverse=True)\n    return products[:n]"}
{"task_id": "Mbpp/309", "solution": "def maximum(a, b):\n    \"\"\"\n    This function takes two numbers as input and returns the maximum of the two.\n    \"\"\"\n    return max(a, b)"}
{"task_id": "Mbpp/310", "solution": "def string_to_tuple(input_string):\n    return tuple(input_string)"}
{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(n):\n    \"\"\"\n    Set the left most unset bit of a given number.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The number with the left most unset bit set.\n    \"\"\"\n    # Find the position of the left most unset bit\n    pos = 0\n    while n & (1 << pos):\n        pos += 1\n\n    # Set the left most unset bit\n    return n | (1 << pos)"}
{"task_id": "Mbpp/312", "solution": "import math\ndef volume_cone(radius, height):\n    return (1/3) * math.pi * radius**2 * height"}
{"task_id": "Mbpp/388", "solution": "def highest_Power_of_2(n):\n    power = 0\n    while 2 ** power <= n:\n        power += 1\n    return 2 ** (power - 1)"}
{"task_id": "Mbpp/389", "solution": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b"}
{"task_id": "Mbpp/390", "solution": "def add_string(lst, format_str):\n    return [format_str.format(i) for i in lst]"}
{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(keys, values, scores):\n    result = []\n    for i in range(len(keys)):\n        nested_dict = {keys[i]: {values[i]: scores[i]}}\n        result.append(nested_dict)\n    return result"}
{"task_id": "Mbpp/392", "solution": "def get_max_sum(n):\n    if n <= 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    if n == 4:\n        return 4\n    if n == 5:\n        return 5\n    if n == 6:\n        return 6\n    if n == 7:\n        return 7\n    if n == 8:\n        return 8\n    if n == 9:\n        return 9\n    if n == 10:\n        return 10\n    if n == 11:\n        return 11\n    if n == 12:\n        return 12\n    if n == 13:\n        return 13\n    if n == 14:\n        return 14\n    if n == 15:\n        return 15\n    if n == 16:\n        return 16\n    if n == 17:\n        return 17\n    if n == 18:\n        return 18\n    if n == 19:\n        return 19\n    if n == 20:\n        return 20\n    if n == 21:\n        return 21\n    if n == 22:\n        return 22\n    if n == 23:\n        return 23\n    if n == 24:\n        return 24\n    if n == 25:\n        return 25\n    if n == 26:\n        return 26\n    if n == 27:\n        return 27\n    if n == 28:\n        return 28\n    if n == 29:\n        return 29\n    if n == 30:\n        return 30\n    if n == 31:\n        return 31\n    if n == 32:\n        return 32\n    if n == 33:\n        return 33\n    if n == 34:\n        return 34\n    if n == 35:\n        return 35\n    if n == 36:\n        return 36\n    if n == 37:\n        return 37\n    if n == 38:\n        return 38\n    if n == 39:\n        return 39\n    if n == 40:\n        return 40\n    if n == 41:\n        return 41\n    if n == 42:\n        return 42\n    if n == 43:\n        return 43\n    if n == 44:\n        return 44\n    if n == 45:\n        return 45\n    if n == 46:\n        return 46\n    if n == 47:\n        return 47\n    if n == 48:\n        return 48\n    if n == 49:\n        return 49\n    if n == 50:\n        return 50\n    if n == 51:\n        return 51\n    if n == 52:\n        return 52\n    if n == 53:\n        return 53\n    if n == 54:\n        return 54\n    if n == 55:\n        return 5"}
{"task_id": "Mbpp/394", "solution": "def check_distinct(tup):\n    return len(tup) == len(set(tup))"}
{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None"}
{"task_id": "Mbpp/397", "solution": "def median_numbers(a, b, c):\n    \"\"\"\n    Find the median of three numbers.\n    \"\"\"\n    numbers = [a, b, c]\n    numbers.sort()\n    return numbers[1]"}
{"task_id": "Mbpp/398", "solution": "def sum_of_digits(numbers):\n    \"\"\"\n    Compute the sum of digits of each number in a given list.\n\n    Args:\n        numbers (list): A list of integers.\n\n    Returns:\n        int: The sum of digits of all numbers in the list.\n    \"\"\"\n    total_sum = 0\n    for number in numbers:\n        total_sum += sum(int(digit) for digit in str(number))\n    return total_sum"}
{"task_id": "Mbpp/404", "solution": "def minimum(a, b):\n    \"\"\"\n    Find the minimum of two numbers.\n\n    Args:\n        a (int or float): The first number.\n        b (int or float): The second number.\n\n    Returns:\n        int or float: The minimum of the two numbers.\n    \"\"\"\n    return a if a < b else b"}
{"task_id": "Mbpp/405", "solution": "def check_tuplex(tup, element):\n    return element in tup"}
{"task_id": "Mbpp/406", "solution": "def find_Parity(n):\n    return n % 2 == 0"}
{"task_id": "Mbpp/409", "solution": "def min_product_tuple(tuples_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns the minimum product of the tuples.\n    \"\"\"\n    min_product = float('inf')  # Initialize with positive infinity\n    for tup in tuples_list:\n        product = tup[0] * tup[1]  # Calculate the product of the tuple\n        if product < min_product:\n            min_product = product  # Update the minimum product if a smaller product is found\n    return min_product"}
{"task_id": "Mbpp/410", "solution": "def min_val(lst):\n    min_val = float('inf')\n    for item in lst:\n        if isinstance(item, (int, float)):\n            min_val = min(min_val, item)\n    return min_val"}
{"task_id": "Mbpp/412", "solution": "def remove_odd(lst):\n    return [x for x in lst if x % 2 == 0]"}
{"task_id": "Mbpp/413", "solution": "def extract_nth_element(tuples_list, n):\n    return [tup[n] for tup in tuples_list]"}
{"task_id": "Mbpp/414", "solution": "def overlapping(seq1, seq2):\n    \"\"\"\n    Check whether any value in seq1 exists in seq2.\n\n    Args:\n        seq1 (list): First sequence to check for overlap.\n        seq2 (list): Second sequence to check for overlap.\n\n    Returns:\n        bool: True if there is an overlap, False otherwise.\n    \"\"\"\n    return any(value in seq2 for value in seq1)"}
{"task_id": "Mbpp/415", "solution": "def max_Product(arr):\n    if len(arr) < 2:\n        return None\n    max_product = float('-inf')\n    max_pair = None\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            product = arr[i] * arr[j]\n            if product > max_product:\n                max_product = product\n                max_pair = (arr[i], arr[j])\n    return max_pair"}
{"task_id": "Mbpp/418", "solution": "def Find_Max(lst):\n    return max(lst, key=len)"}
{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    rounded_numbers = [round(num) for num in numbers]\n    total_sum = sum(rounded_numbers)\n    result = total_sum * len(numbers)\n    return result"}
{"task_id": "Mbpp/420", "solution": "def cube_Sum(n):\n    \"\"\"\n    Calculate the cube sum of the first n even natural numbers.\n\n    Args:\n        n (int): The number of even natural numbers to consider.\n\n    Returns:\n        int: The cube sum of the first n even natural numbers.\n    \"\"\"\n    return sum([i**3 for i in range(2, 2*n+1, 2)])"}
{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(tup, delimiter='-'):\n    return delimiter.join(map(str, tup))"}
{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    \"\"\"\n    This function calculates the average of cubes of first n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers to consider.\n\n    Returns:\n        float: The average of cubes of first n natural numbers.\n    \"\"\"\n    total = 0\n    for i in range(1, n+1):\n        total += i**3\n    return total / n"}
{"task_id": "Mbpp/424", "solution": "def extract_rear(tup):\n    return [s[-1] for s in tup]"}
{"task_id": "Mbpp/425", "solution": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count"}
{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(numbers):\n    return [num for num in numbers if num % 2 != 0]"}
{"task_id": "Mbpp/427", "solution": "def change_date_format(date_str):\n    \"\"\"\n    Convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n\n    Args:\n        date_str (str): The input date string in yyyy-mm-dd format.\n\n    Returns:\n        str: The date string in dd-mm-yyyy format.\n    \"\"\"\n    year, month, day = date_str.split('-')\n    return f\"{day}-{month}-{year}\""}
{"task_id": "Mbpp/428", "solution": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n\n    return arr"}
{"task_id": "Mbpp/429", "solution": "def and_tuples(t1, t2):\n    \"\"\"\n    Extracts the elementwise and tuples from the given two tuples.\n\n    Args:\n        t1 (tuple): The first input tuple.\n        t2 (tuple): The second input tuple.\n\n    Returns:\n        tuple: A tuple containing the elementwise and tuples.\n    \"\"\"\n    # Check if the input tuples have the same length\n    if len(t1) != len(t2):\n        raise ValueError(\"Input tuples must have the same length\")\n\n    # Initialize an empty list to store the elementwise and tuples\n    result = []\n\n    # Iterate through the tuples and perform elementwise and operation\n    for i in range(len(t1)):\n        result.append(t1[i] & t2[i])\n\n    # Convert the result list to a tuple and return\n    return tuple(result)"}
{"task_id": "Mbpp/430", "solution": "def parabola_directrix(a, b, c):\n    \"\"\"\n    Calculate the directrix of a parabola given its coefficients.\n\n    Args:\n        a (float): Coefficient of x^2\n        b (float): Coefficient of x\n        c (float): Constant term\n\n    Returns:\n        float: Directrix of the parabola\n    \"\"\"\n    directrix = c - (b**2) / (4 * a)\n    return directrix"}
{"task_id": "Mbpp/432", "solution": "def median_trapezium(a, b, c):\n    return (a + b + c) / 3"}
{"task_id": "Mbpp/433", "solution": "def check_greater(arr, num):\n    return all(num > x for x in arr)"}
{"task_id": "Mbpp/435", "solution": "def last_Digit(num):\n    return num % 10"}
{"task_id": "Mbpp/436", "solution": "def neg_nos(lst):\n    return [num for num in lst if num < 0]"}
{"task_id": "Mbpp/437", "solution": "def remove_odd(s):\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])"}
{"task_id": "Mbpp/439", "solution": "def multiple_to_single(numbers):\n    return int(''.join(map(str, numbers)))"}
{"task_id": "Mbpp/440", "solution": "import re\ndef find_adverb_position(sentence):\n    adverb_pattern = r'\\b\\w+ly\\b'\n    match = re.search(adverb_pattern, sentence)\n    if match:\n        start, end = match.span()\n        return start, end, match.group()\n    else:\n        return None"}
{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(size):\n    return 6 * size ** 2"}
{"task_id": "Mbpp/445", "solution": "def index_multiplication(tuple1, tuple2):\n    result = []\n    for i in range(len(tuple1)):\n        result.append(tuple(a * b for a, b in zip(tuple1[i], tuple2[i])))\n    return tuple(result)"}
{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for item in lst:\n        count += tup.count(item)\n    return count"}
{"task_id": "Mbpp/447", "solution": "def cube_nums(nums):\n    return [num ** 3 for num in nums]"}
{"task_id": "Mbpp/448", "solution": "def cal_sum(n):\n    \"\"\"\n    Calculate the sum of Perrin numbers up to the nth term.\n\n    Args:\n        n (int): The number of terms to calculate the sum for.\n\n    Returns:\n        int: The sum of Perrin numbers up to the nth term.\n    \"\"\"\n    if n <= 0:\n        return 0\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    else:\n        perrin = [3, 0, 2]\n        for i in range(3, n):\n            perrin.append(perrin[i-2] + perrin[i-3])\n        return sum(perrin)"}
{"task_id": "Mbpp/450", "solution": "def extract_string(lst, size):\n    return [s for s in lst if len(s) == size]"}
{"task_id": "Mbpp/451", "solution": "def remove_whitespaces(input_string):\n    return input_string.replace(\" \", \"\")"}
{"task_id": "Mbpp/453", "solution": "def sumofFactors(n):\n    sum = 0\n    for i in range(2, n + 1, 2):\n        if n % i == 0:\n            sum += i\n    return sum"}
{"task_id": "Mbpp/454", "solution": "import re\ndef text_match_wordz(text):\n    pattern = r'\\b\\w*z.\\w*\\b'\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/455", "solution": "def check_monthnumb_number(month):\n    \"\"\"\n    Check whether the given month number contains 31 days or not.\n    \"\"\"\n    # List of months with 31 days\n    months_with_31_days = [1, 3, 5, 7, 8, 10, 12]\n    \n    # Check if the given month number is in the list of months with 31 days\n    if month in months_with_31_days:\n        return True\n    else:\n        return False"}
{"task_id": "Mbpp/456", "solution": "def reverse_string_list(string_list):\n    return [s[::-1] for s in string_list]"}
{"task_id": "Mbpp/457", "solution": "def Find_Min(lst):\n    \"\"\"\n    Find the sublist with the minimum length in a list of lists.\n\n    Args:\n        lst (list): A list of lists.\n\n    Returns:\n        list: The sublist with the minimum length.\n    \"\"\"\n    if not lst:\n        return None\n\n    min_length = float('inf')\n    min_sublist = None\n\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n            min_sublist = sublist\n\n    return min_sublist"}
{"task_id": "Mbpp/458", "solution": "def rectangle_area(length, width):\n    \"\"\"\n    Calculate the area of a rectangle.\n\n    Args:\n        length (float): The length of the rectangle.\n        width (float): The width of the rectangle.\n\n    Returns:\n        float: The area of the rectangle.\n    \"\"\"\n    return length * width"}
{"task_id": "Mbpp/459", "solution": "def remove_uppercase(s):\n    return ''.join(c for c in s if c.islower())"}
{"task_id": "Mbpp/460", "solution": "def Extract(lst):\n    return [sublist[0] for sublist in lst]"}
{"task_id": "Mbpp/462", "solution": "from itertools import combinations\ndef combinations_list(lst):\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result"}
{"task_id": "Mbpp/463", "solution": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n\n    max_product = min_product = result = arr[0]\n\n    for num in arr[1:]:\n        if num < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n\n        result = max(result, max_product)\n\n    return result"}
{"task_id": "Mbpp/465", "solution": "def drop_empty(dictionary):\n    return {key: value for key, value in dictionary.items() if value is not None}"}
{"task_id": "Mbpp/468", "solution": "def max_product(arr):\n    max_product = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[j] > arr[i]:\n                product = arr[i] * arr[j]\n                if product > max_product:\n                    max_product = product\n    return max_product"}
{"task_id": "Mbpp/470", "solution": "def add_pairwise(tup):\n    return tuple(a + b for a, b in zip(tup, tup[1:]))"}
{"task_id": "Mbpp/471", "solution": "def find_remainder(arr, n):\n    product = 1\n    for num in arr:\n        product = (product * num) % n\n    return product"}
{"task_id": "Mbpp/472", "solution": "def check_consecutive(lst):\n    return sorted(lst) == list(range(min(lst), max(lst)+1))\n\n# Test cases\nassert check_consecutive([1,2,3,4,5]) == True\nassert check_consecutive([1,2,3,5,6]) == False\nassert check_consecutive([10,11,12,13,14]) == True\nassert check_consecutive([1,3,5,7,9]) == False"}
{"task_id": "Mbpp/473", "solution": "def tuple_intersection(list1, list2):\n    \"\"\"\n    Find the tuple intersection of elements in the given tuple list irrespective of their order.\n    \"\"\"\n    # Convert each tuple in the lists to a set to ignore order\n    set1 = {frozenset(t) for t in list1}\n    set2 = {frozenset(t) for t in list2}\n    \n    # Find the intersection of the sets\n    intersection = set1.intersection(set2)\n    \n    # Convert the intersection back to a list of tuples\n    result = [tuple(t) for t in intersection]\n    \n    return result"}
{"task_id": "Mbpp/474", "solution": "def replace_char(string, old_char, new_char):\n    return string.replace(old_char, new_char)"}
{"task_id": "Mbpp/475", "solution": "def sort_counter(counter):\n    return sorted(counter.items(), key=lambda x: x[1], reverse=True)"}
{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    if not arr:\n        return 0\n    return max(arr) + min(arr)"}
{"task_id": "Mbpp/477", "solution": "def is_lower(s):\n    return s.lower()"}
{"task_id": "Mbpp/478", "solution": "def remove_lowercase(s):\n    return ''.join(c for c in s if c.isupper())"}
{"task_id": "Mbpp/479", "solution": "def first_Digit(num):\n    \"\"\"\n    This function takes a number as input and returns the first digit of the number.\n    \"\"\"\n    # Convert the number to a string\n    num_str = str(num)\n    \n    # Return the first character of the string as an integer\n    return int(num_str[0])"}
{"task_id": "Mbpp/554", "solution": "def Split(lst):\n    return [x for x in lst if x % 2 != 0]"}
{"task_id": "Mbpp/555", "solution": "def difference(n):\n    sum_of_cubes = sum([i**3 for i in range(1, n+1)])\n    sum_of_natural_numbers = sum(range(1, n+1))\n    return sum_of_cubes - sum_of_natural_numbers"}
{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr, n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            if (arr[i] ^ arr[j]) % 2 != 0:\n                count += 1\n    return count"}
{"task_id": "Mbpp/557", "solution": "def toggle_string(s):\n    return s.swapcase()"}
{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1, num2):\n    \"\"\"\n    Calculate the sum of the per-digit difference between two integers.\n\n    Args:\n        num1 (int): The first integer.\n        num2 (int): The second integer.\n\n    Returns:\n        int: The sum of the per-digit difference between the two integers.\n    \"\"\"\n    # Convert the integers to strings to iterate over their digits\n    str_num1 = str(num1)\n    str_num2 = str(num2)\n\n    # Initialize the sum of differences\n    sum_diff = 0\n\n    # Iterate over the digits of the two numbers\n    for i in range(max(len(str_num1), len(str_num2))):\n        # Get the digits at the current position, or 0 if the number is shorter\n        digit1 = int(str_num1[i]) if i < len(str_num1) else 0\n        digit2 = int(str_num2[i]) if i < len(str_num2) else 0\n\n        # Calculate the absolute difference between the digits and add it to the sum\n        sum_diff += abs(digit1 - digit2)\n\n    return sum_diff"}
{"task_id": "Mbpp/559", "solution": "def max_sub_array_sum(arr, n):\n    max_so_far = 0\n    max_ending_here = 0\n\n    for i in range(n):\n        max_ending_here = max_ending_here + arr[i]\n        if max_ending_here < 0:\n            max_ending_here = 0\n        elif max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n\n    return max_so_far"}
{"task_id": "Mbpp/560", "solution": "def union_elements(tuple1, tuple2):\n    \"\"\"\n    Find the union of the elements of two given tuples and output them in sorted order.\n\n    Args:\n        tuple1 (tuple): The first input tuple.\n        tuple2 (tuple): The second input tuple.\n\n    Returns:\n        tuple: The sorted union of the elements of the input tuples.\n    \"\"\"\n    # Combine the two tuples and convert to a set to remove duplicates\n    union_set = set(tuple1) | set(tuple2)\n    # Convert the set back to a tuple and sort it\n    union_tuple = tuple(sorted(union_set))\n    return union_tuple"}
{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(lst):\n    max_length = 0\n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n    return max_length"}
{"task_id": "Mbpp/563", "solution": "def extract_values(string):\n    \"\"\"\n    Extract values between quotation marks from a string.\n\n    Args:\n        string (str): Input string containing values between quotation marks.\n\n    Returns:\n        list: List of values extracted from the input string.\n    \"\"\"\n    values = []\n    start_index = 0\n    while True:\n        start_index = string.find('\"', start_index)\n        if start_index == -1:\n            break\n        end_index = string.find('\"', start_index + 1)\n        if end_index == -1:\n            break\n        values.append(string[start_index + 1:end_index])\n        start_index = end_index + 1\n    return values"}
{"task_id": "Mbpp/564", "solution": "def count_pairs(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] != arr[j]:\n                count += 1\n    return count\n\n# Test cases\nassert count_pairs([1,2,1]) == 2"}
{"task_id": "Mbpp/565", "solution": "def split(string):\n    return list(string)"}
{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    \"\"\"\n    Write a function to get the sum of the digits of a non-negative integer.\n    assert sum_digits(345)==12\n    \"\"\"\n    return sum(int(digit) for digit in str(n))"}
{"task_id": "Mbpp/567", "solution": "def issort_list(lst):\n    return lst == sorted(lst)"}
{"task_id": "Mbpp/568", "solution": "def empty_list(n):\n    return [{} for _ in range(n)]"}
{"task_id": "Mbpp/569", "solution": "def sort_sublists(lst):\n    return [sorted(sublist) for sublist in lst]"}
{"task_id": "Mbpp/572", "solution": "def two_unique_nums(lists):\n    unique_nums = []\n    for lst in lists:\n        unique_nums.extend(set(lst))\n    return list(set(unique_nums))"}
{"task_id": "Mbpp/573", "solution": "def unique_product(lst):\n    unique_nums = set(lst)\n    product = 1\n    for num in unique_nums:\n        product *= num\n    return product"}
{"task_id": "Mbpp/576", "solution": "def is_Sub_Array(main_list, sub_list):\n    \"\"\"\n    Check if sub_list is a sublist of main_list.\n\n    Args:\n        main_list (list): The main list to check against.\n        sub_list (list): The sublist to check for.\n\n    Returns:\n        bool: True if sub_list is a sublist of main_list, False otherwise.\n    \"\"\"\n    if not sub_list:\n        return True\n    if len(sub_list) > len(main_list):\n        return False\n    for i in range(len(main_list) - len(sub_list) + 1):\n        if main_list[i:i+len(sub_list)] == sub_list:\n            return True\n    return False"}
{"task_id": "Mbpp/577", "solution": "def last_Digit_Factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 6\n    elif n == 4:\n        return 4\n    else:\n        return 0"}
{"task_id": "Mbpp/578", "solution": "def interleave_lists(list1, list2, list3):\n    return [item for sublist in zip(list1, list2, list3) for item in sublist]"}
{"task_id": "Mbpp/579", "solution": "def find_dissimilar(tup1, tup2):\n    \"\"\"\n    Find the dissimilar elements in the given two tuples.\n\n    Args:\n        tup1 (tuple): The first tuple.\n        tup2 (tuple): The second tuple.\n\n    Returns:\n        tuple: A tuple containing the dissimilar elements.\n    \"\"\"\n    dissimilar_elements = tuple(set(tup1) ^ set(tup2))\n    return dissimilar_elements"}
{"task_id": "Mbpp/580", "solution": "def extract_even(nested_tuple):\n    def is_even(x):\n        return x % 2 == 0\n\n    def extract_even_recursive(t):\n        if isinstance(t, tuple):\n            return tuple(extract_even_recursive(x) for x in t if is_even(x))\n        else:\n            return t\n\n    return extract_even_recursive(nested_tuple)"}
{"task_id": "Mbpp/581", "solution": "import math\ndef surface_Area(base_edge, height):\n    \"\"\"\n    Calculate the surface area of a square pyramid with a given base edge and height.\n\n    Args:\n        base_edge (float): The length of the base edge of the square pyramid.\n        height (float): The height of the square pyramid.\n\n    Returns:\n        float: The surface area of the square pyramid.\n    \"\"\"\n    base_area = base_edge ** 2\n    slant_height = math.sqrt((base_edge / 2) ** 2 + height ** 2)\n    lateral_area = 2 * base_edge * slant_height\n    total_surface_area = base_area + lateral_area\n    return total_surface_area"}
{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    if n <= 1:\n        return 1\n    catalan = [0] * (n + 1)\n    catalan[0] = catalan[1] = 1\n    for i in range(2, n + 1):\n        catalan[i] = 0\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n    return catalan[n]"}
{"task_id": "Mbpp/585", "solution": "def expensive_items(data, n):\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n\n    Args:\n        data (list): A list of dictionaries representing items with 'name' and 'price' keys.\n        n (int): The number of most expensive items to find.\n\n    Returns:\n        list: A list of dictionaries representing the n most expensive items.\n    \"\"\"\n    # Sort the data by price in descending order\n    sorted_data = sorted(data, key=lambda x: x['price'], reverse=True)\n\n    # Return the first n items from the sorted data\n    return sorted_data[:n]"}
{"task_id": "Mbpp/586", "solution": "def split_Arr(arr, n):\n    return arr[n:] + arr[:n]"}
{"task_id": "Mbpp/587", "solution": "def list_tuple(lst):\n    return tuple(lst)"}
{"task_id": "Mbpp/588", "solution": "def big_diff(nums):\n    return max(nums) - min(nums)"}
{"task_id": "Mbpp/589", "solution": "def perfect_squares(start, end):\n    \"\"\"\n    Find perfect squares between two given numbers.\n\n    Args:\n        start (int): The starting number.\n        end (int): The ending number.\n\n    Returns:\n        list: A list of perfect squares between the given numbers.\n    \"\"\"\n    return [num for num in range(start, end + 1) if int(num ** 0.5) ** 2 == num]"}
{"task_id": "Mbpp/590", "solution": "import math\ndef polar_rect(r, theta):\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y)"}
{"task_id": "Mbpp/591", "solution": "def swap_List(newList):\n    newList[0], newList[-1] = newList[-1], newList[0]\n    return newList"}
{"task_id": "Mbpp/592", "solution": "def sum_of_product(n):\n    \"\"\"\n    Calculate the sum of the product of consecutive binomial coefficients.\n\n    Args:\n        n (int): The number of terms in the sum.\n\n    Returns:\n        int: The sum of the product of consecutive binomial coefficients.\n    \"\"\"\n    result = 0\n    for i in range(1, n + 1):\n        result += i * (i - 1)\n    return result\n\n# Test cases\nassert sum_of_product(3) == 15"}
{"task_id": "Mbpp/593", "solution": "def removezero_ip(ip):\n    \"\"\"\n    Remove leading zeroes from an IP address.\n\n    Args:\n        ip (str): The IP address to remove leading zeroes from.\n\n    Returns:\n        str: The IP address with leading zeroes removed.\n    \"\"\"\n    return '.'.join([str(int(octet)) for octet in ip.split('.')])"}
{"task_id": "Mbpp/594", "solution": "def diff_even_odd(lst):\n    first_even = None\n    first_odd = None\n    for num in lst:\n        if first_even is None and num % 2 == 0:\n            first_even = num\n        elif first_odd is None and num % 2 != 0:\n            first_odd = num\n        if first_even is not None and first_odd is not None:\n            return first_even - first_odd\n    return None"}
{"task_id": "Mbpp/596", "solution": "import sys\ndef tuple_size(t):\n    return sys.getsizeof(t)"}
{"task_id": "Mbpp/597", "solution": "def find_kth(arr1, arr2, k):\n    \"\"\"\n    Find the kth element from the given two sorted arrays.\n\n    Args:\n        arr1 (list): First sorted array.\n        arr2 (list): Second sorted array.\n        k (int): The kth element to find.\n\n    Returns:\n        int: The kth element from the merged sorted array.\n\n    Raises:\n        ValueError: If k is out of bounds.\n\n    \"\"\"\n    if k < 1 or k > len(arr1) + len(arr2):\n        raise ValueError(\"k is out of bounds\")\n\n    # Initialize pointers for both arrays\n    i, j = 0, 0\n\n    # Iterate until we find the kth element\n    while i + j < k:\n        if i == len(arr1):\n            j += 1\n        elif j == len(arr2):\n            i += 1\n        elif arr1[i] < arr2[j]:\n            i += 1\n        else:\n            j += 1\n\n    # Return the kth element\n    if i < len(arr1):\n        return arr1[i]\n    else:\n        return arr2[j - 1]"}
{"task_id": "Mbpp/598", "solution": "def armstrong_number(num):\n    \"\"\"\n    Check whether the given number is armstrong or not.\n    \"\"\"\n    # Convert the number to a string to iterate over its digits\n    num_str = str(num)\n    # Calculate the sum of the cubes of the digits\n    sum_of_cubes = sum(int(digit) ** 3 for digit in num_str)\n    # Check if the sum of the cubes is equal to the original number\n    return sum_of_cubes == num"}
{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    \"\"\"\n    Calculate the sum and average of the first n natural numbers.\n\n    Args:\n        n (int): The number of natural numbers to consider.\n\n    Returns:\n        tuple: A tuple containing the sum and average of the first n natural numbers.\n    \"\"\"\n    sum_n = n * (n + 1) // 2\n    average_n = sum_n / n\n    return sum_n, average_n"}
{"task_id": "Mbpp/600", "solution": "def is_Even(num):\n    return num % 2 == 0"}
{"task_id": "Mbpp/602", "solution": "def first_repeated_char(s):\n    seen = set()\n    for char in s:\n        if char in seen:\n            return char\n        seen.add(char)\n    return None"}
{"task_id": "Mbpp/603", "solution": "def get_ludic(n):\n    ludic_numbers = [1, 2]\n    i = 3\n    while len(ludic_numbers) < n:\n        if all(i % j != 0 for j in ludic_numbers):\n            ludic_numbers.append(i)\n        i += 1\n    return ludic_numbers"}
{"task_id": "Mbpp/604", "solution": "def reverse_words(s):\n    return ' '.join(s.split()[::-1])"}
{"task_id": "Mbpp/605", "solution": "def prime_num(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/606", "solution": "import math\ndef radian_degree(degrees):\n    \"\"\"\n    Convert degrees to radians.\n    \"\"\"\n    return math.radians(degrees)"}
{"task_id": "Mbpp/607", "solution": "import re\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return match.group(), match.start(), match.end()\n    else:\n        return None, None, None"}
{"task_id": "Mbpp/608", "solution": "def bell_Number(n):\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]"}
{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst, k):\n    \"\"\"\n    Write a python function which takes a list and returns a list with the same elements, but the k'th element removed.\n    assert remove_kth_element([1,1,2,3,4,4,5,1],3)==[1, 1, 3, 4, 4, 5, 1]\n    \"\"\"\n    if k < 1 or k > len(lst):\n        return lst\n    return lst[:k-1] + lst[k:]"}
{"task_id": "Mbpp/611", "solution": "def max_of_nth(matrix, n):\n    \"\"\"\n    Given a matrix represented as a list of lists, returns the max of the n'th column.\n    \"\"\"\n    return max(row[n] for row in matrix)"}
{"task_id": "Mbpp/612", "solution": "def merge(list_of_lists):\n    \"\"\"\n    Write a python function which takes a list of lists, where each sublist has two elements, and returns a list of two lists where the first list has the first element of each sublist and the second one has the second.\n    assert merge([['x', 'y'], ['a', 'b'], ['m', 'n']]) == [['x', 'a', 'm'], ['y', 'b', 'n']]\n    \"\"\"\n    first_elements = [sublist[0] for sublist in list_of_lists]\n    second_elements = [sublist[1] for sublist in list_of_lists]\n    return [first_elements, second_elements]"}
{"task_id": "Mbpp/614", "solution": "def cummulative_sum(tup_list):\n    \"\"\"\n    This function takes a list of tuples as input and returns the cumulative sum of all the values present in the tuples.\n    \"\"\"\n    # Initialize a variable to store the cumulative sum\n    cum_sum = 0\n    \n    # Iterate through each tuple in the list\n    for tup in tup_list:\n        # Add the sum of the tuple to the cumulative sum\n        cum_sum += sum(tup)\n    \n    # Return the cumulative sum\n    return cum_sum"}
{"task_id": "Mbpp/615", "solution": "def average_tuple(tuples):\n    \"\"\"\n    This function takes a tuple of tuples and returns the average value for each tuple as a list.\n    \"\"\"\n    averages = []\n    for tup in tuples:\n        averages.append(sum(tup) / len(tup))\n    return averages"}
{"task_id": "Mbpp/616", "solution": "def tuple_modulo(tuple1, tuple2):\n    \"\"\"\n    Perform element-wise modulo operation on two tuples of the same length.\n\n    Args:\n        tuple1 (tuple): The first input tuple.\n        tuple2 (tuple): The second input tuple.\n\n    Returns:\n        tuple: A new tuple containing the results of the element-wise modulo operation.\n\n    Raises:\n        ValueError: If the input tuples are not of the same length.\n\n    Examples:\n        >>> tuple_modulo((10, 4, 5, 6), (5, 6, 7, 5))\n        (0, 4, 5, 1)\n    \"\"\"\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Input tuples must be of the same length\")\n\n    return tuple(a % b for a, b in zip(tuple1, tuple2))"}
{"task_id": "Mbpp/618", "solution": "def div_list(list1, list2):\n    \"\"\"\n    Divide two lists element-wise.\n\n    Args:\n        list1 (list): The first list.\n        list2 (list): The second list.\n\n    Returns:\n        list: A new list containing the element-wise division of list1 and list2.\n\n    Raises:\n        ValueError: If the input lists have different lengths.\n\n    Examples:\n        >>> div_list([4, 5, 6], [1, 2, 3])\n        [4.0, 2.5, 2.0]\n    \"\"\"\n    if len(list1) != len(list2):\n        raise ValueError(\"Input lists must have the same length.\")\n\n    return [float(a) / b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/619", "solution": "def move_num(s):\n    num = ''.join(filter(str.isdigit, s))\n    non_num = ''.join(filter(str.isalpha, s))\n    return non_num + num"}
{"task_id": "Mbpp/620", "solution": "def largest_subset(nums):\n    nums.sort()\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)"}
{"task_id": "Mbpp/622", "solution": "def get_median(list1, list2, size):\n    merged_list = sorted(list1 + list2)\n    return merged_list[size // 2] if size % 2 != 0 else (merged_list[size // 2 - 1] + merged_list[size // 2]) / 2"}
{"task_id": "Mbpp/623", "solution": "def nth_nums(nums, n):\n    return [num ** n for num in nums]"}
{"task_id": "Mbpp/624", "solution": "def is_upper(s):\n    return s.upper()"}
{"task_id": "Mbpp/626", "solution": "import math\ndef triangle_area(radius):\n    if radius <= 0:\n        return None\n    else:\n        return 0.5 * radius * radius * math.sqrt(3)"}
{"task_id": "Mbpp/628", "solution": "def replace_spaces(input_string):\n    return input_string.replace(\" \", \"%20\")"}
{"task_id": "Mbpp/629", "solution": "def find_even_numbers(numbers):\n    \"\"\"\n    This function takes a list of numbers as input and returns a new list containing only the even numbers.\n\n    Args:\n        numbers (list): A list of numbers.\n\n    Returns:\n        list: A list containing only the even numbers from the input list.\n    \"\"\"\n    return [num for num in numbers if num % 2 == 0]\n\n# Test the function\nassert find_even_numbers([1, 2, 3, 4, 5]) == [2, 4]"}
{"task_id": "Mbpp/630", "solution": "def get_coordinates(coordinate):\n    x, y = coordinate\n    adjacent_coordinates = []\n    for dx in [-1, 0, 1]:\n        for dy in [-1, 0, 1]:\n            if dx == 0 and dy == 0:\n                continue\n            adjacent_coordinates.append([x + dx, y + dy])\n    return adjacent_coordinates"}
{"task_id": "Mbpp/631", "solution": "def replace_spaces(input_string):\n    return input_string.replace(' ', '_').replace('_', ' ')"}
{"task_id": "Mbpp/632", "solution": "def move_zero(lst):\n    non_zero = [x for x in lst if x != 0]\n    zero = [x for x in lst if x == 0]\n    return non_zero + zero"}
{"task_id": "Mbpp/633", "solution": "def pair_xor_sum(nums):\n    \"\"\"\n    This function calculates the sum of XOR of all pairs of numbers in the given list.\n\n    Args:\n        nums (list): A list of integers.\n\n    Returns:\n        int: The sum of XOR of all pairs of numbers in the list.\n    \"\"\"\n    xor_sum = 0\n    for i in range(len(nums)):\n        for j in range(i+1, len(nums)):\n            xor_sum += nums[i] ^ nums[j]\n    return xor_sum\n\n# Test the function\nassert pair_xor_sum([5, 9, 7, 6]) == 47"}
{"task_id": "Mbpp/635", "solution": "def heap_sort(arr):\n    def heapify(arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[i] < arr[left]:\n            largest = left\n\n        if right < n and arr[largest] < arr[right]:\n            largest = right\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]\n        heapify(arr, i, 0)\n\n    return arr"}
{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(amount, cost):\n    \"\"\"\n    Check whether the given amount has no profit and no loss\n    \"\"\"\n    return amount == cost"}
{"task_id": "Mbpp/638", "solution": "import math\ndef wind_chill(velocity, temperature):\n    \"\"\"\n    Calculate the wind chill index rounded to the next integer given the wind velocity in km/h and a temperature in celsius.\n    \"\"\"\n    wind_chill_index = 13.12 + 0.6215 * temperature - 11.37 * math.pow(velocity, 0.16) + 0.3965 * temperature * math.pow(velocity, 0.16)\n    return round(wind_chill_index)"}
{"task_id": "Mbpp/639", "solution": "def sample_nam(names):\n    return sum(len(name) for name in names if name[0].isupper())"}
{"task_id": "Mbpp/641", "solution": "def is_nonagonal(n):\n    return n * (7 * n - 5) // 2"}
{"task_id": "Mbpp/643", "solution": "import re\ndef text_match_wordz_middle(text):\n    pattern = r'\\Bz\\B'\n    return bool(re.search(pattern, text))"}
{"task_id": "Mbpp/644", "solution": "def reverse_Array_Upto_K(arr, k):\n    \"\"\"\n    Reverses the elements of the array up to the given position k.\n\n    Args:\n        arr (list): The input array.\n        k (int): The position up to which the array should be reversed.\n\n    Returns:\n        list: The modified array with elements reversed up to position k.\n    \"\"\"\n    # Reverse the elements up to position k\n    arr[:k] = arr[:k][::-1]\n    return arr"}
{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(tup, dictionary):\n    return tup + (dictionary,)"}
{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath(matrix):\n    n = len(matrix)\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n\n    for i in range(1, n):\n        dp[i][0] = dp[i-1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i-1] + matrix[0][i]\n\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i-1][j], dp[i][j-1]) + matrix[i][j]\n\n    max_avg = float('-inf')\n    for i in range(n):\n        for j in range(n):\n            avg = dp[i][j] / (i + j + 1)\n            max_avg = max(max_avg, avg)\n\n    return max_avg"}
{"task_id": "Mbpp/722", "solution": "def filter_data(data, min_height, min_weight):\n    return {k: v for k, v in data.items() if v[0] >= min_height and v[1] >= min_weight}"}
{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    \"\"\"\n    The input is defined as two lists of the same length. Write a function to count indices where the lists have the same values.\n    assert count_same_pair([1, 2, 3, 4, 5, 6, 7, 8],[2, 2, 3, 1, 2, 6, 7, 9])==4\n    \"\"\"\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    return count"}
{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    result = base ** power\n    return sum(int(digit) for digit in str(result))"}
{"task_id": "Mbpp/725", "solution": "def extract_quotation(s):\n    return [word.strip('\"') for word in s.split() if '\"' in word]"}
{"task_id": "Mbpp/726", "solution": "def multiply_elements(t):\n    \"\"\"\n    This function takes a tuple of numbers as input and returns a tuple of length N where the i-th element of the tuple is equal to t_i * t_{i+1}.\n    \"\"\"\n    return tuple(t[i] * t[i+1] for i in range(len(t)-1))"}
{"task_id": "Mbpp/728", "solution": "def sum_list(list1, list2):\n    \"\"\"\n    This function takes as input two lists [a_1,...,a_n], [b_1,...,b_n] and returns [a_1+b_1,...,a_n+b_n].\n    \"\"\"\n    return [a + b for a, b in zip(list1, list2)]"}
{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(lst):\n    result = []\n    for i in range(len(lst)):\n        if i == 0 or lst[i] != lst[i-1]:\n            result.append(lst[i])\n    return result"}
{"task_id": "Mbpp/731", "solution": "import math\ndef lateralsurface_cone(r, h):\n    \"\"\"\n    Calculate the lateral surface area of a cone given radius r and height h.\n    \n    Args:\n        r (float): Radius of the cone's base.\n        h (float): Height of the cone.\n    \n    Returns:\n        float: Lateral surface area of the cone.\n    \"\"\"\n    l = math.sqrt(r**2 + h**2)\n    return math.pi * r * l"}
{"task_id": "Mbpp/732", "solution": "def replace_specialchar(input_string):\n    return input_string.replace(' ', ':').replace(',', ':').replace('.', ':')"}
{"task_id": "Mbpp/733", "solution": "def find_first_occurrence(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n\n    while left <= right:\n        mid = left + (right - left) // 2\n\n        if arr[mid] == target:\n            result = mid\n            right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result"}
{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod(arr):\n    n = len(arr)\n    total_sum = 0\n    for i in range(n):\n        for j in range(i, n):\n            subarray = arr[i:j+1]\n            subarray_product = 1\n            for num in subarray:\n                subarray_product *= num\n            total_sum += subarray_product\n    return total_sum"}
{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(n):\n    # Convert the number to binary representation\n    binary = bin(n)[2:]\n    \n    # Toggle bits except the first and the last bit\n    toggled_binary = binary[0] + ''.join('1' if bit == '0' else '0' for bit in binary[1:-1]) + binary[-1]\n    \n    # Convert the toggled binary representation back to decimal\n    toggled_decimal = int(toggled_binary, 2)\n    \n    return toggled_decimal"}
{"task_id": "Mbpp/736", "solution": "def left_insertion(arr, val):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] < val:\n            left = mid + 1\n        else:\n            right = mid\n    return left"}
{"task_id": "Mbpp/737", "solution": "import re\ndef check_str(s):\n    \"\"\"\n    Check whether the given string is starting with a vowel or not using regex.\n    \"\"\"\n    pattern = r\"^[aeiouAEIOU]\"\n    return bool(re.match(pattern, s))"}
{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    \"\"\"\n    Find the index of the smallest triangular number with n digits.\n\n    Args:\n        n (int): The number of digits.\n\n    Returns:\n        int: The index of the smallest triangular number with n digits.\n    \"\"\"\n    def triangular_number(index):\n        return index * (index + 1) // 2\n\n    index = 1\n    while True:\n        if len(str(triangular_number(index))) == n:\n            return index\n        index += 1"}
{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(tup):\n    \"\"\"\n    Convert the given tuple to a key-value dictionary using adjacent elements.\n    \"\"\"\n    return {tup[i]: tup[i+1] for i in range(0, len(tup)-1, 2)}"}
{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(string):\n    return len(set(string)) == 1"}
{"task_id": "Mbpp/742", "solution": "import math\ndef area_tetrahedron(side_length):\n    \"\"\"\n    Calculate the area of a regular tetrahedron.\n\n    Args:\n        side_length (float): The length of a side of the tetrahedron.\n\n    Returns:\n        float: The area of the tetrahedron.\n    \"\"\"\n    area = math.sqrt(3) * (side_length ** 2)\n    return area"}
{"task_id": "Mbpp/743", "solution": "def rotate_right(lst, n):\n    \"\"\"\n    Rotate a given list by specified number of items to the right direction.\n\n    Args:\n        lst (list): The input list to be rotated.\n        n (int): The number of items to rotate the list to the right.\n\n    Returns:\n        list: The rotated list.\n    \"\"\"\n    n = n % len(lst)  # Handle cases where n is greater than the length of the list\n    return lst[-n:] + lst[:-n]"}
{"task_id": "Mbpp/744", "solution": "def check_none(tup):\n    return any(item is None for item in tup)"}
{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum + 1):\n        if all(int(digit) != 0 and num % int(digit) == 0 for digit in str(num)):\n            result.append(num)\n    return result"}
{"task_id": "Mbpp/748", "solution": "def capital_words_spaces(s):\n    return ' '.join(word for word in s.split(' ') if word.istitle())"}
{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(lst):\n    return sorted(lst, key=lambda x: int(x))"}
{"task_id": "Mbpp/750", "solution": "def add_tuple(lst, tup):\n    \"\"\"\n    Add the given tuple to the given list.\n\n    Args:\n        lst (list): The list to which the tuple will be added.\n        tup (tuple): The tuple to be added to the list.\n\n    Returns:\n        list: The updated list with the tuple added.\n    \"\"\"\n    lst.extend(tup)\n    return lst"}
{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    n = len(arr)\n    for i in range(n // 2 - 1, -1, -1):\n        if 2 * i + 1 < n and arr[i] > arr[2 * i + 1]:\n            return False\n        if 2 * i + 2 < n and arr[i] > arr[2 * i + 2]:\n            return False\n    return True"}
{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n-1) + 2*jacobsthal_num(n-2)"}
{"task_id": "Mbpp/753", "solution": "def min_k(records, k):\n    \"\"\"\n    Find the minimum k records from a tuple list.\n\n    Args:\n        records (list): A list of tuples, where each tuple contains a record.\n        k (int): The number of minimum records to find.\n\n    Returns:\n        list: A list of the minimum k records.\n\n    Raises:\n        ValueError: If k is greater than the number of records.\n\n    Examples:\n        >>> min_k([('Manjeet', 10), ('Akshat', 4), ('Akash', 2), ('Nikhil', 8)], 2)\n        [('Akash', 2), ('Akshat', 4)]\n    \"\"\"\n    if k > len(records):\n        raise ValueError(\"k cannot be greater than the number of records\")\n\n    return sorted(records, key=lambda x: x[1])[:k]"}
{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    \"\"\"\n    This function takes three lists as input and returns a list of common elements at the same index in all three lists.\n    \"\"\"\n    common_elements = []\n    for i in range(min(len(l1), len(l2), len(l3))):\n        if l1[i] == l2[i] == l3[i]:\n            common_elements.append(l1[i])\n    return common_elements"}
{"task_id": "Mbpp/755", "solution": "def second_smallest(lst):\n    if len(lst) < 2:\n        return None  # Not enough elements to find a second smallest\n    smallest = float('inf')\n    second_smallest = float('inf')\n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    return second_smallest if second_smallest != float('inf') else None"}
{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(string_list):\n    \"\"\"\n    Count the pairs of reverse strings in the given string list.\n\n    Args:\n        string_list (list): A list of strings.\n\n    Returns:\n        int: The count of pairs of reverse strings.\n    \"\"\"\n    reverse_pairs = 0\n    for i in range(len(string_list)):\n        for j in range(i + 1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                reverse_pairs += 1\n    return reverse_pairs"}
{"task_id": "Mbpp/758", "solution": "def unique_sublists(lst):\n    \"\"\"\n    Write a function to count lists within a list. The function should return a dictionary where every list is converted to a tuple and the value of such tuple is the number of its occurencies in the original list.\n    assert unique_sublists([[1, 3], [5, 7], [1, 3], [13, 15, 17], [5, 7], [9, 11]] )=={(1, 3): 2, (5, 7): 2, (13, 15, 17): 1, (9, 11): 1}\n    \"\"\"\n    # Convert each sublist to a tuple\n    tuples = [tuple(sublist) for sublist in lst]\n    \n    # Count the occurrences of each tuple\n    counts = {}\n    for t in tuples:\n        if t in counts:\n            counts[t] += 1\n        else:\n            counts[t] = 1\n    \n    return counts"}
{"task_id": "Mbpp/759", "solution": "def is_decimal(s):\n    try:\n        float(s)\n        return True\n    except ValueError:\n        return False"}
{"task_id": "Mbpp/760", "solution": "def unique_Element(lst):\n    return len(set(lst)) == 1"}
{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month):\n    \"\"\"\n    Check whether the given month number contains 30 days or not.\n    Months are given as number from 1 to 12.\n    \"\"\"\n    thirty_day_months = [4, 6, 9, 11]\n    return month in thirty_day_months"}
{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr, n):\n    arr.sort()\n    min_diff = float('inf')\n    for i in range(n-1):\n        min_diff = min(min_diff, arr[i+1] - arr[i])\n    return min_diff"}
{"task_id": "Mbpp/764", "solution": "def number_ctr(s):\n    return sum(c.isdigit() for c in s)"}
{"task_id": "Mbpp/765", "solution": "def is_polite(n):\n    \"\"\"\n    Check if a number is polite.\n    A polite number is a positive integer that can be written as the sum of two or more consecutive positive integers.\n    \"\"\"\n    for i in range(1, n):\n        if n % i == 0:\n            return True\n    return False"}
{"task_id": "Mbpp/766", "solution": "def pair_wise(lst):\n    return [(lst[i], lst[i+1]) for i in range(len(lst)-1)]"}
{"task_id": "Mbpp/767", "solution": "def get_pairs_count(arr, sum):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] + arr[j] == sum:\n                count += 1\n    return count"}
{"task_id": "Mbpp/769", "solution": "def Diff(list1, list2):\n    return [item for item in list1 if item not in list2]"}
{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    \"\"\"\n    Calculate the sum of the fourth power of the first n odd natural numbers.\n\n    Args:\n        n (int): The number of odd natural numbers to consider.\n\n    Returns:\n        int: The sum of the fourth power of the first n odd natural numbers.\n    \"\"\"\n    return sum((2 * i + 1) ** 4 for i in range(n))"}
{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    stack = []\n    opening_brackets = \"({[\"\n    closing_brackets = \")}]\"\n    bracket_pairs = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in expression:\n        if char in opening_brackets:\n            stack.append(char)\n        elif char in closing_brackets:\n            if not stack or stack[-1] != bracket_pairs[char]:\n                return False\n            stack.pop()\n\n    return len(stack) == 0"}
{"task_id": "Mbpp/772", "solution": "def remove_length(s, k):\n    words = s.split()\n    filtered_words = [word for word in words if len(word) != k]\n    return ' '.join(filtered_words)"}
{"task_id": "Mbpp/773", "solution": "def occurance_substring(string, substring):\n    \"\"\"\n    Find the occurrence and position of the substring within the string.\n    Return None if there is no match.\n    \"\"\"\n    index = string.find(substring)\n    if index == -1:\n        return None\n    else:\n        return (substring, index, index + len(substring))"}
{"task_id": "Mbpp/775", "solution": "def odd_position(lst):\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            return False\n    return True"}
{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    \"\"\"\n    Write a python function to find the sum of non-repeated elements in a given list.\n    assert find_sum([1,2,3,1,1,4,5,6]) == 21\n    \"\"\"\n    # Create a dictionary to store the frequency of each element\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n\n    # Calculate the sum of non-repeated elements\n    non_repeated_sum = sum(num for num, count in freq.items() if count == 1)\n\n    return non_repeated_sum"}
{"task_id": "Mbpp/778", "solution": "def pack_consecutive_duplicates(lst):\n    result = []\n    current_sublist = [lst[0]]\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i-1]:\n            current_sublist.append(lst[i])\n        else:\n            result.append(current_sublist)\n            current_sublist = [lst[i]]\n    result.append(current_sublist)\n    return result"}
{"task_id": "Mbpp/780", "solution": "def find_combinations(tuples):\n    result = []\n    for i in range(len(tuples)):\n        for j in range(i+1, len(tuples)):\n            result.append((tuples[i][0] + tuples[j][0], tuples[i][1] + tuples[j][1]))\n    return result"}
{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count"}
{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    \"\"\"\n    Write a python function to find the sum of all odd length subarrays. \n    assert odd_length_sum([1,2,4]) == 14\n    \"\"\"\n    total_sum = 0\n    n = len(arr)\n    for i in range(n):\n        for j in range(i, n, 2):\n            total_sum += sum(arr[i:j+1])\n    return total_sum"}
{"task_id": "Mbpp/784", "solution": "def mul_even_odd(lst):\n    even = None\n    odd = None\n    for num in lst:\n        if num % 2 == 0:\n            if even is None:\n                even = num\n            else:\n                return even * num\n        else:\n            if odd is None:\n                odd = num\n            else:\n                return odd * num\n    return None"}
{"task_id": "Mbpp/785", "solution": "def tuple_str_int(s):\n    return tuple(map(int, s.strip('()').split(',')))"}
{"task_id": "Mbpp/786", "solution": "def right_insertion(arr, val):\n    left, right = 0, len(arr)\n    while left < right:\n        mid = (left + right) // 2\n        if arr[mid] <= val:\n            left = mid + 1\n        else:\n            right = mid\n    return left"}
{"task_id": "Mbpp/787", "solution": "import re\ndef text_match_three(text):\n    pattern = 'ab{3}'\n    return bool(re.match(pattern, text))"}
{"task_id": "Mbpp/788", "solution": "def new_tuple(lst, string):\n    return tuple(lst) + (string,)"}
{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            return False\n    return True"}
{"task_id": "Mbpp/791", "solution": "def remove_nested(tup):\n    return tuple(x for x in tup if not isinstance(x, tuple))"}
{"task_id": "Mbpp/792", "solution": "def count_list(nested_lists):\n    \"\"\"\n    Count the number of lists in a given number of lists.\n\n    Args:\n        nested_lists (list): A list containing nested lists.\n\n    Returns:\n        int: The count of lists in the given nested lists.\n    \"\"\"\n    count = 0\n    for item in nested_lists:\n        if isinstance(item, list):\n            count += 1\n    return count"}
{"task_id": "Mbpp/793", "solution": "def last(arr, target):\n    left, right = 0, len(arr) - 1\n    result = -1\n\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n\n    return result"}
{"task_id": "Mbpp/794", "solution": "import re\ndef text_starta_endb(text):\n    pattern = r'^a.*b$'\n    return bool(re.match(pattern, text))"}
{"task_id": "Mbpp/796", "solution": "def return_sum(dictionary):\n    return sum(dictionary.values())"}
{"task_id": "Mbpp/797", "solution": "def sum_in_range(l, r):\n    \"\"\"\n    Write a python function to find the sum of all odd natural numbers within the range l and r.\n    assert sum_in_range(2,5) == 8\n    \"\"\"\n    return sum(num for num in range(l, r+1) if num % 2 != 0)"}
{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    return sum(arr)"}
{"task_id": "Mbpp/799", "solution": "def left_rotate(num, d):\n    return (num << d) | (num >> (32 - d))"}
{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(input_string):\n    return input_string.replace(\" \", \"\")"}
{"task_id": "Mbpp/801", "solution": "def count_equal_numbers(a, b, c):\n    \"\"\"\n    Count the number of equal numbers from three given integers.\n\n    Args:\n        a (int): The first integer.\n        b (int): The second integer.\n        c (int): The third integer.\n\n    Returns:\n        int: The count of equal numbers.\n\n    Examples:\n        >>> count_equal_numbers(1, 1, 1)\n        3\n        >>> count_equal_numbers(1, 2, 3)\n        0\n        >>> count_equal_numbers(1, 1, 2)\n        2\n    \"\"\"\n    count = 0\n    if a == b:\n        count += 1\n    if a == c:\n        count += 1\n    if b == c:\n        count += 1\n    return count\n\n# Test cases\nassert count_equal_numbers(1, 1, 1) == 3\nassert count_equal_numbers(1, 2, 3) == 0\nassert count_equal_numbers(1, 1, 2) == 2"}
{"task_id": "Mbpp/803", "solution": "import math\ndef is_perfect_square(n):\n    \"\"\"\n    Check whether the given number is a perfect square or not.\n    \n    Args:\n        n (int): The number to be checked.\n    \n    Returns:\n        bool: True if the number is a perfect square, False otherwise.\n    \"\"\"\n    if n < 0:\n        return False\n    root = math.isqrt(n)\n    return root * root == n"}
{"task_id": "Mbpp/804", "solution": "def is_product_even(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product % 2 == 0"}
{"task_id": "Mbpp/805", "solution": "def max_sum_list(list_of_lists):\n    \"\"\"\n    Returns the list in a list of lists whose sum of elements is the highest.\n    \"\"\"\n    max_sum = float('-inf')\n    max_list = None\n    for lst in list_of_lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n            max_list = lst\n    return max_list"}
{"task_id": "Mbpp/806", "solution": "def max_run_uppercase(s):\n    max_run = 0\n    current_run = 0\n    for char in s:\n        if char.isupper():\n            current_run += 1\n            max_run = max(max_run, current_run)\n        else:\n            current_run = 0\n    return max_run"}
{"task_id": "Mbpp/807", "solution": "def first_odd(numbers):\n    for num in numbers:\n        if num % 2 != 0:\n            return num\n    return None"}
{"task_id": "Mbpp/808", "solution": "def check_K(tup, k):\n    return k in tup"}
{"task_id": "Mbpp/809", "solution": "def check_smaller(tup1, tup2):\n    return all(x < y for x, y in zip(tup1, tup2))"}
