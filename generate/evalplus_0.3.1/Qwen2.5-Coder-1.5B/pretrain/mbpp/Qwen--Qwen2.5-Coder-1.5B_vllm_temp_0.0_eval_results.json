{"date": "2024-11-02 07:33", "hash": "ee43ecabebf20deef4bb776a405ac5b1", "eval": {"Mbpp/2": [{"task_id": "Mbpp/2", "solution": "from typing import List, Set, Tuple\ndef similar_elements(list1: List[int], list2: List[int]) -> Set[int]:\n    return set(list1) & set(list2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/6": [{"task_id": "Mbpp/6", "solution": "def differ_At_One_Bit_Pos(a,b):\n    if bin(a^b).count('1') == 1:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10, 10]]}], "Mbpp/11": [{"task_id": "Mbpp/11", "solution": "def remove_Occ(str1, char):\n    str1 = str1.replace(char, \"\", 1)\n    str1 = str1.replace(char, \"\", 1)\n    return str1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["waaaorlda", "a"]]}], "Mbpp/7": [{"task_id": "Mbpp/7", "solution": "import re\ndef find_char_long(string):\n    return re.findall(r'\\b\\w{4,}\\b', string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/9": [{"task_id": "Mbpp/9", "solution": "def find_Rotations(string):\n    if string == string[::-1]:\n        return 0\n    for i in range(len(string)):\n        if string[i:] + string[:i] == string:\n            return i\n    return 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["aaaa"]], "plus_fail_tests": [["aaaaaaaaaaaaaaaab"]]}], "Mbpp/4": [{"task_id": "Mbpp/4", "solution": "import heapq\ndef heap_queue_largest(nums, n):\n    return heapq.nlargest(n, nums)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/8": [{"task_id": "Mbpp/8", "solution": "def square_nums(nums):\n    return [num**2 for num in nums]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/3": [{"task_id": "Mbpp/3", "solution": "def is_not_prime(num):\n    if num < 2:\n        return True\n    for i in range(2, num):\n        if num % i == 0:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/17": [{"task_id": "Mbpp/17", "solution": "def square_perimeter(side_length):\n    return 4*side_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/14": [{"task_id": "Mbpp/14", "solution": "def find_Volume(a,b,c):\n    return a*b*c", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10, 8, 6]], "plus_fail_tests": [[100, 50, 10]]}], "Mbpp/12": [{"task_id": "Mbpp/12", "solution": "def sort_matrix(matrix):\n    return sorted(matrix, key=sum)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/20": [{"task_id": "Mbpp/20", "solution": "def is_woodall(n):\n    if n == 1:\n        return True\n    if n < 1:\n        return False\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    if n % 5 == 0:\n        return False\n    if n % 7 == 0:\n        return False\n    if n % 11 == 0:\n        return False\n    if n % 13 == 0:\n        return False\n    if n % 17 == 0:\n        return False\n    if n % 19 == 0:\n        return False\n    if n % 23 == 0:\n        return False\n    if n % 29 == 0:\n        return False\n    if n % 31 == 0:\n        return False\n    if n % 37 == 0:\n        return False\n    if n % 41 == 0:\n        return False\n    if n % 43 == 0:\n        return False\n    if n % 47 == 0:\n        return False\n    if n % 53 == 0:\n        return False\n    if n % 59 == 0:\n        return False\n    if n % 61 == 0:\n        return False\n    if n % 67 == 0:\n        return False\n    if n % 71 == 0:\n        return False\n    if n % 73 == 0:\n        return False\n    if n % 79 == 0:\n        return False\n    if n % 83 == 0:\n        return False\n    if n % 89 == 0:\n        return False\n    if n % 97 == 0:\n        return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[123456791]]}], "Mbpp/18": [{"task_id": "Mbpp/18", "solution": "import unittest\ndef remove_dirty_chars(s1, s2):\n    return ''.join([c for c in s1 if c not in s2])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/19": [{"task_id": "Mbpp/19", "solution": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/56": [{"task_id": "Mbpp/56", "solution": "def check(n):\n    rev = 0\n    temp = n\n    while temp > 0:\n        rev = rev * 10 + temp % 10\n        temp = temp // 10\n    return n == 2 * rev - 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/16": [{"task_id": "Mbpp/16", "solution": "def text_lowercase_underscore(text):\n    return text.islower() and '_' in text", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["_abc"]]}], "Mbpp/58": [{"task_id": "Mbpp/58", "solution": "def opposite_Signs(a,b):\n    if a*b<0:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/59": [{"task_id": "Mbpp/59", "solution": "def is_octagonal(n):\n    return (1 + (1 + 4 * n) ** 0.5) % 2 == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[100]]}], "Mbpp/57": [{"task_id": "Mbpp/57", "solution": "def find_Max_Num(digits):\n    digits.sort(reverse=True)\n    return int(\"\".join(map(str, digits)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/62": [{"task_id": "Mbpp/62", "solution": "def smallest_num(l):\n    return min(l)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/63": [{"task_id": "Mbpp/63", "solution": "from typing import List, Tuple\ndef max_difference(tuples: List[Tuple[int, int]]) -> int:\n    max_diff = 0\n    for i in range(len(tuples)):\n        for j in range(i + 1, len(tuples)):\n            diff = abs(tuples[i][0] - tuples[j][0])\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 5], [1, 7], [10, 3], [1, 2]]]], "plus_fail_tests": [[[[1000000, 999999], [10000000, 9999999], [100000000, 99999999], [1000000000, 999999999]]]]}], "Mbpp/65": [{"task_id": "Mbpp/65", "solution": "def recursive_list_sum(lst):\n    sum = 0\n    for i in lst:\n        if type(i) == list:\n            sum += recursive_list_sum(i)\n        else:\n            sum += i\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/64": [{"task_id": "Mbpp/64", "solution": "def subject_marks(lst):\n    return sorted(lst, key=lambda x: x[1])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/61": [{"task_id": "Mbpp/61", "solution": "def count_Substrings(string):\n    count = 0\n    for i in range(len(string)):\n        sum = 0\n        for j in range(i, len(string)):\n            sum += int(string[j])\n            if sum == j - i + 1:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/68": [{"task_id": "Mbpp/68", "solution": "def is_Monotonic(arr):\n    return (all(arr[i] <= arr[i + 1] for i in range(len(arr) - 1)) or\n            all(arr[i] >= arr[i + 1] for i in range(len(arr) - 1)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/66": [{"task_id": "Mbpp/66", "solution": "def pos_count(lst):\n    count = 0\n    for i in lst:\n        if i > 0:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/69": [{"task_id": "Mbpp/69", "solution": "def is_sublist(list1, list2):\n    if list1 in list2:\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[2, 4, 3, 5, 7], [4, 3]]], "plus_fail_tests": [[[], []]]}], "Mbpp/70": [{"task_id": "Mbpp/70", "solution": "from typing import List, Tuple\ndef get_equal(tuples: List[Tuple]) -> bool:\n    return all(len(t) == len(tuples[0]) for t in tuples)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/67": [{"task_id": "Mbpp/67", "solution": "def bell_number(n):\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/74": [{"task_id": "Mbpp/74", "solution": "def is_samepatterns(arr1, arr2):\n    if len(arr1) != len(arr2):\n        return False\n    for i in range(len(arr1)):\n        if arr1[i] != arr2[i]:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["red", "green", "green"], ["a", "b", "b"]]], "plus_fail_tests": [[["red", "green", "blue"], ["a", "b", "c"]]]}], "Mbpp/72": [{"task_id": "Mbpp/72", "solution": "def dif_Square(n):\n    for i in range(1,n):\n        if i**2 + (n-i)**2 == n:\n            return True\n    return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5]], "plus_fail_tests": [[991]]}], "Mbpp/71": [{"task_id": "Mbpp/71", "solution": "import random\nimport timeit\nfrom typing import List\ndef comb_sort(arr: List[int]) -> List[int]:\n    \"\"\"\n    Sorts a list of elements using the comb sort algorithm.\n\n    Args:\n        arr (List[int]): The list of elements to be sorted.\n\n    Returns:\n        List[int]: The sorted list of elements.\n    \"\"\"\n    gap = len(arr)\n    shrink_factor = 1.3\n    swapped = True\n\n    while gap > 1 or swapped:\n        gap = int(gap / shrink_factor)\n        if gap < 1:\n            gap = 1\n\n        swapped = False\n\n        for i in range(len(arr) - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/77": [{"task_id": "Mbpp/77", "solution": "def is_Diff(n):\n    if n%11==0:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/75": [{"task_id": "Mbpp/75", "solution": "from typing import List, Tuple\ndef find_tuples(tuples: List[Tuple[int, ...]], k: int) -> List[Tuple[int, ...]]:\n    return [t for t in tuples if all(x % k == 0 for x in t)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/79": [{"task_id": "Mbpp/79", "solution": "def word_len(word):\n    if len(word)%2==0:\n        return False\n    else:\n        return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/80": [{"task_id": "Mbpp/80", "solution": "import math\ndef tetrahedral_number(n):\n    return int((n * (n + 1) * (n + 2)) / 6)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/85": [{"task_id": "Mbpp/85", "solution": "import math\ndef surfacearea_sphere(radius):\n    return 4 * math.pi * radius ** 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/82": [{"task_id": "Mbpp/82", "solution": "import math\ndef volume_sphere(radius):\n    return 4 / 3 * math.pi * radius ** 3", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/86": [{"task_id": "Mbpp/86", "solution": "import math\ndef centered_hexagonal_number(n):\n    return 3 * n * n - 3 * n + 1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/84": [{"task_id": "Mbpp/84", "solution": "import pytest", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/88": [{"task_id": "Mbpp/88", "solution": "def freq_count(list1):\n    dict1 = {}\n    for i in list1:\n        if i in dict1:\n            dict1[i] += 1\n        else:\n            dict1[i] = 1\n    return dict1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/87": [{"task_id": "Mbpp/87", "solution": "def merge_dictionaries_three(dict1, dict2, dict3):\n    return {**dict1, **dict2, **dict3}", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/89": [{"task_id": "Mbpp/89", "solution": "import math\ndef closest_num(n):\n    return math.floor(n / 2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[11]], "plus_fail_tests": [[-5]]}], "Mbpp/93": [{"task_id": "Mbpp/93", "solution": "def power(a, b):\n    return a**b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/90": [{"task_id": "Mbpp/90", "solution": "def len_log(list1):\n    max = 0\n    for i in list1:\n        if len(i) > max:\n            max = len(i)\n    return max", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/91": [{"task_id": "Mbpp/91", "solution": "def find_substring(list1, str1):\n    for i in list1:\n        if i.find(str1) != -1:\n            return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/92": [{"task_id": "Mbpp/92", "solution": "def is_undulating(n):\n    if len(str(n)) < 3:\n        return False\n    if str(n)[0] == str(n)[1]:\n        return False\n    for i in range(1, len(str(n)) - 1):\n        if str(n)[i] == str(n)[i + 1]:\n            return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[2121212121212123]]}], "Mbpp/94": [{"task_id": "Mbpp/94", "solution": "def index_minimum(tuples):\n    min_value = min(tuples, key=lambda x: x[1])\n    return min_value[0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/95": [{"task_id": "Mbpp/95", "solution": "\"\"\"\nWrite a python function to find the length of the smallest list in a list of lists.\nassert Find_Min_Length([[1],[1,2]]) == 1\n\"\"\"\ndef find_min_length(list_of_lists):\n    min_length = float('inf')\n    for sublist in list_of_lists:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    return min_length", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/99": [{"task_id": "Mbpp/99", "solution": "def decimal_to_binary(n):\n    return bin(n).replace(\"0b\", \"\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/98": [{"task_id": "Mbpp/98", "solution": "from typing import List\nfrom math import isclose\ndef multiply_num(nums: List[int]) -> float:\n    \"\"\"Multiply all the numbers in a list and divide with the length of the list.\"\"\"\n    return sum(nums) / len(nums)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[8, 2, 3, -1, 7]]], "plus_fail_tests": [[[100000, 2, 3]]]}], "Mbpp/97": [{"task_id": "Mbpp/97", "solution": "from collections import Counter\nfrom itertools import chain\nfrom typing import List, Dict\ndef frequency_lists(lists: List[List[int]]) -> Dict[int, int]:\n    return Counter(chain.from_iterable(lists))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/101": [{"task_id": "Mbpp/101", "solution": "def kth_element(arr, k):\n    return arr[k-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/100": [{"task_id": "Mbpp/100", "solution": "def next_smallest_palindrome(num):\n    # Convert the number to a string\n    num_str = str(num)\n    \n    # Find the next palindrome by incrementing the last digit\n    for i in range(len(num_str) - 1, -1, -1):\n        if num_str[i] != '9':\n            num_str = num_str[:i] + str(int(num_str[i]) + 1) + num_str[i+1:]\n            break\n    else:\n        # If all digits are 9, append a 1 to the end\n        num_str = num_str + '1'\n    \n    # Convert the string back to an integer\n    next_palindrome = int(num_str)\n    \n    return next_palindrome", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[99]], "plus_fail_tests": [[45678]]}], "Mbpp/96": [{"task_id": "Mbpp/96", "solution": "def divisor(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/102": [{"task_id": "Mbpp/102", "solution": "def snake_to_camel(s):\n    s = s.split('_')\n    s = [i.capitalize() for i in s]\n    s = ''.join(s)\n    return s", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["___python_program"]]}], "Mbpp/104": [{"task_id": "Mbpp/104", "solution": "from typing import List, Any\ndef sort_sublists(list_of_lists: List[List[Any]]) -> List[List[Any]]:\n    return [sorted(sublist) for sublist in list_of_lists]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/103": [{"task_id": "Mbpp/103", "solution": "import pytest\nfrom eulerian_num import eulerian_num", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/108": [{"task_id": "Mbpp/108", "solution": "def merge_sorted_list(list1, list2, list3):\n    list1.extend(list2)\n    list1.extend(list3)\n    list1.sort()\n    return list1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/106": [{"task_id": "Mbpp/106", "solution": "from typing import List, Tuple\ndef add_lists(list_: List[int], tuple_: Tuple[int]) -> Tuple[int, ...]:\n    return tuple_ + tuple(list_)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/105": [{"task_id": "Mbpp/105", "solution": "def count(lst):\n    count = 0\n    for i in lst:\n        if i == True:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/109": [{"task_id": "Mbpp/109", "solution": "def odd_Equivalent(binary_string,rotations):\n    count = 0\n    for i in range(rotations):\n        binary_string = binary_string[1:] + binary_string[0]\n        if int(binary_string,2) % 2 == 1:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/111": [{"task_id": "Mbpp/111", "solution": "from typing import List, Set, Tuple, Dict, Any, Optional\nfrom collections import Counter\nfrom itertools import chain\nfrom functools import reduce\nfrom operator import add\nfrom collections import defaultdict\nfrom collections import Counter\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict\nfrom collections import OrderedDict\nfrom collections import namedtuple\nfrom collections import deque\nfrom collections import defaultdict", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/113": [{"task_id": "Mbpp/113", "solution": "def check_integer(string):\n    try:\n        int(string)\n        return True\n    except ValueError:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/118": [{"task_id": "Mbpp/118", "solution": "def string_to_list(string):\n    return string.split(\" \")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/116": [{"task_id": "Mbpp/116", "solution": "def tuple_to_int(tup):\n    return int(''.join(map(str, tup)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/119": [{"task_id": "Mbpp/119", "solution": "def search(arr):\n    if len(arr) == 1:\n        return arr[0]\n    if arr[0] != arr[1]:\n        return arr[0]\n    if arr[-1] != arr[-2]:\n        return arr[-1]\n    for i in range(1, len(arr)-1):\n        if arr[i] != arr[i-1] and arr[i] != arr[i+1]:\n            return arr[i]\n    return -1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[]]]}], "Mbpp/120": [{"task_id": "Mbpp/120", "solution": "from itertools import combinations\nfrom functools import reduce\nfrom operator import mul\ndef max_product_tuple(tuples):\n    return max(reduce(mul, pair) for pair in combinations(tuples, 2))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[2, 7], [2, 6], [1, 8], [4, 9]]]], "plus_fail_tests": [[[[-10, 20], [15, -2], [-5, 10]]]]}], "Mbpp/124": [{"task_id": "Mbpp/124", "solution": "import math\ndef angle_complex(x, y):\n    return math.atan2(y, x)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["0.0", "1j"]], "plus_fail_tests": [["0.0", "0j"]]}], "Mbpp/125": [{"task_id": "Mbpp/125", "solution": "def find_length(s):\n    # Write your code here\n    max_length = 0\n    count_0 = 0\n    count_1 = 0\n    for i in range(len(s)):\n        if s[i] == '0':\n            count_0 += 1\n        else:\n            count_1 += 1\n        if count_0 == count_1:\n            max_length = max(max_length, count_0 + count_1)\n    return max_length", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["11000010001"]], "plus_fail_tests": [["0000000011111111"]]}], "Mbpp/128": [{"task_id": "Mbpp/128", "solution": "def long_words(n, str):\n    word_len = []\n    txt = str.split(\" \")\n    for x in txt:\n        if len(x) > n:\n            word_len.append(x)\n    return word_len", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/127": [{"task_id": "Mbpp/127", "solution": "def multiply_int(a,b):\n    return a*b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/129": [{"task_id": "Mbpp/129", "solution": "def magic_square_test(matrix):\n    if len(matrix) != len(matrix[0]):\n        return False\n    n = len(matrix)\n    sum1 = sum2 = 0\n    for i in range(n):\n        sum1 += matrix[i][i]\n        sum2 += matrix[i][n - 1 - i]\n    if sum1 != sum2:\n        return False\n    for i in range(n):\n        sum1 = 0\n        sum2 = 0\n        for j in range(n):\n            sum1 += matrix[i][j]\n            sum2 += matrix[j][i]\n        if sum1 != sum2:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/131": [{"task_id": "Mbpp/131", "solution": "def reverse_vowels(str1):\n    str2 = \"\"\n    for i in str1:\n        if i in \"aeiouAEIOU\":\n            str2 += i\n    str2 = str2[::-1]\n    str3 = \"\"\n    j = 0\n    for i in str1:\n        if i in \"aeiouAEIOU\":\n            str3 += str2[j]\n            j += 1\n        else:\n            str3 += i\n    return str3", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/130": [{"task_id": "Mbpp/130", "solution": "from collections import Counter\ndef max_occurrences(lst):\n    return Counter(lst).most_common(1)[0][0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/132": [{"task_id": "Mbpp/132", "solution": "def tup_string(tup):\n    return ''.join(tup)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/133": [{"task_id": "Mbpp/133", "solution": "def sum_negativenum(lst):\n    sum = 0\n    for i in lst:\n        if i < 0:\n            sum += i\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/135": [{"task_id": "Mbpp/135", "solution": "import math\ndef hexagonal_num(n):\n    return n * (2 * n - 1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/140": [{"task_id": "Mbpp/140", "solution": "from typing import List, Set, Tuple\ndef extract_singly(list_of_lists: List[Tuple[int, ...]]) -> Set[int]:\n    return set([item for sublist in list_of_lists for item in sublist])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/137": [{"task_id": "Mbpp/137", "solution": "import math\ndef zero_count(arr):\n    zero_count = 0\n    for i in arr:\n        if i == 0:\n            zero_count += 1\n    return zero_count / len(arr)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]]], "plus_fail_tests": [[[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]]}], "Mbpp/139": [{"task_id": "Mbpp/139", "solution": "import math\ndef circle_circumference(radius):\n    return 2 * math.pi * radius", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/138": [{"task_id": "Mbpp/138", "solution": "def is_Sum_Of_Powers_Of_Two(n):\n    if n == 0:\n        return False\n    while n > 0:\n        if n & 1 == 0:\n            n = n >> 1\n        else:\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[-14]]}], "Mbpp/142": [{"task_id": "Mbpp/142", "solution": "def count_samepair(list1,list2,list3):\n    count=0\n    for i in range(len(list1)):\n        if list1[i]==list2[i]==list3[i]:\n            count+=1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 6, 7, 8]]]}], "Mbpp/141": [{"task_id": "Mbpp/141", "solution": "from typing import List\ndef pancake_sort(arr: List[int]) -> List[int]:\n    for i in range(len(arr) - 1, 0, -1):\n        max_index = arr.index(max(arr[:i + 1]))\n        arr[:max_index + 1] = arr[:max_index + 1][::-1]\n        arr[:i + 1] = arr[:i + 1][::-1]\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/162": [{"task_id": "Mbpp/162", "solution": "def sum_series(n):\n    if n <= 0:\n        return 0\n    else:\n        return n + sum_series(n-2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1000000]]}], "Mbpp/161": [{"task_id": "Mbpp/161", "solution": "from typing import List\ndef remove_elements(list1: List[int], list2: List[int]) -> List[int]:\n    return [x for x in list1 if x not in list2]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/160": [{"task_id": "Mbpp/160", "solution": "import math\ndef find_solution(a, b, n):\n    if a == 0 and b == 0:\n        return None\n    if a == 0:\n        return (0, n // b)\n    if b == 0:\n        return (n // a, 0)\n    if a == b:\n        if n % a == 0:\n            return (n // a, n // a)\n        else:\n            return None\n    if a > b:\n        if n % b == 0:\n            return (n // b, 0)\n        else:\n            return None\n    if b > a:\n        if n % a == 0:\n            return (0, n // a)\n        else:\n            return None\n    if a < b:\n        if n % a == 0:\n            return (n // a, 0)\n        else:\n            return None\n    if b < a:\n        if n % b == 0:\n            return (0, n // b)\n        else:\n            return None\n    if a == 1:\n        return (n, 0)\n    if b == 1:\n        return (0, n)\n    if a == 2:\n        if n % 2 == 0:\n            return (n // 2, 0)\n        else:\n            return None\n    if b == 2:\n        if n % 2 == 0:\n            return (0, n // 2)\n        else:\n            return None\n    if a == 3:\n        if n % 3 == 0:\n            return (n // 3, 0)\n        else:\n            return None\n    if b == 3:\n        if n % 3 == 0:\n            return (0, n // 3)\n        else:\n            return None\n    if a == 4:\n        if n % 4 == 0:\n            return (n // 4, 0)\n        else:\n            return None\n    if b == 4:\n        if n % 4 == 0:\n            return (0, n // 4)\n        else:\n            return None\n    if a == 5:\n        if n % 5 == 0:\n            return (n // 5, 0)\n        else:\n            return None\n    if b == 5:\n        if n % 5 == 0:\n            return (0, n // 5)\n        else:\n            return None\n    if a == 6:\n        if n % 6 == 0:\n            return (n // 6, 0)\n        else:\n            return None\n    if b == 6:\n        if n % 6 == 0:\n            return (0, n // 6)\n        else:\n            return None\n    if a == 7:\n        if n % 7 == 0:\n            return (n // 7, 0)\n        else:\n            return None\n    if b == 7:\n        if n % 7 == 0:\n            return (0, n // 7)\n        else:\n            return None\n    if a == 8:\n        if n % 8 == 0:\n            return (n // 8, 0)\n        else:\n            return None\n    if b == 8:\n        if n % 8 == 0:\n            return (0, n // 8)\n        else:\n            return None\n    if a == 9:\n        if n % 9 == 0:\n            return (n // 9, 0)\n        else:\n            return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2, 3, 7]], "plus_fail_tests": [[100, 50, 4000]]}], "Mbpp/145": [{"task_id": "Mbpp/145", "solution": "def max_Abs_Diff(arr):\n    max_diff = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if abs(arr[i] - arr[j]) > max_diff:\n                max_diff = abs(arr[i] - arr[j])\n    return max_diff", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/165": [{"task_id": "Mbpp/165", "solution": "def count_char_position(s):\n    count = 0\n    for i in range(len(s)):\n        if s[i].lower() == chr(ord('a') + i):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/166": [{"task_id": "Mbpp/166", "solution": "def find_even_pair(list):\n    count = 0\n    for i in range(len(list)):\n        for j in range(i+1, len(list)):\n            if (list[i] ^ list[j]) % 2 == 0:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/170": [{"task_id": "Mbpp/170", "solution": "def sum_range_list(list, start, end):\n    sum = 0\n    for i in range(start, end+1):\n        sum += list[i]\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/167": [{"task_id": "Mbpp/167", "solution": "def next_power_of_2(n):\n    \"\"\"\n    Find the smallest power of 2 greater than or equal to n.\n\n    Args:\n    n (int): The number to find the next power of 2 for.\n\n    Returns:\n    int: The smallest power of 2 greater than or equal to n.\n    \"\"\"\n    if n <= 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/168": [{"task_id": "Mbpp/168", "solution": "from typing import List\ndef frequency(lst: List[int], num: int) -> int:\n    return lst.count(num)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/171": [{"task_id": "Mbpp/171", "solution": "import math\ndef perimeter_pentagon(side_length):\n    return 5 * side_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/172": [{"task_id": "Mbpp/172", "solution": "def count_occurance(string):\n    count = 0\n    for i in range(len(string)):\n        if string[i:i+3] == \"std\":\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/223": [{"task_id": "Mbpp/223", "solution": "def is_majority(arr, n, element):\n    count = 0\n    for i in range(n):\n        if arr[i] == element:\n            count += 1\n    if count > n/2:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 1, 0]]}], "Mbpp/222": [{"task_id": "Mbpp/222", "solution": "def check_type(tup):\n    return all(isinstance(i, type(tup[0])) for i in tup)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/226": [{"task_id": "Mbpp/226", "solution": "def odd_values_string(str1):\n    str2 = \"\"\n    for i in range(len(str1)):\n        if i % 2 == 0:\n            str2 = str2 + str1[i]\n    return str2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/224": [{"task_id": "Mbpp/224", "solution": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/227": [{"task_id": "Mbpp/227", "solution": "def min_of_three(a,b,c):\n    if a<b and a<c:\n        return a\n    elif b<a and b<c:\n        return b\n    else:\n        return c", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1.5, 1.5, 1.7539550971097109]]}], "Mbpp/126": [{"task_id": "Mbpp/126", "solution": "def sum(a,b):\n    sum=0\n    for i in range(1,min(a,b)+1):\n        if a%i==0 and b%i==0:\n            sum+=i\n    return sum", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321, 123456789]]}], "Mbpp/232": [{"task_id": "Mbpp/232", "solution": "def larg_nnum(l,n):\n    l.sort()\n    return l[-n:]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[5, 95, 81, -20, 8, 72, 0], 0]]}], "Mbpp/234": [{"task_id": "Mbpp/234", "solution": "def volume_cube(side_length):\n    return side_length**3", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/230": [{"task_id": "Mbpp/230", "solution": "def replace_blank(string,character):\n    return string.replace(\" \",character)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/233": [{"task_id": "Mbpp/233", "solution": "import math", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/237": [{"task_id": "Mbpp/237", "solution": "def check_occurences(tuples):\n    # Write your code here\n    dict = {}\n    for i in tuples:\n        if i in dict:\n            dict[i] += 1\n        else:\n            dict[i] = 1\n    return dict", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 1], [1, 3], [2, 5], [5, 2], [6, 3]]]], "plus_fail_tests": [[[[2, 2], [1, 3], [2, 2], [3, 1], [1, 3]]]]}], "Mbpp/235": [{"task_id": "Mbpp/235", "solution": "def even_bit_set_number(n):\n    return n | (n >> 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[999999999]]}], "Mbpp/238": [{"task_id": "Mbpp/238", "solution": "def number_of_substrings(str1):\n    count = 0\n    for i in range(len(str1)):\n        for j in range(i+1,len(str1)+1):\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/239": [{"task_id": "Mbpp/239", "solution": "def get_total_number_of_sequences(m, n):\n    if n == 1:\n        return 1\n    if m == 1:\n        return 0\n    if m == 2:\n        return 1\n    if n == 2:\n        return m - 1\n    return get_total_number_of_sequences(m, n - 1) + get_total_number_of_sequences(m // 2, n - 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10, 4]], "plus_fail_tests": [[100, 10]]}], "Mbpp/245": [{"task_id": "Mbpp/245", "solution": "def max_sum(arr):\n    n = len(arr)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = arr[i]\n    for i in range(n-1):\n        if arr[i] < arr[i+1]:\n            dp[i][i+1] = arr[i] + arr[i+1]\n    for i in range(n-2):\n        for j in range(i+2, n):\n            if arr[i] < arr[j]:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j] + arr[i])\n    return max([max(row) for row in dp])", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 15, 51, 45, 33, 100, 12, 18, 9]]], "plus_fail_tests": [[[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]]]}], "Mbpp/242": [{"task_id": "Mbpp/242", "solution": "def count_charac(string):\n    return len(string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/240": [{"task_id": "Mbpp/240", "solution": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/244": [{"task_id": "Mbpp/244", "solution": "def next_Perfect_Square(n):\n    return (n+1)**2\nn=int(input())", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/247": [{"task_id": "Mbpp/247", "solution": "def lps(s):\n    n = len(s)\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    for i in range(n):\n        dp[i][i] = 1\n    for i in range(n-1, -1, -1):\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i+1][j], dp[i][j-1])\n    return dp[0][n-1]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/253": [{"task_id": "Mbpp/253", "solution": "def count_integer(lst):\n    count = 0\n    for i in lst:\n        if type(i) == int:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/252": [{"task_id": "Mbpp/252", "solution": "import cmath\ndef convert(complex_number):\n    return cmath.polar(complex_number)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/250": [{"task_id": "Mbpp/250", "solution": "def count_X(tup,element):\n    count = 0\n    for i in tup:\n        if i == element:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/251": [{"task_id": "Mbpp/251", "solution": "def insert_element(list, element):\n    for i in range(len(list)):\n        list.insert(i, element)\n    return list", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Red", "Green", "Black"], "c"]], "plus_fail_tests": [[[-94.19039842971628, -3.4031380684866406, -22.045351968568852, -94.19039842971628], "a"]]}], "Mbpp/123": [{"task_id": "Mbpp/123", "solution": "def amicable_numbers_sum(n):\n    def sum_of_divisors(num):\n        return sum([i for i in range(1, num) if num % i == 0])\n    amicable_numbers = []\n    for i in range(1, n + 1):\n        if sum_of_divisors(i) != i and sum_of_divisors(sum_of_divisors(i)) == i:\n            amicable_numbers.append(i)\n    return sum(amicable_numbers)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9999]], "plus_fail_tests": [[10000]]}], "Mbpp/262": [{"task_id": "Mbpp/262", "solution": "def split_two_parts(lst, L):\n    return lst[:L], lst[L:]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/257": [{"task_id": "Mbpp/257", "solution": "def swap_numbers(a,b):\n    return b,a", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/259": [{"task_id": "Mbpp/259", "solution": "from typing import List, Tuple\ndef maximize_elements(tuples1: List[Tuple[int, int]], tuples2: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    return sorted(tuples1 + tuples2, key=lambda x: x[0] + x[1], reverse=True)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 3], [4, 5], [2, 9], [1, 10]], [[6, 7], [3, 9], [1, 1], [7, 3]]]], "plus_fail_tests": [[[[1, 2], [3, 4], [5, 6], [7, 8]], [[8, 7], [6, 5], [4, 3], [2, 1]]]]}], "Mbpp/261": [{"task_id": "Mbpp/261", "solution": "def division_elements(tuple1, tuple2):\n    # Check if the tuples have the same length\n    if len(tuple1) != len(tuple2):\n        raise ValueError(\"Tuples must have the same length\")\n\n    # Perform element-wise division\n    result = tuple(a / b for a, b in zip(tuple1, tuple2))\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/264": [{"task_id": "Mbpp/264", "solution": "def dog_age(age):\n    if age <= 2:\n        return age * 10.5\n    else:\n        return 21 + (age - 2) * 4", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/256": [{"task_id": "Mbpp/256", "solution": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/265": [{"task_id": "Mbpp/265", "solution": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/266": [{"task_id": "Mbpp/266", "solution": "def lateralsurface_cube(side_length):\n    return 4 * side_length ** 2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/268": [{"task_id": "Mbpp/268", "solution": "import math\ndef find_star_num(n):\n    return (n**2)*(4*n-2)+1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/269": [{"task_id": "Mbpp/269", "solution": "def ascii_value(char):\n    return ord(char)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/267": [{"task_id": "Mbpp/267", "solution": "def square_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**2\n    return sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[1000000.0]]}], "Mbpp/270": [{"task_id": "Mbpp/270", "solution": "def sum_even_and_even_index(list1):\n    sum = 0\n    for i in range(0, len(list1), 2):\n        if list1[i] % 2 == 0:\n            sum += list1[i]\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/273": [{"task_id": "Mbpp/273", "solution": "def substract_elements(tuple1, tuple2):\n    return tuple(a - b for a, b in zip(tuple1, tuple2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/274": [{"task_id": "Mbpp/274", "solution": "import math\ndef even_binomial_Coeff_Sum(n):\n    sum = 0\n    for i in range(0, n+1, 2):\n        sum += math.comb(n, i)\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/272": [{"task_id": "Mbpp/272", "solution": "def rear_extract(tuples):\n    return [t[2] for t in tuples]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[1, ["Rash", 21]], [2, ["Varsha", 20]], [3, ["Kil", 19]]]]]}], "Mbpp/276": [{"task_id": "Mbpp/276", "solution": "import math\ndef volume_cylinder(radius, height):\n    return math.pi * radius**2 * height", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/277": [{"task_id": "Mbpp/277", "solution": "def dict_filter(dict, n):\n    return {k: v for k, v in dict.items() if v >= n}", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/279": [{"task_id": "Mbpp/279", "solution": "import math\ndef is_num_decagonal(n):\n    if n < 0:\n        return False\n    else:\n        return math.sqrt(21 * n + 1) % 1 == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/281": [{"task_id": "Mbpp/281", "solution": "def all_unique(l):\n    return len(l) == len(set(l))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/278": [{"task_id": "Mbpp/278", "solution": "from typing import Tuple\ndef count_first_elements(t: Tuple) -> int:\n    \"\"\"\n    Count the number of elements that occurs before the tuple element in the given tuple.\n    :param t: tuple\n    :return: int\n    \"\"\"\n    count = 0\n    for i in t:\n        if isinstance(i, tuple):\n            break\n        count += 1\n    return count", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6]]]}], "Mbpp/280": [{"task_id": "Mbpp/280", "solution": "def sequential_search(array, element):\n    for i in range(len(array)):\n        if array[i] == element:\n            return (True, i)\n    return (False, -1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/282": [{"task_id": "Mbpp/282", "solution": "def sub_list(list1, list2):\n    return [x - y for x, y in zip(list1, list2)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/286": [{"task_id": "Mbpp/286", "solution": "from typing import List\ndef max_sub_array_sum_repeated(arr: List[int], k: int, n: int) -> int:\n    max_sum = float(\"-inf\")\n    for i in range(n):\n        curr_sum = 0\n        for j in range(k):\n            curr_sum += arr[i]\n            max_sum = max(max_sum, curr_sum)\n    return max_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[10, 20, -30, -1], 4, 3]], "plus_fail_tests": [[[5, -2, 10, 4, -7, 3], 6, 5]]}], "Mbpp/283": [{"task_id": "Mbpp/283", "solution": "def validate(n):\n    n = str(n)\n    for i in n:\n        if int(i) > len(n) - n.count(i):\n            return False\n    return True", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1234]], "plus_fail_tests": [[9]]}], "Mbpp/285": [{"task_id": "Mbpp/285", "solution": "def text_match_two_three(text):\n    return \"ab\" in text or \"abbb\" in text", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/284": [{"task_id": "Mbpp/284", "solution": "def check_element(list,element):\n    for i in list:\n        if i != element:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/287": [{"task_id": "Mbpp/287", "solution": "def square_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**2\n    return sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[100]]}], "Mbpp/292": [{"task_id": "Mbpp/292", "solution": "def find(a,b):\n    return int(a/b)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-1, 2]]}], "Mbpp/290": [{"task_id": "Mbpp/290", "solution": "def max_length(lists):\n    max_len = 0\n    max_list = []\n    for i in lists:\n        if len(i) > max_len:\n            max_len = len(i)\n            max_list = i\n    return max_len, max_list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/294": [{"task_id": "Mbpp/294", "solution": "def max_val(l):\n    max = l[0]\n    for i in l:\n        if type(i) == int:\n            if i > max:\n                max = i\n        elif type(i) == str:\n            if i > max:\n                max = i\n    return max", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python", 3, 2, 4, 5, "version"]]], "plus_fail_tests": [[[1, "2", true, 3.14, ["a", "b"], [5, 6, 7], {"8": "eight", "9": "nine"}, "Python", 10, 11, 12]]]}], "Mbpp/293": [{"task_id": "Mbpp/293", "solution": "import math\ndef otherside_rightangle(a,b):\n    return math.sqrt(a**2+b**2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/296": [{"task_id": "Mbpp/296", "solution": "def get_Inv_Count(arr):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] > arr[j]:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/297": [{"task_id": "Mbpp/297", "solution": "def flatten_list(nested_list):\n    result = []\n    for item in nested_list:\n        if isinstance(item, list):\n            result.extend(flatten_list(item))\n        else:\n            result.append(item)\n    return result\nnested_list = [0, 10, [20, 30], 40, 50, [60, 70, 80], [90, 100, 110, 120]]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/299": [{"task_id": "Mbpp/299", "solution": "def max_aggregate(tuples):\n    max_aggregate = 0\n    max_name = \"\"\n    for name, score in tuples:\n        if score > max_aggregate:\n            max_aggregate = score\n            max_name = name\n    return max_name, max_aggregate", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[["Juan Whelan", 90], ["Sabah Colley", 88], ["Peter Nichols", 7], ["Juan Whelan", 122], ["Sabah Colley", 84]]]], "plus_fail_tests": [[[["Alice", 80], ["Bob", 90], ["Charlie", 70], ["Alice", 60], ["Bob", 50], ["Charlie", 40]]]]}], "Mbpp/300": [{"task_id": "Mbpp/300", "solution": "import math\ndef count_binary_seq(n):\n    \"\"\"\n    :param n: length of binary sequence\n    :return: count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits\n    \"\"\"\n    return math.comb(2 * n, n) / 2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[1]], "plus_fail_tests": [[4]]}], "Mbpp/305": [{"task_id": "Mbpp/305", "solution": "def start_withp(words):\n    for word in words:\n        if word[0] == 'P' or word[0] == 'p':\n            return word\n    return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python PHP", "Java JavaScript", "c c++"]]], "plus_fail_tests": [[["Python Programming", "Java Programming", "Perl Programming", "Ruby Programming", "PHP Programming", "C Programming"]]]}], "Mbpp/301": [{"task_id": "Mbpp/301", "solution": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + max(dict_depth(v) for v in d.values()) if d else 0\n    else:\n        return 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"a": 1, "b": {"c": {"d": {}}}}]], "plus_fail_tests": [[{}]]}], "Mbpp/306": [{"task_id": "Mbpp/306", "solution": "def max_sum_increasing_subseq(arr, n, k, i):\n    if i == n:\n        return 0\n    if k > i:\n        return max_sum_increasing_subseq(arr, n, k, i+1)\n    return max(arr[i] + max_sum_increasing_subseq(arr, n, k, i+1), max_sum_increasing_subseq(arr, n, k, i+1))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 101, 2, 3, 100, 4, 5], 7, 4, 6]], "plus_fail_tests": [[[5, 2, 4, 1, 3, 6], 6, 1, 3]]}], "Mbpp/308": [{"task_id": "Mbpp/308", "solution": "from itertools import combinations\nfrom functools import reduce\nfrom operator import mul\ndef large_product(list1, list2, n):\n    return sorted([reduce(mul, i) for i in combinations(list1, 1) for j in combinations(list2, 1) if i[0] * j[0] > 0], reverse=True)[:n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5, 6], [3, 6, 8, 9, 10, 6], 3]], "plus_fail_tests": [[[61.017129591114184, 19.303378474526568, 49.402419273875154, 49.402419273875154, -6.658136072450631, 55.36349167122134, 6.408487552626596, -22.555835342170255, -61.03464372753109, 76.32506038662768, 61.017129591114184], [61.017129591114184, 19.303378474526568, 49.402419273875154, 49.402419273875154, -6.658136072450631, 55.36349167122134, 6.408487552626596, -22.555835342170255, -61.03464372753109, 76.32506038662768, 61.017129591114184], true]]}], "Mbpp/309": [{"task_id": "Mbpp/309", "solution": "def maximum(a,b):\n    if a>b:\n        return a\n    else:\n        return b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/310": [{"task_id": "Mbpp/310", "solution": "def string_to_tuple(str):\n    return tuple(str)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python 3.0"]], "plus_fail_tests": [["hello   world"]]}], "Mbpp/311": [{"task_id": "Mbpp/311", "solution": "def set_left_most_unset_bit(n):\n    return n | (n+1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[255]]}], "Mbpp/312": [{"task_id": "Mbpp/312", "solution": "import math\ndef volume_cone(radius, height):\n    return (1/3) * math.pi * radius**2 * height", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/388": [{"task_id": "Mbpp/388", "solution": "def highest_Power_of_2(n):\n    \"\"\"\n    Find the highest power of 2 that is less than or equal to n.\n\n    Args:\n        n (int): The input number.\n\n    Returns:\n        int: The highest power of 2 that is less than or equal to n.\n    \"\"\"\n    power = 0\n    while (1 << power) <= n:\n        power += 1\n    return (1 << (power - 1))\nn = 10", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/390": [{"task_id": "Mbpp/390", "solution": "def add_string(list,format):\n    return [format.format(i) for i in list]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/391": [{"task_id": "Mbpp/391", "solution": "def convert_list_dictionary(list1, list2, list3):\n    dict1 = {}\n    for i in range(len(list1)):\n        dict1[list1[i]] = {list2[i]: list3[i]}\n    return [dict1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["S001", "S002", "S003", "S004"], ["Adina Park", "Leyton Marsh", "Duncan Boyle", "Saim Richards"], [85, 98, 89, 92]]], "plus_fail_tests": [[["abc", "def", "ghi", "jkl"], ["python", "program", "language", "programs"], [{"1": "a", "2": "b"}, {"3": "c"}, 4, ["x", "y", "z"]]]]}], "Mbpp/392": [{"task_id": "Mbpp/392", "solution": "import math\ndef get_max_sum(n):\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    if n == 4:\n        return 4\n    if n == 5:\n        return 5\n    if n == 6:\n        return 6\n    if n == 7:\n        return 7\n    if n == 8:\n        return 8\n    if n == 9:\n        return 9\n    if n == 10:\n        return 10\n    if n == 11:\n        return 11\n    if n == 12:\n        return 12\n    if n == 13:\n        return 13\n    if n == 14:\n        return 14\n    if n == 15:\n        return 15\n    if n == 16:\n        return 16\n    if n == 17:\n        return 17\n    if n == 18:\n        return 18\n    if n == 19:\n        return 19\n    if n == 20:\n        return 20\n    if n == 21:\n        return 21\n    if n == 22:\n        return 22\n    if n == 23:\n        return 23\n    if n == 24:\n        return 24\n    if n == 25:\n        return 25\n    if n == 26:\n        return 26\n    if n == 27:\n        return 27\n    if n == 28:\n        return 28\n    if n == 29:\n        return 29\n    if n == 30:\n        return 30\n    if n == 31:\n        return 31\n    if n == 32:\n        return 32\n    if n == 33:\n        return 33\n    if n == 34:\n        return 34\n    if n == 35:\n        return 35\n    if n == 36:\n        return 36\n    if n == 37:\n        return 37\n    if n == 38:\n        return 38\n    if n == 39:\n        return 39\n    if n == 40:\n        return 40\n    if n == 41:\n        return 41\n    if n == 42:\n        return 42\n    if n == 43:\n        return 43\n    if n == 44:\n        return 44\n    if n == 45:\n        return 45\n    if n == 46:\n        return 46\n    if n == 47:\n        return 47\n    if n == 48:\n        return 48\n    if n == 49:\n        return 49\n    if n == 50:\n        return 50\n    if n == 51:\n        return 51\n    if n == 52:\n        return 52\n    if n == 53:\n        return 53\n    if n == 54:\n        return 54\n    if n == 55:\n        return 55", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[60]], "plus_fail_tests": [[100]]}], "Mbpp/394": [{"task_id": "Mbpp/394", "solution": "from typing import Tuple\ndef check_distinct(t: Tuple) -> bool:\n    return len(set(t)) == len(t)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/395": [{"task_id": "Mbpp/395", "solution": "def first_non_repeating_character(str1):\n    char_order = []\n    count = {}\n    for char in str1:\n        if char in count:\n            count[char] += 1\n        else:\n            count[char] = 1\n            char_order.append(char)\n    for char in char_order:\n        if count[char] == 1:\n            return char\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/397": [{"task_id": "Mbpp/397", "solution": "def median_numbers(a,b,c):\n    if a>b:\n        if a<c:\n            return a\n        elif b<c:\n            return c\n        else:\n            return b\n    elif b>a:\n        if b<c:\n            return b\n        elif a<c:\n            return c\n        else:\n            return a\n    else:\n        return b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/398": [{"task_id": "Mbpp/398", "solution": "def sum_of_digits(list1):\n    sum=0\n    for i in list1:\n        sum+=i\n    return sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[10, 2, 56]]], "plus_fail_tests": [[[-10, 15, 0, -5, 2]]]}], "Mbpp/404": [{"task_id": "Mbpp/404", "solution": "def minimum(a,b):\n    if a<b:\n        return a\n    else:\n        return b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/405": [{"task_id": "Mbpp/405", "solution": "def check_tuplex(tuplex, element):\n    if element in tuplex:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/409": [{"task_id": "Mbpp/409", "solution": "def min_product_tuple(tuples):\n    min_product = float('inf')\n    for pair in tuples:\n        product = pair[0] * pair[1]\n        if product < min_product:\n            min_product = product\n    return min_product\ntuples = [(2, 7), (2, 6), (1, 8), (4, 9)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/410": [{"task_id": "Mbpp/410", "solution": "def min_val(l):\n    min = l[0]\n    for i in l:\n        if type(i) == int:\n            if i < min:\n                min = i\n        elif type(i) == str:\n            if i < min:\n                min = i\n    return min", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python", 3, 2, 4, 5, "version"]]], "plus_fail_tests": [[["Python", 10, 5, 2.5, 2.5, "version"]]]}], "Mbpp/255": [{"task_id": "Mbpp/255", "solution": "def combinations_colors(colors, n):\n    if n == 0:\n        return [()]\n    else:\n        return [ (color,) + combo for color in colors for combo in combinations_colors(colors, n-1)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Red", "Green", "Blue"], 2]], "plus_fail_tests": [[["A", "B", "C", "D"], 4]]}], "Mbpp/412": [{"task_id": "Mbpp/412", "solution": "def remove_odd(l):\n    return [i for i in l if i%2==0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/260": [{"task_id": "Mbpp/260", "solution": "import math\ndef newman_prime(n):\n    \"\"\"\n    :param n: nth newman\u2013shanks\u2013williams prime number\n    :return: nth newman\u2013shanks\u2013williams prime number\n    \"\"\"\n    if n == 1:\n        return 2\n    else:\n        i = 1\n        while True:\n            i += 1\n            if is_prime(i):\n                if is_prime(newman(i)):\n                    n -= 1\n                    if n == 0:\n                        return i\ndef is_prime(n):\n    \"\"\"\n    :param n: number to check if it is prime\n    :return: True if n is prime, False otherwise\n    \"\"\"\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef newman(n):\n    \"\"\"\n    :param n: number to calculate newman\u2013shanks\u2013williams prime\n    :return: newman\u2013shanks\u2013williams prime\n    \"\"\"\n    return 2 * n**2 - n + 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[100]]}], "Mbpp/413": [{"task_id": "Mbpp/413", "solution": "def extract_nth_element(tuples_list, n):\n    return [tup[n] for tup in tuples_list]\ntuples_list = [('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)]\nn = 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/415": [{"task_id": "Mbpp/415", "solution": "def max_Product(arr):\n    max1 = max(arr)\n    arr.remove(max1)\n    max2 = max(arr)\n    return (max1,max2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 7, 0, 8, 4]]], "plus_fail_tests": [[[-2, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]}], "Mbpp/414": [{"task_id": "Mbpp/414", "solution": "def overlapping(seq1,seq2):\n    for i in seq1:\n        for j in seq2:\n            if i==j:\n                return True\n    return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/418": [{"task_id": "Mbpp/418", "solution": "def Find_Max(list):\n    max = 0\n    for i in list:\n        if len(i) > max:\n            max = len(i)\n    return max", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[["A"], ["A", "B"], ["A", "B", "C"]]]], "plus_fail_tests": [[[[], [], []]]]}], "Mbpp/419": [{"task_id": "Mbpp/419", "solution": "def round_and_sum(numbers):\n    return sum([round(num) for num in numbers]) * len(numbers)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/422": [{"task_id": "Mbpp/422", "solution": "def find_Average_Of_Cube(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**3\n    return sum/n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/421": [{"task_id": "Mbpp/421", "solution": "def concatenate_tuple(tup, delimiter):\n    return delimiter.join(str(i) for i in tup)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["ID", "is", 4, "UTS"]]], "plus_fail_tests": [[["The", "quick", "brown", "fox"]]]}], "Mbpp/420": [{"task_id": "Mbpp/420", "solution": "\"\"\"\nWrite a python function to find the cube sum of first n even natural numbers.\nassert cube_Sum(2) == 72\n\"\"\"\n#PF-Assgn-23\ndef cube_sum(n):\n    sum=0\n    for i in range(1,n+1):\n        sum=sum+(2*i)**3\n    return sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/271": [{"task_id": "Mbpp/271", "solution": "def even_Power_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2*i)**5\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/424": [{"task_id": "Mbpp/424", "solution": "def extract_rear(tup):\n    return [i[-1] for i in tup]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/389": [{"task_id": "Mbpp/389", "solution": "import unittest\ndef find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return find_lucas(n - 1) + find_lucas(n - 2)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/425": [{"task_id": "Mbpp/425", "solution": "def count_element_in_list(list1,element):\n    count=0\n    for i in list1:\n        if element in i:\n            count+=1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/427": [{"task_id": "Mbpp/427", "solution": "import re\ndef change_date_format(date: str) -> str:\n    \"\"\"\n    Function to convert a date of yyyy-mm-dd format to dd-mm-yyyy format.\n    :param date: date in yyyy-mm-dd format\n    :return: date in dd-mm-yyyy format\n    \"\"\"\n    if not re.match(r\"^\\d{4}-\\d{2}-\\d{2}$\", date):\n        raise ValueError(\"Invalid date format. Expected yyyy-mm-dd\")\n    return date.replace(\"-\", \"/\")[8:] + \"-\" + date.replace(\"-\", \"/\")[5:7] + \"-\" + date.replace(\"-\", \"/\")[0:4]", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["2021-1-026"]]}], "Mbpp/426": [{"task_id": "Mbpp/426", "solution": "def filter_oddnumbers(list):\n    return [i for i in list if i%2!=0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/428": [{"task_id": "Mbpp/428", "solution": "from typing import List\ndef shell_sort(arr: List[int]) -> List[int]:\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/429": [{"task_id": "Mbpp/429", "solution": "from typing import Tuple", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/430": [{"task_id": "Mbpp/430", "solution": "import math\ndef parabola_directrix(a,b,c):\n    return -b/(2*a) - math.sqrt((b**2 - 4*a*c)/4*a**2)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 3, 2]], "plus_fail_tests": [[0, 0, 0]]}], "Mbpp/432": [{"task_id": "Mbpp/432", "solution": "def median_trapezium(a,b,c):\n    return (a+b+c)/2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[15, 25, 35]], "plus_fail_tests": [[2.3, 4.7, 3.9]]}], "Mbpp/433": [{"task_id": "Mbpp/433", "solution": "from typing import List\ndef check_greater(arr: List[int], num: int) -> bool:\n    return num > max(arr)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[], 10]]}], "Mbpp/435": [{"task_id": "Mbpp/435", "solution": "def last_Digit(n):\n    return n%10\nn=int(input())", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/439": [{"task_id": "Mbpp/439", "solution": "def multiple_to_single(list):\n    return int(''.join(map(str, list)))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/436": [{"task_id": "Mbpp/436", "solution": "def neg_nos(lst):\n    return [i for i in lst if i<0]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/440": [{"task_id": "Mbpp/440", "solution": "import re\ndef find_adverb_position(sentence):\n    pattern = r\"\\b\\w+ly\\b\"\n    matches = re.finditer(pattern, sentence)\n    adverbs = [(match.start(), match.end(), match.group()) for match in matches]\n    return adverbs", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["clearly!! we can see the sky"]], "plus_fail_tests": [["heavily and quickly we ran down the steep hill"]]}], "Mbpp/406": [{"task_id": "Mbpp/406", "solution": "def find_Parity(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count % 2 == 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10]]}], "Mbpp/437": [{"task_id": "Mbpp/437", "solution": "def remove_odd(string):\n    return string[1::2]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/441": [{"task_id": "Mbpp/441", "solution": "def surfacearea_cube(n):\n    return 6*n*n", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/446": [{"task_id": "Mbpp/446", "solution": "def count_Occurrence(tup, lst):\n    count = 0\n    for i in lst:\n        for j in tup:\n            if i == j:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/447": [{"task_id": "Mbpp/447", "solution": "def cube_nums(nums):\n    return [num**3 for num in nums]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/448": [{"task_id": "Mbpp/448", "solution": "import pytest\nfrom src.perrin_numbers import cal_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/445": [{"task_id": "Mbpp/445", "solution": "from typing import Tuple\ndef index_multiplication(tup1: Tuple[Tuple[int, ...]], tup2: Tuple[Tuple[int, ...]]) -> Tuple[Tuple[int, ...]]:\n    return tuple(tuple(a * b for a, b in zip(t1, t2)) for t1, t2 in zip(tup1, tup2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/450": [{"task_id": "Mbpp/450", "solution": "def extract_string(str_list, size):\n    return [s for s in str_list if len(s) >= size]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["Python", "list", "exercises", "practice", "solution"], 8]], "plus_fail_tests": [[["abcdef", "xyz", "pqr", "lmnop", "abcde"], 5]]}], "Mbpp/451": [{"task_id": "Mbpp/451", "solution": "import re\ndef remove_whitespaces(string):\n    return re.sub(r'\\s+', '', string)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["\n\t"]]}], "Mbpp/454": [{"task_id": "Mbpp/454", "solution": "import re\ndef text_match_wordz(text):\n    regex = re.compile(r'\\w*z\\w*')\n    if regex.search(text):\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/455": [{"task_id": "Mbpp/455", "solution": "def check_monthnumb_number(month):\n    if month in [1,3,5,7,8,10,12]:\n        return True\n    elif month in [4,6,9,11]:\n        return False\n    else:\n        return \"Invalid month number\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[2]]}], "Mbpp/456": [{"task_id": "Mbpp/456", "solution": "def reverse_string_list(list1):\n    list2 = []\n    for i in list1:\n        list2.append(i[::-1])\n    return list2", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/457": [{"task_id": "Mbpp/457", "solution": "def Find_Min(lst):\n    min = len(lst[0])\n    for i in lst:\n        if len(i) < min:\n            min = len(i)\n    return min", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1], [1, 2], [1, 2, 3]]]], "plus_fail_tests": [[[[], [], []]]]}], "Mbpp/458": [{"task_id": "Mbpp/458", "solution": "def rectangle_area(a,b):\n    return a*b", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/459": [{"task_id": "Mbpp/459", "solution": "import re\ndef remove_uppercase(string: str) -> str:\n    return re.sub(r'[A-Z]', '', string)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["ThiS%^%!s&a(mY)TesTStR%i*ng"]]}], "Mbpp/460": [{"task_id": "Mbpp/460", "solution": "def Extract(lst):\n    return [sub[0] for sub in lst]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/463": [{"task_id": "Mbpp/463", "solution": "from typing import List\ndef max_subarray_product(nums: List[int]) -> int:\n    if not nums:\n        return 0\n\n    max_product = min_product = result = nums[0]\n\n    for num in nums[1:]:\n        if num < 0:\n            max_product, min_product = min_product, max_product\n\n        max_product = max(num, max_product * num)\n        min_product = min(num, min_product * num)\n\n        result = max(result, max_product)\n\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/462": [{"task_id": "Mbpp/462", "solution": "from itertools import combinations\ndef combinations_list(lst):\n    result = []\n    for i in range(len(lst)+1):\n        for j in combinations(lst, i):\n            result.append(list(j))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["orange", "red", "green", "blue"]]], "plus_fail_tests": [[["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"]]]}], "Mbpp/465": [{"task_id": "Mbpp/465", "solution": "import pytest\nfrom collections import defaultdict\nfrom typing import Dict, Any\ndef drop_empty(data: Dict[str, Any]) -> Dict[str, Any]:\n    return {k: v for k, v in data.items() if v is not None}", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/468": [{"task_id": "Mbpp/468", "solution": "from typing import List\ndef max_product(nums: List[int]) -> int:\n    if not nums:\n        return 0\n    max_product = nums[0]\n    for i in range(1, len(nums)):\n        for j in range(i):\n            if nums[i] > nums[j]:\n                max_product = max(max_product, nums[i] * nums[j])\n    return max_product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 100, 4, 5, 150, 6]]], "plus_fail_tests": [[[3, -5, 2, 6, -1, 4, -3]]]}], "Mbpp/470": [{"task_id": "Mbpp/470", "solution": "from typing import Tuple\ndef add_pairwise(tup: Tuple[int]) -> Tuple[int]:\n    \"\"\"\n    Add neighboring elements of the given tuple.\n    :param tup: tuple of integers\n    :return: tuple of integers\n    \"\"\"\n    return tuple(a + b for a, b in zip(tup, tup[1:]))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/471": [{"task_id": "Mbpp/471", "solution": "def find_remainder(arr,n):\n    product=1\n    for i in arr:\n        product=(product*i)%n\n    return product", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/472": [{"task_id": "Mbpp/472", "solution": "def check_Consecutive(list1):\n    list1.sort()\n    for i in range(len(list1)-1):\n        if list1[i]+1 != list1[i+1]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/475": [{"task_id": "Mbpp/475", "solution": "def sort_counter(d):\n    return sorted(d.items(), key=lambda x: x[1], reverse=True)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/473": [{"task_id": "Mbpp/473", "solution": "from typing import List, Tuple\ndef tuple_intersection(tup1: List[Tuple[int, int]], tup2: List[Tuple[int, int]]) -> set:\n    \"\"\"\n    Find the tuple intersection of elements in the given tuple list irrespective of their order.\n    :param tup1: List of tuples\n    :param tup2: List of tuples\n    :return: Set of tuples\n    \"\"\"\n    return set(tup1).intersection(set(tup2))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[3, 4], [5, 6], [9, 10], [4, 5]], [[5, 4], [3, 4], [6, 5], [9, 11]]]], "plus_fail_tests": [[[[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]], [[2, 3, 1], [6, 5, 4], [11, 12, 10]]]]}], "Mbpp/474": [{"task_id": "Mbpp/474", "solution": "def replace_char(string,old,new):\n    return string.replace(old,new)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/453": [{"task_id": "Mbpp/453", "solution": "def sumofFactors(num):\n    sum = 0\n    for i in range(1, num+1):\n        if num % i == 0 and i % 2 == 0:\n            sum += i\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/476": [{"task_id": "Mbpp/476", "solution": "def big_sum(arr):\n    return max(arr) + min(arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/477": [{"task_id": "Mbpp/477", "solution": "def is_lower(str1):\n    return str1.lower()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/478": [{"task_id": "Mbpp/478", "solution": "def remove_lowercase(s):\n    return ''.join([i for i in s if i.isupper()])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/479": [{"task_id": "Mbpp/479", "solution": "def first_Digit(n):\n    while n>=10:\n        n=n/10\n    return int(n)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/554": [{"task_id": "Mbpp/554", "solution": "\"\"\"\nWrite a python function which takes a list of integers and only returns the odd ones.\nassert Split([1,2,3,4,5,6]) == [1,3,5]\n\"\"\"\ndef split(list):\n    odd = []\n    for i in list:\n        if i % 2 != 0:\n            odd.append(i)\n    return odd", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/555": [{"task_id": "Mbpp/555", "solution": "def difference(n):\n    sum_of_cubes=0\n    sum_of_natural_numbers=0\n    for i in range(1,n+1):\n        sum_of_cubes=sum_of_cubes+(i**3)\n        sum_of_natural_numbers=sum_of_natural_numbers+i\n    difference=sum_of_cubes-sum_of_natural_numbers\n    return difference\nn=3", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/556": [{"task_id": "Mbpp/556", "solution": "def find_Odd_Pair(arr,n):\n    count=0\n    for i in range(n):\n        for j in range(i+1,n):\n            if (arr[i]^arr[j])%2!=0:\n                count+=1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/558": [{"task_id": "Mbpp/558", "solution": "def digit_distance_nums(num1,num2):\n    sum=0\n    while num1>0 and num2>0:\n        sum+=abs(num1%10-num2%10)\n        num1//=10\n        num2//=10\n    return sum", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[12345, 9]]}], "Mbpp/559": [{"task_id": "Mbpp/559", "solution": "from typing import List\ndef max_sub_array_sum(arr: List[int], k: int) -> int:\n    \"\"\"\n    Time Complexity: O(n)\n    Space Complexity: O(1)\n    \"\"\"\n    if k > len(arr):\n        return None\n    max_sum = 0\n    for i in range(k):\n        max_sum += arr[i]\n    current_sum = max_sum\n    for i in range(k, len(arr)):\n        current_sum += arr[i] - arr[i - k]\n        max_sum = max(max_sum, current_sum)\n    return max_sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[-2, -3, 4, -1, -2, 1, 5, -3], 8]], "plus_fail_tests": [[[-10, -5, -3, -2, -1], 5]]}], "Mbpp/560": [{"task_id": "Mbpp/560", "solution": "def union_elements(t1,t2):\n    t3=t1+t2\n    t3=list(set(t3))\n    t3.sort()\n    return tuple(t3)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/564": [{"task_id": "Mbpp/564", "solution": "def count_Pairs(lst,n):\n    count = 0\n    for i in range(n):\n        for j in range(i+1,n):\n            if lst[i] != lst[j]:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/562": [{"task_id": "Mbpp/562", "solution": "def Find_Max_Length(lst):\n    max_length = 0\n    for i in lst:\n        if len(i) > max_length:\n            max_length = len(i)\n    return max_length", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/557": [{"task_id": "Mbpp/557", "solution": "def toggle_string(string):\n    return string.swapcase()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/566": [{"task_id": "Mbpp/566", "solution": "def sum_digits(n):\n    if n == 0:\n        return 0\n    else:\n        return n % 10 + sum_digits(n // 10)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000]]}], "Mbpp/565": [{"task_id": "Mbpp/565", "solution": "def split(string):\n    return [char for char in string]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/563": [{"task_id": "Mbpp/563", "solution": "import re\ndef extract_values(string):\n    return re.findall(r'\"([^\"]*)\"', string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/567": [{"task_id": "Mbpp/567", "solution": "def issort_list(list1):\n    for i in range(len(list1)-1):\n        if list1[i] > list1[i+1]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/568": [{"task_id": "Mbpp/568", "solution": "def empty_list(n):\n    return [{} for i in range(n)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/569": [{"task_id": "Mbpp/569", "solution": "def sort_sublists(lists):\n    return [sorted(sublist) for sublist in lists]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/572": [{"task_id": "Mbpp/572", "solution": "def two_unique_nums(list1):\n    list2 = []\n    for i in list1:\n        if i not in list2:\n            list2.append(i)\n    return list2", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 2, 3, 4, 5]]], "plus_fail_tests": [[[1, 2, 3, 2, 4, 5, 3, 6, 4, 7, 8, 9, 5, 6]]]}], "Mbpp/578": [{"task_id": "Mbpp/578", "solution": "from typing import List\ndef interleave_lists(list1: List[int], list2: List[int], list3: List[int]) -> List[int]:\n    return [i for i in list1 for j in list2 for k in list3]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 4, 5, 6, 7], [10, 20, 30, 40, 50, 60, 70], [100, 200, 300, 400, 500, 600, 700]]], "plus_fail_tests": [[[1, 2, 3, 4, 5], [10, 20, 30, 40, 50], [100, 200, 300, 400, 500]]]}], "Mbpp/576": [{"task_id": "Mbpp/576", "solution": "def is_Sub_Array(list1,list2):\n    if list1 in list2:\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 1], [1, 2, 1]]], "plus_fail_tests": [[[], []]]}], "Mbpp/577": [{"task_id": "Mbpp/577", "solution": "def last_Digit_Factorial(n):\n    if n == 0 or n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 6\n    elif n == 4:\n        return 4\n    elif n == 5:\n        return 0\n    elif n == 6:\n        return 2\n    elif n == 7:\n        return 4\n    elif n == 8:\n        return 2\n    elif n == 9:\n        return 0\n    else:\n        return 0", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[1.5869584267664152]]}], "Mbpp/573": [{"task_id": "Mbpp/573", "solution": "def unique_product(list1):\n    product = 1\n    for i in list1:\n        if list1.count(i) == 1:\n            product = product * i\n    return product", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[10, 20, 30, 40, 20, 50, 60, 40]]], "plus_fail_tests": [[[1000000, 2000000, 3000000, 2000000, 4000000, 5000000]]]}], "Mbpp/579": [{"task_id": "Mbpp/579", "solution": "from typing import Tuple\ndef find_dissimilar(tup1: Tuple, tup2: Tuple) -> Tuple:\n    \"\"\"Find dissimilar elements in the given two tuples.\"\"\"\n    return tuple(set(tup1) ^ set(tup2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/581": [{"task_id": "Mbpp/581", "solution": "def surface_Area(base_edge, height):\n    return base_edge**2 + 2*base_edge*height", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/580": [{"task_id": "Mbpp/580", "solution": "from typing import Any, Tuple\ndef extract_even(mixed_tuple: Tuple[Any, ...]) -> Tuple[Any, ...]:\n    \"\"\"Remove uneven elements in the nested mixed tuple.\"\"\"\n    return tuple(\n        item\n        for item in mixed_tuple\n        if isinstance(item, tuple)\n        and all(isinstance(i, int) and i % 2 == 0 for i in item)\n        or isinstance(item, int) and item % 2 == 0\n    )", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[4, 5, [7, 6, [2, 4]], 6, 8]]], "plus_fail_tests": [[[1, 2, 3, [4, 5, [6, 7, [8, 9, [10, 11, [12, 13, [14, 15, [16, 17, [18, 19, [20]]]]]]]]]]]]}], "Mbpp/583": [{"task_id": "Mbpp/583", "solution": "def catalan_number(n):\n    if n==0 or n==1:\n        return 1\n    else:\n        return catalan_number(n-1)*(4*n-2)/(n+1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/586": [{"task_id": "Mbpp/586", "solution": "def split_Arr(arr,n):\n    return arr[n:] + arr[:n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/585": [{"task_id": "Mbpp/585", "solution": "import pytest\nfrom typing import List, Dict\ndef expensive_items(items: List[Dict[str, float]], n: int) -> List[Dict[str, float]]:\n    \"\"\"\n    Find the n most expensive items in a given dataset.\n\n    Args:\n        items (List[Dict[str, float]]): A list of dictionaries representing items with 'name' and 'price' keys.\n        n (int): The number of most expensive items to find.\n\n    Returns:\n        List[Dict[str, float]]: A list of dictionaries representing the n most expensive items.\n\n    Raises:\n        ValueError: If n is less than 1 or greater than the number of items in the dataset.\n\n    Examples:\n        >>> expensive_items([{'name': 'Item-1', 'price': 101.1}, {'name': 'Item-2', 'price': 555.22}], 1)\n        [{'name': 'Item-2', 'price': 555.22}]\n        >>> expensive_items([{'name': 'Item-1', 'price': 101.1}, {'name': 'Item-2', 'price': 555.22}], 2)\n        [{'name': 'Item-2', 'price': 555.22}, {'name': 'Item-1', 'price': 101.1}]\n    \"\"\"\n    if n < 1 or n > len(items):\n        raise ValueError(\"n must be between 1 and the number of items in the dataset\")\n\n    sorted_items = sorted(items, key=lambda x: x['price'], reverse=True)\n    return sorted_items[:n]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/587": [{"task_id": "Mbpp/587", "solution": "def list_tuple(list1):\n    return tuple(list1)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/589": [{"task_id": "Mbpp/589", "solution": "import math\ndef perfect_squares(a,b):\n    l=[]\n    for i in range(a,b+1):\n        if math.sqrt(i)==int(math.sqrt(i)):\n            l.append(i)\n    return l", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[-10, -1]]}], "Mbpp/588": [{"task_id": "Mbpp/588", "solution": "def big_diff(nums):\n    return max(nums) - min(nums)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/590": [{"task_id": "Mbpp/590", "solution": "import math\ndef polar_rect(r, theta):\n    x = r * math.cos(theta)\n    y = r * math.sin(theta)\n    return (x, y), (x + 1j * y)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3, 4]], "plus_fail_tests": [[0, 0]]}], "Mbpp/591": [{"task_id": "Mbpp/591", "solution": "def swap_List(list1):\n    temp = list1[0]\n    list1[0] = list1[-1]\n    list1[-1] = temp\n    return list1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/592": [{"task_id": "Mbpp/592", "solution": "import math\ndef sum_Of_product(n):\n    sum = 0\n    for i in range(0,n+1):\n        sum += math.factorial(n)/(math.factorial(i)*math.factorial(n-i))\n    return sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[10]]}], "Mbpp/593": [{"task_id": "Mbpp/593", "solution": "import re\ndef removezero_ip(ip):\n    return re.sub(r'\\b0+(?=\\d)', '', ip)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["0.0.0.0"]]}], "Mbpp/594": [{"task_id": "Mbpp/594", "solution": "def diff_even_odd(l):\n    even = 0\n    odd = 0\n    for i in l:\n        if i%2 == 0:\n            even = i\n            break\n    for i in l:\n        if i%2 != 0:\n            odd = i\n            break\n    return even - odd", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/596": [{"task_id": "Mbpp/596", "solution": "import sys\ndef tuple_size(tup):\n    return sys.getsizeof(tup)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/597": [{"task_id": "Mbpp/597", "solution": "from typing import List\ndef find_kth(arr1: List[int], arr2: List[int], k: int) -> int:\n    if not arr1:\n        return arr2[k - 1]\n    if not arr2:\n        return arr1[k - 1]\n    if k == 1:\n        return min(arr1[0], arr2[0])\n    if arr1[0] < arr2[0]:\n        return find_kth(arr1[1:], arr2, k - 1)\n    return find_kth(arr1, arr2[1:], k - 1)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[1, 2, 3], [true, true, false], 3]]}], "Mbpp/600": [{"task_id": "Mbpp/600", "solution": "def is_Even(n):\n    if n%2==0:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/598": [{"task_id": "Mbpp/598", "solution": "def armstrong_number(n):\n    sum=0\n    temp=n\n    while temp>0:\n        digit=temp%10\n        sum+=digit**3\n        temp//=10\n    if n==sum:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[3]]}], "Mbpp/602": [{"task_id": "Mbpp/602", "solution": "def first_repeated_char(str1):\n    for i in range(len(str1)):\n        if str1[i] in str1[:i]:\n            return str1[i]\n    return \"None\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["abc"]], "plus_fail_tests": [[""]]}], "Mbpp/603": [{"task_id": "Mbpp/603", "solution": "from math import sqrt\ndef is_prime(n):\n    if n == 1:\n        return False\n    for i in range(2, int(sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\ndef get_ludic(n):\n    ludic = []\n    for i in range(1, n + 1):\n        if is_prime(i):\n            ludic.append(i)\n    return ludic", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[100]]}], "Mbpp/604": [{"task_id": "Mbpp/604", "solution": "def reverse_words(string):\n    return \" \".join(string.split()[::-1])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/606": [{"task_id": "Mbpp/606", "solution": "import math\ndef radian_degree(degrees):\n    return math.radians(degrees)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/607": [{"task_id": "Mbpp/607", "solution": "import re\ndef find_literals(text, pattern):\n    match = re.search(pattern, text)\n    if match:\n        return match.group(), match.start(), match.end()\n    else:\n        return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/610": [{"task_id": "Mbpp/610", "solution": "def remove_kth_element(lst,k):\n    return lst[:k]+lst[k+1:]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 2, 3, 4, 4, 5, 1], 3]], "plus_fail_tests": [[[1, 2, 3, 4, 5], 1]]}], "Mbpp/611": [{"task_id": "Mbpp/611", "solution": "from typing import List\ndef max_of_nth(matrix: List[List[int]], n: int) -> int:\n    return max([row[n] for row in matrix])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/612": [{"task_id": "Mbpp/612", "solution": "def merge(list_of_lists):\n    return [list(x) for x in zip(*list_of_lists)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/614": [{"task_id": "Mbpp/614", "solution": "from typing import List, Tuple\ndef cummulative_sum(tup_list: List[Tuple[int]]) -> int:\n    \"\"\"\n    Function to find the cumulative sum of all the values that are present in the given tuple list.\n    :param tup_list: List of tuples\n    :return: int\n    \"\"\"\n    return sum(sum(tup) for tup in tup_list)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/608": [{"task_id": "Mbpp/608", "solution": "\"\"\"\nWrite a python function to find nth bell number.\nassert bell_Number(2) == 2\n\"\"\"\ndef bell_number(n):\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/615": [{"task_id": "Mbpp/615", "solution": "def average_tuple(tpl):\n    return [sum(i)/len(i) for i in zip(*tpl)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/616": [{"task_id": "Mbpp/616", "solution": "from typing import Tuple\ndef tuple_modulo(t1: Tuple[int], t2: Tuple[int]) -> Tuple[int]:\n    \"\"\"\n    Perform element wise modulo on two tuples\n    :param t1: first tuple\n    :param t2: second tuple\n    :return: tuple of modulo results\n    \"\"\"\n    return tuple(x % y for x, y in zip(t1, t2))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/619": [{"task_id": "Mbpp/619", "solution": "import re\ndef move_num(string):\n    return re.sub(r'\\d+', '', string) + re.findall(r'\\d+', string)[::-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["I1love143you55three3000thousand"]], "plus_fail_tests": [["Hello! My age is 28. I was born on the 1st of January, 1992."]]}], "Mbpp/618": [{"task_id": "Mbpp/618", "solution": "from typing import List\ndef div_list(list1: List[int], list2: List[int]) -> List[float]:\n    return [x / y for x, y in zip(list1, list2)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/620": [{"task_id": "Mbpp/620", "solution": "from typing import List\ndef largest_subset(nums: List[int]) -> int:\n    nums.sort()\n    n = len(nums)\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[9, 3, 12, 7, 16, 3, 11, 8, 4, 13, 13]]]}], "Mbpp/623": [{"task_id": "Mbpp/623", "solution": "def nth_nums(nums, n):\n    return [num**n for num in nums]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/622": [{"task_id": "Mbpp/622", "solution": "import math\ndef get_median(list1, list2, size):\n    \"\"\"\n    :param list1: list of numbers\n    :param list2: list of numbers\n    :param size: size of both lists\n    :return: median of two sorted lists\n    \"\"\"\n    if size % 2 == 0:\n        return (get_median_helper(list1, list2, size // 2) + get_median_helper(list1, list2, size // 2 + 1)) / 2\n    else:\n        return get_median_helper(list1, list2, size // 2 + 1)\ndef get_median_helper(list1, list2, index):\n    \"\"\"\n    :param list1: list of numbers\n    :param list2: list of numbers\n    :param index: index of median\n    :return: median of two sorted lists\n    \"\"\"\n    if len(list1) == 0:\n        return list2[index - 1]\n    if len(list2) == 0:\n        return list1[index - 1]\n    if index == 1:\n        return min(list1[0], list2[0])\n    if list1[0] < list2[0]:\n        return get_median_helper(list1[1:], list2, index - 1)\n    else:\n        return get_median_helper(list1, list2[1:], index - 1)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 12, 15, 26, 38], [2, 13, 17, 30, 45], 5]], "plus_fail_tests": [[[1, 4, 7, 10, 13, 16, 19, 22, 25, 28], [2, 5, 8, 11, 14, 17, 20, 23, 26, 29], 10]]}], "Mbpp/626": [{"task_id": "Mbpp/626", "solution": "import math\ndef triangle_area(radius):\n    if radius < 0:\n        return None\n    return (math.pi * radius * radius) / 4", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[0.5]]}], "Mbpp/629": [{"task_id": "Mbpp/629", "solution": "\"\"\"\nWrite a python function to find even numbers from a list of numbers.\nassert Split([1,2,3,4,5]) == [2,4]\n\"\"\"\ndef split_list(list1):\n    even_list = []\n    for i in list1:\n        if i % 2 == 0:\n            even_list.append(i)\n    return even_list", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/628": [{"task_id": "Mbpp/628", "solution": "import unittest\ndef replace_spaces(string):\n    return string.replace(\" \", \"%20\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/624": [{"task_id": "Mbpp/624", "solution": "def is_upper(str):\n    return str.upper()", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/632": [{"task_id": "Mbpp/632", "solution": "def move_zero(list):\n    for i in list:\n        if i == 0:\n            list.remove(i)\n            list.append(i)\n    return list", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/633": [{"task_id": "Mbpp/633", "solution": "def pair_xor_Sum(lst,n):\n    sum=0\n    for i in range(n):\n        for j in range(i+1,n):\n            sum+=lst[i]^lst[j]\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/637": [{"task_id": "Mbpp/637", "solution": "def noprofit_noloss(a,b):\n    if a==b:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/631": [{"task_id": "Mbpp/631", "solution": "import re\ndef replace_spaces(string):\n    return re.sub(r'\\s', '_', string)", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [["The_Avengers"]], "plus_fail_tests": []}], "Mbpp/635": [{"task_id": "Mbpp/635", "solution": "import heapq\ndef heap_sort(arr):\n    heapq.heapify(arr)\n    return [heapq.heappop(arr) for _ in range(len(arr))]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/638": [{"task_id": "Mbpp/638", "solution": "def wind_chill(velocity,temperature):\n    return round(13.12 + 0.6215 * temperature - 11.37 * velocity ** 0.16 + 0.3965 * temperature * velocity ** 0.16)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/641": [{"task_id": "Mbpp/641", "solution": "import math\ndef is_nonagonal(n):\n    \"\"\"\n    :param n: int\n    :return: bool\n    \"\"\"\n    return math.sqrt(1 + 21 * n) % 7 == 0", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[10]], "plus_fail_tests": [[1000000]]}], "Mbpp/639": [{"task_id": "Mbpp/639", "solution": "def sample_nam(names):\n    return sum(len(name) for name in names if name[0].isupper())", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[["AbCdE", "fGH", "IJKLMnOp", "qrs", "TUVW", "xyz"]]]}], "Mbpp/644": [{"task_id": "Mbpp/644", "solution": "\"\"\"\nWrite a python function to reverse an array upto a given position.\nassert reverse_Array_Upto_K([1, 2, 3, 4, 5, 6],4) == [4, 3, 2, 1, 5, 6]\n\"\"\"\ndef reverse_array_Upto_K(arr,k):\n    start = 0\n    end = len(arr)-1\n    while start < end:\n        arr[start],arr[end] = arr[end],arr[start]\n        start += 1\n        end -= 1\n    return arr[:k] + arr[k:][::-1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/605": [{"task_id": "Mbpp/605", "solution": "def prime_num(num):\n    if num > 1:\n        for i in range(2, num):\n            if (num % i) == 0:\n                return False\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[999999999989]]}], "Mbpp/643": [{"task_id": "Mbpp/643", "solution": "import re\ndef text_match_wordz_middle(text):\n    pattern = r'^[a-zA-Z]*z[a-zA-Z]*$'\n    if re.search(pattern, text):\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["pythonzabc."]], "plus_fail_tests": [["zzzxyabczzz xxzzxxyz zzzz abczyz baaz azzbzz"]]}], "Mbpp/720": [{"task_id": "Mbpp/720", "solution": "def add_dict_to_tuple(tup, dict):\n    return tup + (dict,)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/722": [{"task_id": "Mbpp/722", "solution": "def filter_data(data, min_height, min_weight):\n    return {k: v for k, v in data.items() if v[0] > min_height and v[1] > min_weight}", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[{"Cierra Vega": [6.2, 70], "Alden Cantrell": [5.9, 65], "Kierra Gentry": [6.0, 68], "Pierre Cox": [5.8, 66]}, 6.0, 70]], "plus_fail_tests": [[{"Alice": [5.6, 60], "Bob": [6.1, 70], "Charlie": [5.9, 65], "Dave": [5.11, 72], "Eve": [6.0, 68], "Frank": [5.7, 63]}, 5.8, 65]]}], "Mbpp/721": [{"task_id": "Mbpp/721", "solution": "def maxAverageOfPath(matrix):\n    n = len(matrix)\n    dp = [[0] * n for _ in range(n)]\n    dp[0][0] = matrix[0][0]\n    for i in range(1, n):\n        dp[i][0] = dp[i - 1][0] + matrix[i][0]\n        dp[0][i] = dp[0][i - 1] + matrix[0][i]\n    for i in range(1, n):\n        for j in range(1, n):\n            dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + matrix[i][j]\n    return dp[n - 1][n - 1] / (n * n)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [6, 5, 4], [7, 3, 9]]]], "plus_fail_tests": [[[[0, 0, 0], [0, 0, 0], [0, 0, -1]]]]}], "Mbpp/723": [{"task_id": "Mbpp/723", "solution": "def count_same_pair(list1, list2):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i]:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/724": [{"task_id": "Mbpp/724", "solution": "def power_base_sum(base, power):\n    return sum([int(i) for i in str(base**power)])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/726": [{"task_id": "Mbpp/726", "solution": "def multiply_elements(t):\n    return tuple(t[i] * t[i+1] for i in range(len(t)-1))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/730": [{"task_id": "Mbpp/730", "solution": "def consecutive_duplicates(l):\n    return [i for i, j in zip(l, l[1:]) if i != j]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[0, 0, 1, 2, 3, 4, 4, 5, 6, 6, 6, 7, 8, 9, 4, 4]]], "plus_fail_tests": [[["apple", "apple", "banana", "orange", "apple", "banana", "banana", "banana", "kiwi", "kiwi", "orange"]]]}], "Mbpp/728": [{"task_id": "Mbpp/728", "solution": "def sum_list(a,b):\n    return [a[i]+b[i] for i in range(len(a))]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/725": [{"task_id": "Mbpp/725", "solution": "import re\ndef extract_quotation(string: str) -> list:\n    return re.findall(r'\"([^\"]*)\"', string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/731": [{"task_id": "Mbpp/731", "solution": "import math\ndef lateralsurface_cone(r,h):\n    return math.pi*r*h", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[5, 12]], "plus_fail_tests": [[2.5, 8.3]]}], "Mbpp/732": [{"task_id": "Mbpp/732", "solution": "import re\ndef replace_specialchar(string):\n    return re.sub(r'[ ,.]', ':', string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/630": [{"task_id": "Mbpp/630", "solution": "from typing import List, Tuple\ndef get_coordinates(coord: Tuple[int, int]) -> List[Tuple[int, int]]:\n    return [(coord[0] - 1, coord[1] - 1), (coord[0], coord[1] - 1), (coord[0] + 1, coord[1] - 1),\n            (coord[0] - 1, coord[1]), (coord[0] + 1, coord[1]),\n            (coord[0] - 1, coord[1] + 1), (coord[0], coord[1] + 1), (coord[0] + 1, coord[1] + 1)]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[3, 4]]], "plus_fail_tests": [[[1, 1, 1]]]}], "Mbpp/733": [{"task_id": "Mbpp/733", "solution": "from typing import List\ndef find_first_occurrence(arr: List[int], target: int) -> int:\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            if mid == 0 or arr[mid - 1] < target:\n                return mid\n            else:\n                right = mid - 1\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/734": [{"task_id": "Mbpp/734", "solution": "def sum_Of_Subarray_Prod(lst):\n    sum = 0\n    for i in range(len(lst)):\n        for j in range(i+1,len(lst)+1):\n            sum += (lst[i:j])\n    return sum", "base_status": "fail", "plus_status": "pass", "base_fail_tests": [[[1, 2, 3]]], "plus_fail_tests": []}], "Mbpp/735": [{"task_id": "Mbpp/735", "solution": "def toggle_middle_bits(n):\n    return n ^ (n >> 1) ^ 1", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[9]], "plus_fail_tests": [[123456]]}], "Mbpp/737": [{"task_id": "Mbpp/737", "solution": "import re\ndef check_str(str1):\n    pattern = re.compile(r'^[aeiouAEIOU]')\n    if pattern.match(str1):\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/740": [{"task_id": "Mbpp/740", "solution": "def tuple_to_dict(tup):\n    return {tup[i]: tup[i+1] for i in range(0, len(tup), 2)}", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/736": [{"task_id": "Mbpp/736", "solution": "def left_insertion(arr,val):\n    for i in range(len(arr)):\n        if arr[i]>=val:\n            return i\n    return len(arr)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/741": [{"task_id": "Mbpp/741", "solution": "def all_Characters_Same(str1):\n    return len(set(str1)) == 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/742": [{"task_id": "Mbpp/742", "solution": "import math\ndef area_tetrahedron(a):\n    return math.sqrt(3)*a**2/4", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[3]], "plus_fail_tests": [[1000000]]}], "Mbpp/743": [{"task_id": "Mbpp/743", "solution": "def rotate_right(list, n):\n    return list[-n:] + list[:-n]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/744": [{"task_id": "Mbpp/744", "solution": "from typing import Tuple\ndef check_none(t: Tuple) -> bool:\n    return any([i is None for i in t])", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/749": [{"task_id": "Mbpp/749", "solution": "def sort_numeric_strings(list_of_strings):\n    return sorted(list_of_strings, key=int)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["4", "12", "45", "7", "0", "100", "200", "-12", "-500"]]], "plus_fail_tests": [[["10000000000", "99999999", "88888888", "7777777", "666666", "-55555", "-4444", "-333", "222", "111", "10", "9", "8", "7", "6", "5", "4", "3", "2", "1"]]]}], "Mbpp/750": [{"task_id": "Mbpp/750", "solution": "from typing import List, Tuple\ndef add_tuple(lst: List[int], tpl: Tuple[int]) -> List[int]:\n    return lst + list(tpl)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/748": [{"task_id": "Mbpp/748", "solution": "import re\ndef capital_words_spaces(string):\n    return re.sub(r\"(\\w)([A-Z])\", r\"\\1 \\2\", string)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/751": [{"task_id": "Mbpp/751", "solution": "def check_min_heap(arr):\n    n = len(arr)\n    for i in range(n):\n        if 2*i + 1 < n and arr[i] > arr[2*i + 1]:\n            return False\n        if 2*i + 2 < n and arr[i] > arr[2*i + 2]:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/745": [{"task_id": "Mbpp/745", "solution": "def divisible_by_digits(startnum, endnum):\n    result = []\n    for num in range(startnum, endnum + 1):\n        if all(int(digit) != 0 and num % int(digit) == 0 for digit in str(num)):\n            result.append(num)\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/752": [{"task_id": "Mbpp/752", "solution": "def jacobsthal_num(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return jacobsthal_num(n-1) + 2*jacobsthal_num(n-2)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100]]}], "Mbpp/753": [{"task_id": "Mbpp/753", "solution": "from typing import List, Tuple\ndef min_k(records: List[Tuple[str, int]], k: int) -> List[Tuple[str, int]]:\n    \"\"\"\n    Find minimum k records from tuple list\n    :param records: list of tuples\n    :param k: number of records to be returned\n    :return: list of tuples\n    \"\"\"\n    return sorted(records, key=lambda x: x[1])[:k]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/754": [{"task_id": "Mbpp/754", "solution": "def extract_index_list(l1, l2, l3):\n    return [i for i in l1 if i in l2 and i in l3]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 7], [0, 1, 2, 3, 4, 5, 7]]], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7], [0, 1, 2, 3, 4, 5, 6], [0, 2, 4, 6, 8, 10, 12]]]}], "Mbpp/757": [{"task_id": "Mbpp/757", "solution": "def count_reverse_pairs(string_list):\n    count = 0\n    for i in range(len(string_list)):\n        for j in range(i+1, len(string_list)):\n            if string_list[i] == string_list[j][::-1]:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/758": [{"task_id": "Mbpp/758", "solution": "from collections import Counter\nfrom typing import List, Dict, Tuple\ndef unique_sublists(lst: List[List[int]]) -> Dict[Tuple[int], int]:\n    return Counter(tuple(i) for i in lst)", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/755": [{"task_id": "Mbpp/755", "solution": "def second_smallest(list1):\n    list1.sort()\n    return list1[1]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, -0.5, 0, 2, -2, -2]]], "plus_fail_tests": [[[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5, 8, 9, 7, 9]]]}], "Mbpp/759": [{"task_id": "Mbpp/759", "solution": "import re\ndef is_decimal(string):\n    if re.match(r'^[0-9]+(\\.[0-9]{1,2})?$', string):\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/599": [{"task_id": "Mbpp/599", "solution": "def sum_average(n):\n    sum=0\n    for i in range(1,n+1):\n        sum+=i\n    avg=sum/n\n    return sum,avg", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100000000]]}], "Mbpp/760": [{"task_id": "Mbpp/760", "solution": "def unique_Element(list1):\n    if len(list1) == len(set(list1)):\n        return True\n    else:\n        return False", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 1, 1]]], "plus_fail_tests": [[[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]]]}], "Mbpp/762": [{"task_id": "Mbpp/762", "solution": "def check_monthnumber_number(month):\n    if month in [4,6,9,11]:\n        return True\n    elif month in [1,3,5,7,8,10,12]:\n        return False\n    else:\n        return \"Invalid month number\"", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[2]], "plus_fail_tests": [[2]]}], "Mbpp/763": [{"task_id": "Mbpp/763", "solution": "def find_min_diff(arr,n):\n    min_diff = arr[1] - arr[0]\n    for i in range(n-1):\n        for j in range(i+1,n):\n            if arr[j] - arr[i] < min_diff:\n                min_diff = arr[j] - arr[i]\n    return min_diff", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 5, 3, 19, 18, 25], 6]], "plus_fail_tests": [[[15, 12, 20, 30, 8, 4, 19, 37, 22, 28, 11, 25], 12]]}], "Mbpp/764": [{"task_id": "Mbpp/764", "solution": "def number_ctr(str1):\n    count = 0\n    for i in str1:\n        if i.isdigit():\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/767": [{"task_id": "Mbpp/767", "solution": "def get_pairs_count(lst, sum):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i] + lst[j] == sum:\n                count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/766": [{"task_id": "Mbpp/766", "solution": "def pair_wise(l):\n    return [(l[i], l[i+1]) for i in range(len(l)-1)]", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/769": [{"task_id": "Mbpp/769", "solution": "\"\"\"\nWrite a python function to get the difference between two lists.\nassert (Diff([10, 15, 20, 25, 30, 35, 40], [25, 40, 35])) == [10, 20, 30, 15]\n\"\"\"\n#PF-Assgn-33\ndef get_difference(list1,list2):\n    #remove pass and write your logic here\n    list3=[]\n    for i in list1:\n        if i not in list2:\n            list3.append(i)\n    for j in list2:\n        if j not in list1:\n            list3.append(j)\n    return list3\nlist1=[1,3,7,8,9]\nlist2=[1,2,4,5,6,7,8]", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/770": [{"task_id": "Mbpp/770", "solution": "def odd_num_sum(n):\n    sum = 0\n    for i in range(1, n*2, 2):\n        sum += i**4\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/765": [{"task_id": "Mbpp/765", "solution": "def is_polite(n):\n    if n == 1:\n        return 2\n    if n == 2:\n        return 4\n    if n == 3:\n        return 6\n    if n == 4:\n        return 8\n    if n == 5:\n        return 10\n    if n == 6:\n        return 12\n    if n == 7:\n        return 14\n    if n == 8:\n        return 16\n    if n == 9:\n        return 18\n    if n == 10:\n        return 20\n    if n == 11:\n        return 22\n    if n == 12:\n        return 24\n    if n == 13:\n        return 26\n    if n == 14:\n        return 28\n    if n == 15:\n        return 30\n    if n == 16:\n        return 32\n    if n == 17:\n        return 34\n    if n == 18:\n        return 36\n    if n == 19:\n        return 38\n    if n == 20:\n        return 40\n    if n == 21:\n        return 42\n    if n == 22:\n        return 44\n    if n == 23:\n        return 46\n    if n == 24:\n        return 48\n    if n == 25:\n        return 50\n    if n == 26:\n        return 52\n    if n == 27:\n        return 54\n    if n == 28:\n        return 56\n    if n == 29:\n        return 58\n    if n == 30:\n        return 60\n    if n == 31:\n        return 62\n    if n == 32:\n        return 64\n    if n == 33:\n        return 66\n    if n == 34:\n        return 68\n    if n == 35:\n        return 70\n    if n == 36:\n        return 72\n    if n == 37:\n        return 74\n    if n == 38:\n        return 76\n    if n == 39:\n        return 78\n    if n == 40:\n        return 80\n    if n == 41:\n        return 82\n    if n == 42:\n        return 84\n    if n == 43:\n        return 86\n    if n == 44:\n        return 88\n    if n == 45:\n        return 90\n    if n == 46:\n        return 92\n    if n == 47:\n        return 94\n    if n == 48:\n        return 96\n    if n == 49:\n        return 98\n    if n == 50:\n        return 100\n    if n == 51:\n        return 102\n    if n == 52:\n        return 104\n    if n == 53:\n        return 106\n    if n == 54:\n        return 108\n    if n == 55:\n        return 110", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[7]], "plus_fail_tests": [[10000000]]}], "Mbpp/771": [{"task_id": "Mbpp/771", "solution": "def check_expression(expression):\n    stack = []\n    for char in expression:\n        if char in ['{', '[', '(']:\n            stack.append(char)\n        elif char == '}':\n            if not stack or stack[-1] != '{':\n                return False\n            stack.pop()\n        elif char == ']':\n            if not stack or stack[-1] != '[':\n                return False\n            stack.pop()\n        elif char == ')':\n            if not stack or stack[-1] != '(':\n                return False\n            stack.pop()\n    return not stack\nexpression = \"{()}[{}]\"", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[""]]}], "Mbpp/772": [{"task_id": "Mbpp/772", "solution": "import re\ndef remove_length(string, k):\n    return re.sub(r'\\b\\w{%d}\\b' % k, '', string)", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["The person is most value tet", 3]], "plus_fail_tests": [["This is a Test of the Function", 4]]}], "Mbpp/773": [{"task_id": "Mbpp/773", "solution": "import re\ndef occurance_substring(string,substring):\n    if re.search(substring,string):\n        return re.search(substring,string).span()\n    else:\n        return None", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [["python programming, python language", "python"]], "plus_fail_tests": [["", ""]]}], "Mbpp/775": [{"task_id": "Mbpp/775", "solution": "def odd_position(nums):\n    for i in range(1, len(nums), 2):\n        if nums[i] % 2 == 0:\n            return False\n    return True", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/777": [{"task_id": "Mbpp/777", "solution": "def find_sum(lst):\n    sum = 0\n    for i in lst:\n        if lst.count(i) == 1:\n            sum += i\n    return sum", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3, 1, 1, 4, 5, 6]]], "plus_fail_tests": [[[-1, -2, -3, -1, -1, -4, -5, -6]]]}], "Mbpp/739": [{"task_id": "Mbpp/739", "solution": "def find_Index(n):\n    i = 1\n    while True:\n        if i*(i+1)/2 >= 10**(n-1):\n            return i\n        i += 1", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[100]]}], "Mbpp/778": [{"task_id": "Mbpp/778", "solution": "from typing import List, Any\ndef pack_consecutive_duplicates(lst: List[Any]) -> List[List[Any]]:\n    \"\"\"\n    Function to pack consecutive duplicates of a given list elements into sublists.\n    :param lst: List[Any]\n    :return: List[List[Any]]\n    \"\"\"\n    result = []\n    for i in range(len(lst)):\n        if i == 0:\n            result.append([lst[i]])\n        elif lst[i] == lst[i - 1]:\n            result[-1].append(lst[i])\n        else:\n            result.append([lst[i]])\n    return result", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/782": [{"task_id": "Mbpp/782", "solution": "def odd_length_sum(arr):\n    sum = 0\n    for i in range(1, len(arr)+1, 2):\n        for j in range(len(arr)-i+1):\n            sum += sum_subarray(arr, j, i)\n    return sum\ndef sum_subarray(arr, start, length):\n    sum = 0\n    for i in range(start, start+length):\n        sum += arr[i]\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/784": [{"task_id": "Mbpp/784", "solution": "def mul_even_odd(lst):\n    even = 0\n    odd = 0\n    for i in lst:\n        if i % 2 == 0:\n            even = i\n        else:\n            odd = i\n    return even * odd", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 3, 5, 7, 4, 1, 6, 8]]], "plus_fail_tests": [[[0, 1, -1, 2, -2, 3, -3]]]}], "Mbpp/780": [{"task_id": "Mbpp/780", "solution": "from itertools import combinations\ndef find_combinations(tuples):\n    result = []\n    for i in range(1, len(tuples) + 1):\n        for combo in combinations(tuples, i):\n            result.append(sum(combo))\n    return result", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[[1, 2, 3], [3, 4, 5]]]], "plus_fail_tests": [[[[100, 200], [300, 400], [500, 600], [700, 800]]]]}], "Mbpp/785": [{"task_id": "Mbpp/785", "solution": "import pytest\ndef tuple_str_int(tup_str: str) -> tuple:\n    \"\"\"Convert tuple string to integer tuple.\n\n    Args:\n        tup_str (str): tuple string\n\n    Returns:\n        tuple: integer tuple\n    \"\"\"\n    return tuple(int(i) for i in tup_str[1:-1].split(\",\"))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/786": [{"task_id": "Mbpp/786", "solution": "def right_insertion(arr,val):\n    for i in range(len(arr)):\n        if arr[i]>=val:\n            return i\n    return len(arr)", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[50.64327388212607, -72.16612625583227, 95.25630303581863, -75.73998556144497, 11.857449640680656, 90.05081633927793, -90.20293226837086, -12.02758648076636, -35.964731488229475], 7]]}], "Mbpp/787": [{"task_id": "Mbpp/787", "solution": "import re\ndef text_match_three(text):\n    \"\"\"\n    :param text: string\n    :return: boolean\n    \"\"\"\n    pattern = r'ab{3}'\n    return re.search(pattern, text) is not None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/788": [{"task_id": "Mbpp/788", "solution": "from typing import Tuple\ndef new_tuple(list_: list, string: str) -> Tuple[str, ...]:\n    return tuple(list_ + list(string))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[["WEB", "is"], "best"]], "plus_fail_tests": [[[], ""]]}], "Mbpp/790": [{"task_id": "Mbpp/790", "solution": "def even_position(lst):\n    for i in range(0,len(lst),2):\n        if lst[i]%2!=0:\n            return False\n    return True", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[2, 1, 4, 2, 6, 1, 8, 2, 10, 1, 12]]]}], "Mbpp/793": [{"task_id": "Mbpp/793", "solution": "def last(arr,ele):\n    low=0\n    high=len(arr)-1\n    while low<=high:\n        mid=(low+high)//2\n        if arr[mid]>ele:\n            high=mid-1\n        elif arr[mid]<ele:\n            low=mid+1\n        else:\n            if mid==len(arr)-1 or arr[mid+1]!=arr[mid]:\n                return mid\n            else:\n                low=mid+1\n    return -1", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/796": [{"task_id": "Mbpp/796", "solution": "def return_sum(dict):\n    sum = 0\n    for i in dict.values():\n        sum += i\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/791": [{"task_id": "Mbpp/791", "solution": "from typing import Any, Tuple\ndef remove_nested(t: Tuple) -> Tuple:\n    \"\"\"Remove nested tuples from the given tuple.\"\"\"\n    return tuple(x for x in t if not isinstance(x, tuple))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/794": [{"task_id": "Mbpp/794", "solution": "import re\ndef text_starta_endb(text):\n    pattern = r'^a.*b$'\n    result = re.search(pattern, text)\n    return result", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["xaabbyz1323ababb"]]}], "Mbpp/792": [{"task_id": "Mbpp/792", "solution": "def count_list(lists):\n    count = 0\n    for i in lists:\n        if type(i) == list:\n            count += 1\n    return count", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/798": [{"task_id": "Mbpp/798", "solution": "def _sum(arr):\n    sum = 0\n    for i in arr:\n        sum += i\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/797": [{"task_id": "Mbpp/797", "solution": "def sum_in_range(l,r):\n    sum=0\n    for i in range(l,r+1):\n        if i%2!=0:\n            sum+=i\n    return sum", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/799": [{"task_id": "Mbpp/799", "solution": "def left_rotate(n,d):\n    return (n << d) | (n >> (32-d))", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/801": [{"task_id": "Mbpp/801", "solution": "def test_three_equal(a,b,c):\n    if a==b==c:\n        return 3\n    elif a==b or b==c or a==c:\n        return 2\n    else:\n        return 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/800": [{"task_id": "Mbpp/800", "solution": "def remove_all_spaces(string):\n    return string.replace(\" \", \"\")", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/803": [{"task_id": "Mbpp/803", "solution": "import math\ndef is_perfect_square(n):\n    if n < 0:\n        return False\n    return math.sqrt(n) % 1 == 0", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/805": [{"task_id": "Mbpp/805", "solution": "def max_sum_list(lists):\n    max_sum = 0\n    max_sum_list = []\n    for list in lists:\n        sum = 0\n        for element in list:\n            sum += element\n        if sum > max_sum:\n            max_sum = sum\n            max_sum_list = list\n    return max_sum_list", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[[[-10, -20, -30], [-40, -50, -60], [-70, -80, -90], [-100, -110, -120]]]]}], "Mbpp/806": [{"task_id": "Mbpp/806", "solution": "import re\ndef max_run_uppercase(string):\n    return max(len(x) for x in re.findall(r'[A-Z]+', string))", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [["a"]]}], "Mbpp/808": [{"task_id": "Mbpp/808", "solution": "def check_K(tup, k):\n    if k in tup:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/807": [{"task_id": "Mbpp/807", "solution": "def first_odd(num_list):\n    for num in num_list:\n        if num % 2 != 0:\n            return num\n    return None", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/809": [{"task_id": "Mbpp/809", "solution": "def check_smaller(t1, t2):\n    return all(x < y for x, y in zip(t1, t2))", "base_status": "fail", "plus_status": "fail", "base_fail_tests": [[[1, 2, 3], [2, 3, 4]]], "plus_fail_tests": [[[3, 7, 11, 15, 19], [2, 6, 10, 14, 18]]]}], "Mbpp/804": [{"task_id": "Mbpp/804", "solution": "def is_product_even(list):\n    product = 1\n    for i in list:\n        product *= i\n    if product % 2 == 0:\n        return True\n    else:\n        return False", "base_status": "pass", "plus_status": "pass", "base_fail_tests": [], "plus_fail_tests": []}], "Mbpp/781": [{"task_id": "Mbpp/781", "solution": "def count_divisors(n):\n    count = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            count += 1\n    return count % 2 == 0", "base_status": "pass", "plus_status": "fail", "base_fail_tests": [], "plus_fail_tests": [[987654321]]}]}, "pass_at_k": {"base": {"pass@1": 0.701058201058201}, "plus": {"pass@1": 0.5873015873015873}}}