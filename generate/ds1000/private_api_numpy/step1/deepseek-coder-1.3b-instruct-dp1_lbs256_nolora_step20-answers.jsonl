{"id": 0, "code": "result = df.reindex(List)\nprint(result)\n", "metadata": {"problem_id": 0, "library_problem_id": 0, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 0}}
{"id": 1, "code": "\nresult = df.reindex(List)\nprint(result)\n", "metadata": {"problem_id": 1, "library_problem_id": 1, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 0}}
{"id": 2, "code": "\n# First, get the value counts for each column\ncounts = df.apply(pd.value_counts)\n\n# Then, get the values that have at least 2 occurrences\nvalues_with_at_least_2 = counts.loc[:, counts >= 2].columns.tolist()\n\n# Create a dictionary to map old values to new values\nmap_dict = dict(zip(values_with_at_least_2, values_with_at_least_2))\n\n# Replace the old values with the new values\ndf.replace(map_dict, inplace=True)\n\n# Now, the values in Qu1, Qu2, Qu3 should be the same as in the original dataframe\nresult = df\n", "metadata": {"problem_id": 2, "library_problem_id": 2, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 2}}
{"id": 3, "code": "\n# First, get the value counts\ncounts = df.apply(pd.value_counts)\n\n# Then, get the values that have at least 3 occurrences\nvalues_at_least_3 = counts.loc[:, counts >= 3].columns.tolist()\n\n# For Qu1, replace the values that are not in the list with 'other'\ndf['Qu1'] = pd.Categorical(df['Qu1']).replace(to_replace=values_at_least_3, \n                                               replacement='other', \n                                               inplace=False)\n\n# For Qu2, do the same as Qu1\ndf['Qu2'] = pd.Categorical(df['Qu2']).replace(to_replace=values_at_least_3, \n                                               replacement='other', \n                                               inplace=False)\n\n# For Qu3, do the same as Qu1\ndf['Qu3'] = pd.Categorical(df['Qu3']).replace(to_replace=values_at_least_3, \n                                               replacement='other', \n                                               inplace=False)\n\nresult = df\n", "metadata": {"problem_id": 3, "library_problem_id": 3, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 2}}
{"id": 4, "code": "\n    for col in df.columns:\n        counts = df[col].value_counts()\n        for index, value in enumerate(counts):\n            if value >= 2:\n                df[col] = df[col].replace(value, 'other')\n    return df\n    ### END SOLUTION\n\nprint(f())\n", "metadata": {"problem_id": 4, "library_problem_id": 4, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 2}}
{"id": 5, "code": "\n# First, count the occurrence of each value in each column\ncounts = df.apply(pd.value_counts)\n\n# Then, for each column, if the count is 3 or more, replace the value with 'other'\ndf.loc[:, 'Qu1':'Qu3'] = df.loc[:, 'Qu1':'Qu3'].apply(lambda x: 'other' if x.name in counts.loc[x.name] and counts.loc[x.name] >= 3 else x)\n\nresult = df\n", "metadata": {"problem_id": 5, "library_problem_id": 5, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 2}}
{"id": 6, "code": "\n# First, count the occurrence of each value in each column\ncounts = df.apply(pd.value_counts)\n\n# Then, replace the values in each column according to the counts\ndf = df.replace(counts.loc[:, 'Qu1'] >= 3, 'other')\ndf = df.replace(counts.loc[:, 'Qu2'] >= 2, 'other')\ndf = df.replace(counts.loc[:, 'Qu3'] >= 2, 'other')\n\n# Finally, replace the 'apple' with 'egg'\ndf = df.replace('apple', 'egg')\n\nresult = df\n", "metadata": {"problem_id": 6, "library_problem_id": 6, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 2}}
{"id": 7, "code": "df['id'] = range(1, len(df) + 1)\nresult = df.drop_duplicates(subset='url', keep='first')\n", "metadata": {"problem_id": 7, "library_problem_id": 7, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 7}}
{"id": 8, "code": "df['drop_if_dup'] = df.groupby('url')['drop_if_dup'].transform(lambda x: 'Yes' if x.nunique() == 1 else 'No')\nresult = df.drop_duplicates(subset='url', keep='first')\n", "metadata": {"problem_id": 8, "library_problem_id": 8, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 7}}
{"id": 9, "code": "df['id'] = range(1, len(df) + 1)\nresult = df.drop_duplicates(subset='url', keep='last')\n", "metadata": {"problem_id": 9, "library_problem_id": 9, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 7}}
{"id": 10, "code": "\ndf_melt = pd.melt(df, id_vars=['name'], var_name='v2', value_name='v3')\ndf_grouped = df_melt.groupby(['name', 'v2']).size().unstack().fillna(0).astype(int)\nresult = df_grouped.groupby(level=0).apply(lambda x: x.to_dict()).to_dict()\n", "metadata": {"problem_id": 10, "library_problem_id": 10, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 10}}
{"id": 11, "code": "df['datetime'] = df['datetime'].dt.tz_convert(None)", "metadata": {"problem_id": 11, "library_problem_id": 11, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 11}}
{"id": 12, "code": "\n    df['datetime'] = df['datetime'].dt.tz_convert(None)\n    return df\n    ### END SOLUTION\n\nprint(f())\n", "metadata": {"problem_id": 12, "library_problem_id": 12, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 11}}
{"id": 13, "code": "df['datetime'] = df['datetime'].dt.tz_convert(None)", "metadata": {"problem_id": 13, "library_problem_id": 13, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 11}}
{"id": 14, "code": "df['datetime'] = df['datetime'].dt.tz_convert(None)\n", "metadata": {"problem_id": 14, "library_problem_id": 14, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 11}}
{"id": 15, "code": "\n# First, we need to parse the message to extract the key-value pairs\ndf['message'] = df['message'].str.replace('\\[|\\]|, ', '').str.split(', ').apply(lambda x: {i.split(':')[0].strip(): i.split(':')[1].strip() for i in x})\n\n# Then, we can use the updated 'message' column to create a new DataFrame\ndf_new = df[['name', 'status', 'number', 'message']].explode('message').reset_index(drop=True)\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Finally, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message' column to the desired format\ndf_new['message'] = df_new['message'].apply(lambda x: x.replace('none', ''))\n\n# Now, we can convert the 'message'", "metadata": {"problem_id": 15, "library_problem_id": 15, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 15}}
{"id": 16, "code": "df['score'] = df.apply(lambda row: row['score'] * 10 if row['product'] in products else row['score'], axis=1)\n", "metadata": {"problem_id": 16, "library_problem_id": 16, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 16}}
{"id": 17, "code": "df['score'] = df.apply(lambda row: row['score'] * 10 if row['product'] in products else row['score'], axis=1)\n", "metadata": {"problem_id": 17, "library_problem_id": 17, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 16}}
{"id": 18, "code": "\nfor product in products:\n    df.loc[df['product'].between(product[0], product[1]), 'score'] *= 10\n", "metadata": {"problem_id": 18, "library_problem_id": 18, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 16}}
{"id": 19, "code": "\ndf['score'] = df.apply(lambda row: 1 if row['product'] in products else row['score'], axis=1)\ndf['score'] = (df['score'] - df['score'].min()) / (df['score'].max() - df['score'].min())\ndf = df.drop('product', 1)\n", "metadata": {"problem_id": 19, "library_problem_id": 19, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 16}}
{"id": 20, "code": "\ndf['category'] = df.idxmax(axis=1)\ndf\n", "metadata": {"problem_id": 20, "library_problem_id": 20, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 20}}
{"id": 21, "code": "\ndf['category'] = df.idxmax(axis=1)\n", "metadata": {"problem_id": 21, "library_problem_id": 21, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 20}}
{"id": 22, "code": "\n# First, create a list of binary columns\nbinary_cols = ['A', 'B', 'C', 'D']\n\n# Then, create a new column 'category'\ndf['category'] = df[binary_cols].apply(lambda x: [col for col in binary_cols if x[col] == 1], axis=1)\n\n# Finally, remove the binary columns\ndf = df.drop(binary_cols, axis=1)\n", "metadata": {"problem_id": 22, "library_problem_id": 22, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 20}}
{"id": 23, "code": "df['Date'] = df['Date'].dt.strftime('%b-%Y')\n", "metadata": {"problem_id": 23, "library_problem_id": 23, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 23}}
{"id": 24, "code": "df['Date'] = df['Date'].dt.strftime('%d-%b-%Y')", "metadata": {"problem_id": 24, "library_problem_id": 24, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 23}}
{"id": 25, "code": "df['Date'] = df['Date'].dt.strftime('%d-%b-%Y %A')\ndf = df.set_index('Date')\ndf", "metadata": {"problem_id": 25, "library_problem_id": 25, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 23}}
{"id": 26, "code": "\ndf['#1'] = df['#1'].shift(-1)\ndf = df.iloc[1:]\ndf['#2'] = df['#2'].shift(-1)\ndf = df.iloc[1:]\ndf\n", "metadata": {"problem_id": 26, "library_problem_id": 26, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 26}}
{"id": 27, "code": "\ndf['#1'] = df['#1'].shift(-1)\ndf.loc['1980-01-01'][0] = df.loc['1980-01-01'][0]\ndf = df.iloc[1:]\ndf\n", "metadata": {"problem_id": 27, "library_problem_id": 27, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 26}}
{"id": 28, "code": "\ndf['#1'] = df['#1'].shift(-1)\ndf['#2'] = df['#2'].shift(1)\ndf = df.iloc[:, ::-1]\ndf = df.reset_index(drop=True)\nprint(df)\n", "metadata": {"problem_id": 28, "library_problem_id": 28, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 26}}
{"id": 29, "code": "\n# First, shift the first row of the first column down by 1 row\ndf['#1'] = df['#1'].shift(-1)\n\n# Then, shift the last row of the first column to the first row, first column\ndf['#2'] = df['#2'].shift(1)\n\ndf = df.iloc[:, ::-1]\n\ndf\n", "metadata": {"problem_id": 29, "library_problem_id": 29, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 26}}
{"id": 30, "code": "df.columns = [col + 'X' for col in df.columns]", "metadata": {"problem_id": 30, "library_problem_id": 30, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 30}}
{"id": 31, "code": "df.columns = ['X' + col for col in df.columns]\n", "metadata": {"problem_id": 31, "library_problem_id": 31, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 30}}
{"id": 32, "code": "\n# Create a list of all column names\ncols = df.columns.tolist()\n\n# Create a list of new column names\nnew_cols = ['XHeader' + col if not col.endswith('X') else 'Header' + col for col in cols]\n\n# Rename the columns\ndf.columns = new_cols\n", "metadata": {"problem_id": 32, "library_problem_id": 32, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 30}}
{"id": 33, "code": "\n# Create a list of columns that contain 'val'\ncols_with_val = [col for col in df.columns if 'val' in col]\n\n# Calculate the mean of the columns in the list\nresult = df[cols_with_val].groupby('group').mean()\n\nprint(result)\n", "metadata": {"problem_id": 33, "library_problem_id": 33, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 33}}
{"id": 34, "code": "\ndf.columns = [i if 'val' not in i else 'val'+str(int(i.split('val')[1])+1) for i in df.columns]\nresult = df.groupby('group').agg({\"group_color\": \"first\", \"val1\": \"sum\", \"val2\": \"sum\", \"val3\": \"sum\"})\nresult.columns = ['group_color', 'val1', 'val2', 'val3']\nresult = result.reset_index()\n", "metadata": {"problem_id": 34, "library_problem_id": 34, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 33}}
{"id": 35, "code": "\ndf['val32'] = df.groupby('group')['val42'].transform('sum')\n\ndf['val1'] = df.groupby('group')['val1'].transform('sum')\ndf['val2'] = df.groupby('group')['val2'].transform('mean')\n\nresult = df.groupby('group').agg({\"group_color\": \"first\", \"val1\": \"sum\", \"val2\": \"mean\", \"val32\": \"mean\"})\n", "metadata": {"problem_id": 35, "library_problem_id": 35, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 33}}
{"id": 36, "code": "\nresult = df.loc[row_list, column_list].mean()", "metadata": {"problem_id": 36, "library_problem_id": 36, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 36}}
{"id": 37, "code": "\nresult = df.loc[row_list, column_list].sum()", "metadata": {"problem_id": 37, "library_problem_id": 37, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 36}}
{"id": 38, "code": "\nresult = df.loc[row_list, column_list].sum()\nresult = result.sort_values(ascending=False).drop_duplicates().index\ndf = df.loc[result]\n", "metadata": {"problem_id": 38, "library_problem_id": 38, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 36}}
{"id": 39, "code": "\n# First, we need to remove the 'null' values from 'temp' column\ndf['temp'] = df['temp'].apply(lambda x: 'null' if x == 'null' else x)\n\n# Then, we convert 'temp' column to numeric\ndf['temp'] = pd.to_numeric(df['temp'])\n\n# Now, we can get the value counts\nresult = df.apply(pd.value_counts)\n\n# And finally, we convert the numeric values back to strings\nresult = result.applymap(str)\n\nprint(result)\n", "metadata": {"problem_id": 39, "library_problem_id": 39, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 39}}
{"id": 40, "code": "\nnull_counts = df.isnull().sum()\nresult = null_counts[null_counts > 0]\nresult", "metadata": {"problem_id": 40, "library_problem_id": 40, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 39}}
{"id": 41, "code": "\n# Create a function to get the value counts\ndef get_value_counts(df):\n    return df.value_counts()\n\n# Apply the function to each column\nresult = {col: get_value_counts(df[col]) for col in df.columns}\n\n# Print the result\nfor key, value in result.items():\n    print(f\"---- {key} ---\")\n    print(value, \"\\n\")\n", "metadata": {"problem_id": 41, "library_problem_id": 41, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 39}}
{"id": 42, "code": "df = df.iloc[2:].reset_index(drop=True)\ndf.columns = df.loc[0].astype(str)\ndf = df[1:]\nresult = df\n", "metadata": {"problem_id": 42, "library_problem_id": 42, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 42}}
{"id": 43, "code": "df = df.iloc[2:].reset_index(drop=True)\ndf.columns = df.loc[0].astype(str)\ndf = df.iloc[:, :-1]\ndf = df.reset_index(drop=True)\ndf = df.rename(columns={'index': 'Nanonose'})\ndf = df.iloc[:1, :]\ndf = df.reset_index(drop=True)\ndf = pd.concat([df.iloc[0], df.iloc[1]], axis=1)\ndf = df.reset_index(drop=True)\ndf = df.rename(columns={'index': 'Nanonose'})\ndf = df.iloc[:1, :]\ndf = df.reset_index(drop=True)\nresult = df\n", "metadata": {"problem_id": 43, "library_problem_id": 43, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 42}}
{"id": 44, "code": "\ndef fill_nan(x):\n    x = x.dropna()\n    x = x.sort_values()\n    return x\n\ndf = df.apply(fill_nan, axis=1)\nresult = df\n", "metadata": {"problem_id": 44, "library_problem_id": 44, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 44}}
{"id": 45, "code": "\ndf['0'] = df['0'].astype(str) + df['1'].astype(str) + df['2'].astype(str)\ndf = df.drop(['1', '2'], axis=1)\ndf = df.rename(columns={'0': '0'})\nresult = df\n", "metadata": {"problem_id": 45, "library_problem_id": 45, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 44}}
{"id": 46, "code": "\ndf['0'] = df['0'].mask(df['0'].isnull(), df['0'].notnull().shift(-1))\ndf = df.iloc[1:]\ndf", "metadata": {"problem_id": 46, "library_problem_id": 46, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 44}}
{"id": 47, "code": "\n# First, find the rows where the value is less than the threshold\nrows_to_sum = df[df['value'] < thresh]\n\n# Then, sum the values in these rows\nsum_value = rows_to_sum['value'].sum()\n\n# Finally, replace the rows with the sum in the original dataframe\ndf.loc[df['value'] >= thresh, 'value'] = sum_value\nresult = df\n", "metadata": {"problem_id": 47, "library_problem_id": 47, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 47}}
{"id": 48, "code": "\n# First, find the rows where the value is less than the threshold\nrows_to_replace = df[df['value'] < thresh]\n\n# Then, calculate the average of these rows\naverage = rows_to_replace.mean()\n\n# Finally, replace the original dataframe with the average row\ndf.loc['X'] = average\nresult = df\n", "metadata": {"problem_id": 48, "library_problem_id": 48, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 47}}
{"id": 49, "code": "\n# Create a mask for the rows to be replaced\nmask = (df['value'] >= section_left) & (df['value'] <= section_right)\n\n# Replace the rows with the average of the selected rows\ndf.loc['X'] = df.loc[mask, 'value'].mean()\n\n# Reset the index\ndf = df.reset_index()\n\nresult = df\n", "metadata": {"problem_id": 49, "library_problem_id": 49, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 47}}
{"id": 50, "code": "\nfor col in df.columns:\n    df[\"inv_\" + col] = 1 / df[col]\n\nresult = df\n", "metadata": {"problem_id": 50, "library_problem_id": 50, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 50}}
{"id": 51, "code": "\ndf = pd.concat([df, pd.DataFrame(df.columns.to_series().apply(lambda x: [np.exp(x)]), columns=['exp_'+col for col in df.columns])], axis=1)\nresult = df\n", "metadata": {"problem_id": 51, "library_problem_id": 51, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 50}}
{"id": 52, "code": "\n# create a dictionary with the inverses\ninverse_dict = {col: \"inv_\" + col for col in df.columns}\n\n# apply the dictionary to the dataframe\ndf = df.rename(inverse_dict)\n\n# add the inverses to the dataframe\ndf[\"inv_A\"] = df[\"A\"].map(lambda x: 1/x if x != 0 else 0)\ndf[\"inv_B\"] = df[\"B\"].map(lambda x: 1/x if x != 0 else 0)\n\nresult = df\n", "metadata": {"problem_id": 52, "library_problem_id": 52, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 50}}
{"id": 53, "code": "\nimport numpy as np\n\ndef sigmoid(x):\n    return 1 / (1 + np.exp(-x))\n\nfor col in df.columns:\n    df['sigmoid_' + col] = df[col].apply(sigmoid)\n\nresult = df\n", "metadata": {"problem_id": 53, "library_problem_id": 53, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 50}}
{"id": 54, "code": "\n# Get the index of the minimum value in each column\nmin_idx = df.idxmin()\n\n# Get the index of the maximum value in each column\nmax_idx = df.idxmax()\n\n# Create a mask where the maximum value is located after the minimum value\nmask = (max_idx.values > min_idx.values)\n\n# Apply the mask to the DataFrame\nresult = df.loc[mask]\n\n# Convert the result to datetime\nresult.index = result.index.to_series().dt.date\n\nprint(result)\n", "metadata": {"problem_id": 54, "library_problem_id": 54, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 54}}
{"id": 55, "code": "\n# Get the index of the minimum value in each column\nmin_idx = df.idxmin()\n\n# Get the index of the maximum value in each column\nmax_idx = df.idxmax()\n\n# Create a mask where the maximum value is before the minimum value\nmask = (max_idx < min_idx)\n\n# Apply the mask to the DataFrame\nresult = df.loc[mask]\n\n# Reset the index\nresult.reset_index(drop=True, inplace=True)\n\nprint(result)\n", "metadata": {"problem_id": 55, "library_problem_id": 55, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 54}}
{"id": 56, "code": "\n# First, find the minimum and maximum dates\nmin_date = df['dt'].min()\nmax_date = df['dt'].max()\n\n# Create a range of dates between the minimum and maximum\ndate_range = pd.date_range(start=min_date, end=max_date)\n\n# Expand the date_range to include all dates\ndf_full = pd.DataFrame({'dt': date_range, 'val': 0}, index=range(len(date_range)))\n\n# Merge the original dataframe with the expanded dataframe\ndf_full = df_full.merge(df, how='left')\n\n# Fill the 'val' column with 0 where there is no matching date\ndf_full['val'] = df_full['val'].fillna(0)\n\nresult = df_full\n", "metadata": {"problem_id": 56, "library_problem_id": 56, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 56}}
{"id": 57, "code": "\n# First, find the minimum and maximum dates\nmin_date = df['dt'].min()\nmax_date = df['dt'].max()\n\n# Create a range of dates between the minimum and maximum\ndate_range = pd.date_range(start=min_date, end=max_date)\n\n# Expand the date_range to include all dates\ndf_full = pd.DataFrame({'dt': date_range, 'val': 0}, index=range(len(date_range)))\n\n# Merge the original dataframe with the expanded one\ndf_full = pd.merge(df_full, df, on=['dt', 'user'], how='left')\n\n# Fill the missing values with 0\ndf_full['val'] = df_full['val'].fillna(0)\n\nresult = df_full\n", "metadata": {"problem_id": 57, "library_problem_id": 57, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 56}}
{"id": 58, "code": "\n# First, find the minimum and maximum dates\nmin_date = df['dt'].min()\nmax_date = df['dt'].max()\n\n# Create a range from the minimum to the maximum date\ndate_range = pd.date_range(start=min_date, end=max_date)\n\n# Expand the date_range to include all dates\ndf_full = pd.DataFrame({'dt': date_range, 'val': 233}, index=range(len(date_range)))\n\n# Merge the original dataframe with the expanded one\ndf_full = pd.merge(df_full, df, on=['dt', 'user'], how='left')\n\n# Fill the missing values with 233\ndf_full['val'] = df_full['val'].fillna(233)\n\n# Sort the dataframe by date and user\ndf_full = df_full.sort_values(['dt', 'user'])\n\nresult = df_full\n", "metadata": {"problem_id": 58, "library_problem_id": 58, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 56}}
{"id": 59, "code": "df = df.set_index(['user', 'dt']).groupby('user').resample('D').max().reset_index()\ndf['val'] = df.groupby('user').transform('max')\ndf = df.set_index(['user', 'dt']).groupby('user').resample('D').fill(method='ffill').reset_index()\nresult = df\n", "metadata": {"problem_id": 59, "library_problem_id": 59, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 56}}
{"id": 60, "code": "df = df.set_index('dt').groupby('user').resample('D').max().reset_index()\ndf['dt'] = df['dt'].dt.strftime('%d-%b-%Y')\ndf = df.sort_values('dt')\nresult = df\n", "metadata": {"problem_id": 60, "library_problem_id": 60, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 56}}
{"id": 61, "code": "df['name'] = df['name'].astype('category').cat.codes\nresult = df\n", "metadata": {"problem_id": 61, "library_problem_id": 61, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 61}}
{"id": 62, "code": "df['a'] = df.groupby('name')['a'].transform('idxmax') + 1\nresult = df\n", "metadata": {"problem_id": 62, "library_problem_id": 62, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 61}}
{"id": 63, "code": "\n    df['name'] = df['name'].astype('category').cat.codes\n    return df\n    ### END SOLUTION\n\nprint(f())\n", "metadata": {"problem_id": 63, "library_problem_id": 63, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 61}}
{"id": 64, "code": "df['ID'] = df.groupby('name')['a'].transform('first') + df.groupby('name')['a'].cumcount()\nresult = df[['ID', 'b', 'c']]\n", "metadata": {"problem_id": 64, "library_problem_id": 64, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 61}}
{"id": 65, "code": "df = df.melt(id_vars=['user', 'someBool'], var_name='date', value_name='value')\ndf = df.sort_values(by=['user', 'date'])\ndf = df.reset_index(drop=True)\ndf = df.groupby('user')['date', 'value', 'someBool'].apply(list)\ndf = df.reset_index()\ndf = df.rename(columns={'date': '01/12/15', 'value': '300', 'someBool': 'True'})\ndf = df.drop(columns=['300'])\ndf = df.rename(columns={'01/12/15': 'date', '300': 'value', 'True': 'someBool'})\ndf = df.sort_values(by=['user', 'date'])\ndf = df.reset_index(drop=True)\ndf\n", "metadata": {"problem_id": 65, "library_problem_id": 65, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 65}}
{"id": 66, "code": "df = df.melt(id_vars=['user', '01/12/15'], var_name='others', value_name='value')\ndf = df.sort_values(['user', 'others'])\ndf = df.reset_index(drop=True)\ndf", "metadata": {"problem_id": 66, "library_problem_id": 66, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 65}}
{"id": 67, "code": "df = df.melt(id_vars='user', var_name='date', value_name='value')\ndf['date'] = df['date'].str.split(' ', 1).str[0]\ndf = df.pivot_table(index='user', columns='date', values='value', dropna=False)\ndf = df.reset_index()\ndf = df.rename(columns={'01/12/15': 'date1', '02/12/15': 'date2'})\ndf = df.merge(df.drop(['date1', 'date2'], axis=1), left_index=True, right_index=True)\ndf = df[['user', 'date1', 'date2', 'value1', 'value2']]\ndf = df.rename(columns={'date1': '01/12/15', 'date2': '02/12/15', 'value1': 'value', 'value2': 'someBool'})\n", "metadata": {"problem_id": 67, "library_problem_id": 67, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 65}}
{"id": 68, "code": "\nmask = df['c'] > 0.5\nresult = df.loc[mask, columns]\nresult = np.array(result)\n", "metadata": {"problem_id": 68, "library_problem_id": 68, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 68}}
{"id": 69, "code": "\nmask = df['c'] > 0.45\nresult = df.loc[mask, columns].values\n", "metadata": {"problem_id": 69, "library_problem_id": 69, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 68}}
{"id": 70, "code": "\n    return df.loc[df['c'] > 0.5, columns]\n    ### END SOLUTION\n\ndf = pd.DataFrame(np.random.rand(4,5), columns = list('abcde'))\nprint(f(df))\n", "metadata": {"problem_id": 70, "library_problem_id": 70, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 68}}
{"id": 71, "code": "\n    df_sub = df.loc[df['c'] > 0.5, ['b', 'e']]\n    df_sub['sum'] = df_sub['b'] + df_sub['e']\n    return df_sub\n    ### END SOLUTION\n", "metadata": {"problem_id": 71, "library_problem_id": 71, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 68}}
{"id": 72, "code": "\n    return df.loc[df['c'] > 0.5, columns]\n    ### END SOLUTION\n", "metadata": {"problem_id": 72, "library_problem_id": 72, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 68}}
{"id": 73, "code": "\n# Convert date to datetime\ndf['date'] = pd.to_datetime(df['date'])\n\n# Sort the dataframe by date\ndf = df.sort_values('date')\n\n# Create a new column 'date_range' which is the date of the row plus the number of days\ndf['date_range'] = df.groupby('ID')['date'].shift(-X) + pd.DateOffset(days=X)\n\n# Filter the dataframe to only include rows where 'date_range' is greater than the current date\ndf = df[df['date_range'] > pd.Timestamp.now()]\n\n# Reset the index\ndf = df.reset_index(drop=True)\n\nresult = df\n", "metadata": {"problem_id": 73, "library_problem_id": 73, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 73}}
{"id": 74, "code": "\n# Convert date to datetime\ndf['date'] = pd.to_datetime(df['date'])\n\n# Sort the dataframe by date\ndf = df.sort_values('date')\n\n# Create a new column 'week' which represents the week of the year\ndf['week'] = df['date'].dt.to_period('W')\n\n# Create a new column 'week_end' which represents the end of the week\ndf['week_end'] = df['date'].dt.to_period('W').dt.end_time\n\n# Create a new column 'week_start' which represents the start of the week\ndf['week_start'] = df['date'].dt.to_period('W').dt.start_time\n\n# Create a new column 'week_start_date' which represents the date of the start of the week\ndf['week_start_date'] = df['week_start'].dt.to_datetime()\n\n# Create a new column 'week_end_date' which represents the date of the end of the week\ndf['week_end_date'] = df['week_end'].dt.to_datetime()\n\n# Create a new column 'week_start_date_str' which represents the date of the start of the week as a string\ndf['week_start_date_str'] = df['week_start_date'].dt.strftime('%m/%d/%y')\n\n# Create a new column 'week_end_date_str' which represents the date of the end of the week as a string\ndf['week_end_date_str'] = df['week_end_date'].dt.strftime('%m/%d/%y')\n\n# Create a new column 'week_start_date_str' which represents the date of the start of the week as a string\ndf['week_start_date_str'] = df['week_start_date'].dt.strftime('%m/%d/%y')\n\n# Create a new column 'week_end_date_str' which represents the date of the end of the week as a string\ndf['week_end_date_str'] = df['week_end_date'].dt.strftime('%m/%d/%y')\n\n# Create a new column 'week_start_date_str' which represents the date of the start of the week as a string\ndf['week_start_date_str'] = df['week_start_date'].dt.strftime('%m/%d/%y')\n\n# Create a new column 'week_end_date_str' which represents the date of the end of the week as a string\ndf['week_end_date_str'] = df['week_end_date'].dt.strftime('%m/%d/%y')\n\n# Create a new column 'week_start_date_str' which represents the date of the start of the week as a string\ndf['week_start_date_str'] = df['week_start_date'].dt.strftime('%m/%d/%y')\n\n# Create a new column 'week_end_date_str' which represents the date of the end of the week as a string\ndf['week_end_date_str'] = df['week_end_date'].dt.strftime('%m/%d/%y')\n\n# Create a new column 'week_start_date_str' which represents the date of the start of the week as a string\ndf['week_start_date_str'] = df['week_start_date'].dt.strftime('%m/%d/%y')\n\n# Create a new column 'week_end_date_str' which represents the date of the end of the week as a string\ndf['week_end_date_str'] = df['week_end_date'].dt.strftime('%m/%d/%y')\n\n# Create a new column 'week_start_date_str' which represents the date of the start of the week as a string\ndf['week_start_date_str'] = df['week_start_date'].dt.strftime('%m/%d/%y')\n\n# Create a new column 'week_end_date_str' which represents the date of the end of the week as a string\ndf['week_end_date_str'] = df['week_end_date'].dt.strftime('%m/%d/%", "metadata": {"problem_id": 74, "library_problem_id": 74, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 73}}
{"id": 75, "code": "\n# Convert date to datetime\ndf['date'] = pd.to_datetime(df['date'])\n\n# Sort the dataframe by date\ndf = df.sort_values('date')\n\n# Create a new column 'week' which represents the week of the year\ndf['week'] = df['date'].dt.to_period('W')\n\n# Group by 'week' and 'ID' and count the number of rows in each group\ngrouped = df.groupby(['week', 'ID']).size().unstack().fillna(0)\n\n# Create a mask where the count is greater than X\nmask = grouped.T > X\n\n# Select the rows where the mask is True\nresult = df[mask.any(axis=1)]\n\n# Convert 'week' back to date\nresult['week'] = result['week'].dt.to_period('W')\n\n# Sort the result by 'week'\nresult = result.sort_values('week')\n\n# Reset the index\nresult = result.reset_index(drop=True)\n", "metadata": {"problem_id": 75, "library_problem_id": 75, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 73}}
{"id": 76, "code": "\ndf['col1'] = df.groupby(df.index // 3).cumcount() / (df.groupby(df.index // 3).cumcount() + 1)\nresult = df\n", "metadata": {"problem_id": 76, "library_problem_id": 76, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 76}}
{"id": 77, "code": "\ndf['col1'] = df.groupby(df.index // 3).cumcount() + 1\nresult = df\n", "metadata": {"problem_id": 77, "library_problem_id": 77, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 76}}
{"id": 78, "code": "\ndf['col1'] = df.groupby(df.index // 4).cumcount() * df['col1'].values\nresult = df['col1'].sum()\n", "metadata": {"problem_id": 78, "library_problem_id": 78, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 76}}
{"id": 79, "code": "\ndf['col1'] = df['col1'].rolling(window=3).mean()\nresult = df\n", "metadata": {"problem_id": 79, "library_problem_id": 79, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 76}}
{"id": 80, "code": "\n# First, we need to create a new column that indicates the group number\ndf['group'] = list(itertools.chain(*[[i]*int(len(df)//3) for i in range(1, 4)]))\n\n# Then, we group by the new column and perform the desired operations\nresult = df.groupby('group')['col1'].apply(lambda x: x.sum() if len(x)==3 else x.mean()).reset_index(drop=True)\n\nprint(result)\n", "metadata": {"problem_id": 80, "library_problem_id": 80, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 76}}
{"id": 81, "code": "\n# First, we need to create a new column that indicates whether the row is the first, second or third\ndf['is_first'] = range(1, len(df) + 1)\ndf['is_second'] = range(1, len(df) + 1)\n\n# Then, we group by 'is_first' and 'is_second' and apply the appropriate functions\nresult = df.groupby(['is_first', 'is_second']).apply(lambda x: x['col1'].sum() if x['is_first'].nunique() == 3 else x['col1'].mean())\n\n# Reset the index\nresult = result.reset_index(drop=True)\n\nprint(result)\n", "metadata": {"problem_id": 81, "library_problem_id": 81, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 76}}
{"id": 82, "code": "\ndf['A'] = df['A'].mask(df['A'] == 0)\ndf['A'] = df['A'].ffill(downcast='infer')\ndf['A'] = df['A'].fillna(method='ffill')\n", "metadata": {"problem_id": 82, "library_problem_id": 82, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 82}}
{"id": 83, "code": "\ndf['A'] = df['A'].mask(df['A'] == 0).ffill(downcast='infer')\n", "metadata": {"problem_id": 83, "library_problem_id": 83, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 82}}
{"id": 84, "code": "\ndf['A'] = df['A'].mask(df['A'] == 0)\ndf['A'] = df['A'].fillna(method='ffill').fillna(method='bfill')\ndf['A'] = df['A'].mask(df['A'] == 0)\ndf['A'] = df['A'].fillna(method='bfill')\ndf", "metadata": {"problem_id": 84, "library_problem_id": 84, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 82}}
{"id": 85, "code": "\n# Split the duration into two columns\ndf[['number', 'time']] = df['duration'].str.split(' ', 1, expand=True)\n\n# Convert the number to integer\ndf['number'] = df['number'].astype(int)\n\n# Create a new column 'time_days' based on the values of 'time' column\ndf['time_days'] = df['time'].replace(['year', 'month', 'week', 'day'], [365, 30, 7, 1])\n\n# Drop the 'time' column\ndf.drop('time', axis=1, inplace=True)\n\ndf\n", "metadata": {"problem_id": 85, "library_problem_id": 85, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 85}}
{"id": 86, "code": "\n# Split the duration column into two separate columns\ndf[['time', 'number']] = df['duration'].str.split(' ', 1, expand=True)\n\n# Convert 'time' column to numeric\ndf['time'] = pd.to_numeric(df['time'])\n\n# Create a dictionary to map the time to the number of days\ntime_to_days = {'year': 365, 'day': 1, 'week': 7, 'month': 30}\n\n# Create a new column 'time_day' based on the 'time' column\ndf['time_day'] = df['time'].map(time_to_days)\n\ndf\n", "metadata": {"problem_id": 86, "library_problem_id": 86, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 85}}
{"id": 87, "code": "\n    df['number'] = df['duration'].str.extract('(\\d+)').astype(int)\n    df['time'] = df['duration'].str.extract('([a-zA-Z]+)').str.strip()\n    df['time_days'] = df['time'].map({'year': 365, 'day': 1, 'week': 7, 'month': 30})\n    return df\n    ### END SOLUTION\n\nprint(f())\n", "metadata": {"problem_id": 87, "library_problem_id": 87, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 85}}
{"id": 88, "code": "\ndf['time'] = df['duration'].str.split(' ', 1).str[0]\ndf['number'] = df['duration'].str.split(' ', 1).str[1]\ndf['time_day'] = df['time'].replace(['year', 'week', 'day', 'month'], [365, 7, 1, 30])\ndf['time_day'] = df['time_day'] * df['number'].astype(int)\ndf\n", "metadata": {"problem_id": 88, "library_problem_id": 88, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 85}}
{"id": 89, "code": "\nresult = [(df1[column] == df2[column]).all() for column in columns_check_list]\nprint(result)\n", "metadata": {"problem_id": 89, "library_problem_id": 89, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 89}}
{"id": 90, "code": "\nresult = [(df1[column] == df2[column]).all() for column in columns_check_list]\nprint(result)\n", "metadata": {"problem_id": 90, "library_problem_id": 90, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 89}}
{"id": 91, "code": "df.index = df.index.set_levels(pd.to_datetime(df.index.levels[1]), level='date')\n", "metadata": {"problem_id": 91, "library_problem_id": 91, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 91}}
{"id": 92, "code": "df.index = df.index.set_levels(pd.to_datetime(df.index.levels[1]), level=1)\n", "metadata": {"problem_id": 92, "library_problem_id": 92, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 91}}
{"id": 93, "code": "\n    df['date'] = pd.to_datetime(df['date'])\n    return df[['date', 'x', 'y']].to_numpy()\n    ### END SOLUTION\n\ndf = pd.DataFrame({'id': ['abc', 'abc', 'abc'],\n                   'date': ['3/1/1994', '9/1/1994', '3/1/1995'],\n                   'x': [100, 90, 80],\n                   'y': [7, 8, 9]})\n\nprint(f(df))\n", "metadata": {"problem_id": 93, "library_problem_id": 93, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 91}}
{"id": 94, "code": "\n    df.index = pd.to_datetime(df.index)\n    df = df.swaplevel(0,1)\n    return df\n    ### END SOLUTION\n", "metadata": {"problem_id": 94, "library_problem_id": 94, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 91}}
{"id": 95, "code": "df = df.melt(id_vars=['Country', 'Variable'], var_name='year', value_name='value')\ndf = df.pivot_table(index=['Country', 'year'], columns='Variable', values='value').reset_index()\ndf.columns.name = None\ndf = df.sort_values(['Country', 'year', 'Variable'])\ndf", "metadata": {"problem_id": 95, "library_problem_id": 95, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 95}}
{"id": 96, "code": "df = df.melt(id_vars=['Country', 'Variable'], var_name='year', value_name='value')\ndf = df.sort_values(['Country', 'year', 'Variable'], ascending=[True, True, False])\ndf = df.pivot_table(index=['Country', 'year'], columns='Variable', values='value').reset_index()\ndf = df.rename_axis(index=['Country', 'year'])\ndf = df.sort_index()\ndf", "metadata": {"problem_id": 96, "library_problem_id": 96, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 95}}
{"id": 97, "code": "df = df.loc[abs(df.iloc[:, 1:].max(axis=1)) < 1]\n", "metadata": {"problem_id": 97, "library_problem_id": 97, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 97}}
{"id": 98, "code": "df = df.loc[abs(df.iloc[:, 1:].max(axis=1)) < 2]\n", "metadata": {"problem_id": 98, "library_problem_id": 98, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 97}}
{"id": 99, "code": "df = df.loc[abs(df.filter(regex='Value_')) > 1]\n", "metadata": {"problem_id": 99, "library_problem_id": 99, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 97}}
{"id": 100, "code": "df['A'] = df['A'].str.replace('&AMP;', '&')\n", "metadata": {"problem_id": 100, "library_problem_id": 100, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 100}}
{"id": 101, "code": "df['A'] = df['A'].str.replace('&LT;', '<')\n", "metadata": {"problem_id": 101, "library_problem_id": 101, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 100}}
{"id": 102, "code": "\n    df.replace(to_replace='&AMP;', \n               pattern='&', \n               inplace=True, \n               regex=True)\n    return df\n    ### END SOLUTION\n\nf(example_df)\n", "metadata": {"problem_id": 102, "library_problem_id": 102, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 100}}
{"id": 103, "code": "df = df.replace({'&AMP;': '&', '&LT;': '<', '&GT;': '>'})\n", "metadata": {"problem_id": 103, "library_problem_id": 103, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 100}}
{"id": 104, "code": "df['A'] = df['A'].str.replace('&AMP;', '&')\n", "metadata": {"problem_id": 104, "library_problem_id": 104, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 100}}
{"id": 105, "code": "\ndef split_name(name):\n    if ' ' in name:\n        return name.split(' ', 1)\n    else:\n        return [name, None]\n\ndf[['first_name', 'last_name']] = df['name'].apply(split_name)\ndf = df.drop(columns=['name'])\n", "metadata": {"problem_id": 105, "library_problem_id": 105, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 105}}
{"id": 106, "code": "\ndef validate_single_space_name(name: str) -> str:\n    pattern = re.compile(r'^.*( ){1}.*$')\n    match_obj = re.match(pattern, name)\n    if match_obj:\n        return name\n    else:\n        return None\n\ndf['name'] = df['name'].apply(validate_single_space_name)\ndf['1_name'] = df['name'].apply(lambda x: x.split(' ')[0] if x is not None else x)\ndf['2_name'] = df['name'].apply(lambda x: x.split(' ')[1] if x is not None else x)\ndf = df.drop(columns=['name'])\ndf = df.rename(columns={'1_name': 'name', '2_name': 'name'})\n", "metadata": {"problem_id": 106, "library_problem_id": 106, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 105}}
{"id": 107, "code": "\ndef split_name(name):\n    if ' ' in name:\n        first_name, *middle_names = name.split(' ')\n        last_name = middle_names[-1] if middle_names else None\n        return first_name, last_name\n    else:\n        return name, None, None\n\ndf[['first name', 'middle_name', 'last_name']] = df['name'].apply(split_name)\ndf = df[['first name', 'middle_name', 'last_name']]\n", "metadata": {"problem_id": 107, "library_problem_id": 107, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 105}}
{"id": 108, "code": "result = df2.merge(df1, on='Timestamp', how='left')\nresult['data'] = result['data'].fillna(method='ffill').astype(int)\nresult = result.sort_values('Timestamp')\n", "metadata": {"problem_id": 108, "library_problem_id": 108, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 108}}
{"id": 109, "code": "result = pd.merge_asof(df1['Timestamp'], df2['Timestamp'], direction='nearest')\nresult = df1.merge(df2, on='Timestamp', how='left')\n", "metadata": {"problem_id": 109, "library_problem_id": 109, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 108}}
{"id": 110, "code": "df['state'] = np.where((df['col2']<=50) & (df['col3']<=50), df['col1'], df['col3'].max())\n", "metadata": {"problem_id": 110, "library_problem_id": 110, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 110}}
{"id": 111, "code": "df['state'] = np.where((df['col2'] > 50) & (df['col3'] > 50), df['col1'], df['col1'] + df['col2'] + df['col3'])\n", "metadata": {"problem_id": 111, "library_problem_id": 111, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 110}}
{"id": 112, "code": "\ndf['Field1'] = pd.to_numeric(df['Field1'], errors='coerce')\ndf['Field1'] = df['Field1'].apply(lambda x: x if pd.isnull(x) else int(x) if x.is_integer() else float(x))\ndf['Field1'] = df['Field1'].apply(lambda x: x if isinstance(x, str) and x.strip() == '' else x)\n\ndf['Field1'] = df['Field1'].apply(lambda x: x if pd.isnull(x) else int(x) if x.is_integer() else float(x))\n\ndf = df[df['Field1'].apply(lambda x: isinstance(x, int))]\n\ndf = df.set_index('ID')\n\ndf['Field1'] = df['Field1'].astype(str)\n\ndf = df['Field1'].tolist()\n\nprint(df)\n", "metadata": {"problem_id": 112, "library_problem_id": 112, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 112}}
{"id": 113, "code": "\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in str(x).split() if str(i).isdigit()])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in str(x).split(',') if str(i).isdigit()])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in str(x).split(' ') if str(i).isdigit()])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in str(x).split('-') if str(i).isdigit()])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [])\ndf['Field1'] = df['Field1'].apply(lambda x: [int(i) for i in x if isinstance(i, int)] if isinstance(x, list) else [", "metadata": {"problem_id": 113, "library_problem_id": 113, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 112}}
{"id": 114, "code": "\n    result = []\n    for i in df['Field1']:\n        if not isinstance(i, int):\n            result.append(i)\n    return result\n    ### END SOLUTION\n\nprint(f())\n", "metadata": {"problem_id": 114, "library_problem_id": 114, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 112}}
{"id": 115, "code": "\ndf['val1'] = df['val1'] / df['val1'].sum() * 100\ndf['val2'] = df['val2'] / df['val2'].sum() * 100\ndf['val3'] = df['val3'] / df['val3'].sum() * 100\ndf['val4'] = df['val4'] / df['val4'].sum() * 100\n\ndf", "metadata": {"problem_id": 115, "library_problem_id": 115, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 115}}
{"id": 116, "code": "\ndf['val1'] = df['val1'] / df['val1'].sum()\ndf['val2'] = df['val2'] / df['val2'].sum()\ndf['val3'] = df['val3'] / df['val3'].sum()\ndf['val4'] = df['val4'] / df['val4'].sum()\n\ndf", "metadata": {"problem_id": 116, "library_problem_id": 116, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 115}}
{"id": 117, "code": "result = df.loc[test]", "metadata": {"problem_id": 117, "library_problem_id": 117, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 117}}
{"id": 118, "code": "result = df.loc[test]", "metadata": {"problem_id": 118, "library_problem_id": 118, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 117}}
{"id": 119, "code": "df.drop(test, inplace=True)\nresult = df\n", "metadata": {"problem_id": 119, "library_problem_id": 119, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 117}}
{"id": 120, "code": " ###\n    return df.loc[test]\n    ### END SOLUTION ###\n\ntest = ['TP3','TP12','TP18', 'TP3']\n\nresult = f(df, test)\nprint(result)\n", "metadata": {"problem_id": 120, "library_problem_id": 120, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 117}}
{"id": 121, "code": "\n# First, calculate the Euclidean distance for each pair of cars\ndf['euclidean_distance'] = ((df['x'] - df['x'].shift())**2 + (df['y'] - df['y'].shift())**2).apply(lambda x: x**0.5)\n\n# Then, find the nearest car for each car at each time\ndf['nearest_neighbour'] = df.groupby('time')['euclidean_distance'].transform(min)\n\n# Finally, calculate the average distance for each time\ndf['average_distance'] = df.groupby('time')['euclidean_distance'].mean()\n\ndf\n", "metadata": {"problem_id": 121, "library_problem_id": 121, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 121}}
{"id": 122, "code": "\n# First, we need to calculate the Euclidean distance for each pair of cars\ndf['euclidean_distance'] = ((df['x'] - df['x'].shift())**2 + (df['y'] - df['y'].shift())**2).apply(lambda x: x**0.5)\n\n# Then, we group by 'time' and 'car', and find the car with the maximum distance\ndf['farmost_neighbour'] = df.groupby('time')['euclidean_distance'].transform('idxmin')\n\n# Finally, we calculate the average distance for each time point\ndf['average_distance'] = df.groupby('time')['euclidean_distance'].mean()\n\ndf\n", "metadata": {"problem_id": 122, "library_problem_id": 122, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 121}}
{"id": 123, "code": "\ndf['keywords_all'] = df.apply(lambda row: ','.join(row.dropna().astype(str).values), axis=1)\n", "metadata": {"problem_id": 123, "library_problem_id": 123, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 123}}
{"id": 124, "code": "\ndf['keywords_all'] = df.apply(lambda row: '-'.join(row.dropna().astype(str)), axis=1)\n", "metadata": {"problem_id": 124, "library_problem_id": 124, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 123}}
{"id": 125, "code": "\ndf['keywords_all'] = df[['keywords_0', 'keywords_1', 'keywords_2', 'keywords_3']].apply(lambda x: '-'.join(x.dropna().astype(str)), axis=1)\ndf\n", "metadata": {"problem_id": 125, "library_problem_id": 125, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 123}}
{"id": 126, "code": "\ndf['keywords_all'] = df[['keywords_0', 'keywords_1', 'keywords_2', 'keywords_3']].apply(lambda x: '-'.join(x.dropna().values[::-1]), axis=1)\ndf\n", "metadata": {"problem_id": 126, "library_problem_id": 126, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 123}}
{"id": 127, "code": "\n# Select 20% of rows\nsample_df = df.sample(frac=0.2, random_state=0)\n\n# Change Quantity to zero\nsample_df['Quantity'] = 0\n\n# Keep the indexes of the altered rows\nsample_df.index = df.index[~df.index.isin(sample_df.index)]\n\ndf = df.drop(df.index[~df.index.isin(sample_df.index)])\n\ndf = pd.concat([df, sample_df])\n", "metadata": {"problem_id": 127, "library_problem_id": 127, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 127}}
{"id": 128, "code": "\n# Select 20% of rows\nsample_df = df.sample(frac=0.2, random_state=0)\n\n# Change the value of the ProductId column to zero\nsample_df['ProductId'] = 0\n\n# Keep the indexes of the altered rows\nsample_df.index = df.index[~df.index.isin(sample_df.index)]\n\ndf = df.drop(df.index[~df.index.isin(sample_df.index)])\n\ndf = pd.concat([df, sample_df])\n", "metadata": {"problem_id": 128, "library_problem_id": 128, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 127}}
{"id": 129, "code": "\n# First, we find the number of rows for each user\nuser_counts = df['UserId'].value_counts()\n\n# Then, we find the number of rows to select for each user\nnum_rows = user_counts * 0.2\n\n# We select the rows for each user\nselected_rows = df.groupby('UserId').apply(lambda x: x.sample(num_rows, random_state=0))\n\n# We set the Quantity to 0\ndf.loc[selected_rows.index, 'Quantity'] = 0\n\n# We keep the original indexes\ndf.loc[selected_rows.index, 'UserId'] = selected_rows.index\n\ndf\n", "metadata": {"problem_id": 129, "library_problem_id": 129, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 127}}
{"id": 130, "code": "\n# First, we need to find the first duplicate row\nfirst_duplicate = df.duplicated(subset=['col1','col2'], keep=False)\n\n# Then, we need to get the index of the first duplicate row\nindex_first_duplicate = first_duplicate.idxmax()\n\n# We create a new column 'index_original' referring to the index of the first duplicate row\ndf['index_original'] = index_first_duplicate\n\n# Finally, we get the duplicates rows\nresult = df.loc[first_duplicate == True]\n\nprint(result)\n", "metadata": {"problem_id": 130, "library_problem_id": 130, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 130}}
{"id": 131, "code": "\n# First, we need to find the duplicates\nduplicates = df.duplicated(subset=['col1','col2'], keep=False)\n\n# Then, we need to find the last occurrence of each duplicate\nlast_occurrence = duplicates.groupby(level=0).transform(max)\n\n# Finally, we select the rows that are duplicates and their last occurrence\nresult = df.loc[duplicates & last_occurrence]\n\n# Add the original index\nresult['index_original'] = duplicates.groupby(level=0).cumcount()\n\nprint(result)\n", "metadata": {"problem_id": 131, "library_problem_id": 131, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 130}}
{"id": 132, "code": "\n    duplicate_bool = df.duplicated(subset=['col1','col2'], keep='first')\n    duplicate = df.loc[duplicate_bool == True]\n    duplicate['index_original'] = duplicate_bool.apply(lambda x: df.index[x] if x else None)\n    return duplicate\n    ### END SOLUTION\n\nprint(f())\n", "metadata": {"problem_id": 132, "library_problem_id": 132, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 130}}
{"id": 133, "code": "\n# First, we need to find the first duplicate in each column\nduplicates = df.duplicated(subset=['col1','col2', '3col'], keep=False)\n\n# Then, we need to find the index of the first duplicate in each column\nfirst_duplicates = duplicates.groupby(['col1','col2', '3col']).transform(min) == duplicates\n\n# Finally, we need to add a new column with the index of the first duplicate\ndf['index_original'] = duplicates.groupby(['col1','col2', '3col']).transform(min)\n\nresult = df[first_duplicates]\n", "metadata": {"problem_id": 133, "library_problem_id": 133, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 130}}
{"id": 134, "code": "\n# First, we need to find the last occurrence of each duplicate\nlast_occurrence = df.groupby(['col1','col2'])['val'].transform('last')\n\n# Then, we can merge this with the original dataframe\ndf = df.drop(columns=['val'])\ndf = pd.concat([df, last_occurrence.rename('index_original')], axis=1)\n\n# Finally, we can drop duplicates\ndf = df.drop_duplicates(subset=['col1','col2'], keep='last')\n\nresult = df\n", "metadata": {"problem_id": 134, "library_problem_id": 134, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 130}}
{"id": 135, "code": "\n# First, find the maximum count for each group\nmax_counts = df.groupby(['Sp', 'Mt'])['count'].max().reset_index()\n\n# Then, join this with the original DataFrame to get the rows with the maximum count\nresult = df.join(max_counts.set_index(['Sp', 'Mt'])['count'], on=['Sp', 'Mt']).loc[df['count'] == max_counts['count']]\n\n# Reset the index\nresult = result.reset_index(drop=True)\n", "metadata": {"problem_id": 135, "library_problem_id": 135, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 135}}
{"id": 136, "code": "\n# First, find the maximum count for each group\nmax_counts = df.groupby(['Sp','Mt'])['count'].max().reset_index()\n\n# Then, join the original dataframe with the maximum counts\nresult = df.join(max_counts.set_index(['Sp','Mt'])['count'], on=['Sp','Mt'])\n\n# Finally, filter out the rows where count is not equal to the maximum count\nresult = result[result['count'] == result['count'].max()]\n\nprint(result)\n", "metadata": {"problem_id": 136, "library_problem_id": 136, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 135}}
{"id": 137, "code": "\n# First, find the minimum count for each group\nmin_counts = df.groupby(['Sp', 'Mt'])['count'].min().reset_index()\n\n# Then, join the original dataframe with the minimum counts\nresult = df.join(min_counts.set_index(['Sp', 'Mt'])['count'], on=['Sp', 'Mt']).drop('count', 1)\n\n# Finally, filter the result to only include rows where count is equal to the minimum count\nresult = result[result['count'] == min_counts['count']].reset_index(drop=True)\n\nprint(result)\n", "metadata": {"problem_id": 137, "library_problem_id": 137, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 135}}
{"id": 138, "code": "\n# First, find the maximum count for each group\nmax_counts = df.groupby(['Sp','Value'])['count'].max().reset_index()\n\n# Then, join the original dataframe with the maximum counts\nresult = df.join(max_counts.set_index(['Sp','Value'])['count'], on=['Sp','Value'])\n\n# Finally, filter out the rows where count is not equal to the maximum count\nresult = result[result['count'] == result['count'].expanding().max()]\n\n# Reset the index\nresult = result.reset_index(drop=True)\n", "metadata": {"problem_id": 138, "library_problem_id": 138, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 135}}
{"id": 139, "code": "result = df[df['Category'].isin(filter_list)]", "metadata": {"problem_id": 139, "library_problem_id": 139, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 139}}
{"id": 140, "code": "result = df[~df['Category'].isin(filter_list)]", "metadata": {"problem_id": 140, "library_problem_id": 140, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 139}}
{"id": 141, "code": "\n# Create a list of tuples where each tuple contains the first and second column level\n# and the third column level\nvalue_vars = [('A', 'B', 'E'),\n              ('A', 'B', 'F'),\n              ('A', 'C', 'G'),\n              ('A', 'C', 'H'),\n              ('A', 'D', 'I'),\n              ('A', 'D', 'J')]\n\n# Use pd.melt with the 'value_vars' argument\nresult = pd.melt(df, value_vars=value_vars)\n", "metadata": {"problem_id": 141, "library_problem_id": 141, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 141}}
{"id": 142, "code": "\n# Create a list of tuples where each tuple contains the first, second and third column level\ntuples = [(df.columns[i][0], df.columns[i][1], df.columns[i][2]) for i in range(len(df.columns))]\n\n# Use pd.melt to melt the dataframe\nresult = pd.melt(df, id_vars=tuples, value_vars=tuples)\n\n# Rename the columns\nresult.columns = ['variable', 'value']\n\n# Add the original column names\nresult['column'] = df.columns.to_list()\n\n# Sort the result by variable and value\nresult = result.sort_values(['variable', 'value'])\n\n# Reset the index\nresult = result.reset_index(drop=True)\n\nprint(result)\n", "metadata": {"problem_id": 142, "library_problem_id": 142, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 141}}
{"id": 143, "code": "df['cumsum'] = df.groupby('id')['val'].cumsum()\ndf\n", "metadata": {"problem_id": 143, "library_problem_id": 143, "library": "Pandas", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 143}}
{"id": 144, "code": "df['cumsum'] = df.groupby('id')['val'].cumsum()\n", "metadata": {"problem_id": 144, "library_problem_id": 144, "library": "Pandas", "test_case_cnt": 3, "perturbation_type": "Surface", "perturbation_origin_id": 143}}
{"id": 145, "code": "df['cumsum'] = df.groupby('id')['val'].cumsum()\ndf", "metadata": {"problem_id": 145, "library_problem_id": 145, "library": "Pandas", "test_case_cnt": 3, "perturbation_type": "Surface", "perturbation_origin_id": 143}}
{"id": 146, "code": "df['cummax'] = df.groupby('id')['val'].expanding(max).max()\ndf", "metadata": {"problem_id": 146, "library_problem_id": 146, "library": "Pandas", "test_case_cnt": 3, "perturbation_type": "Semantic", "perturbation_origin_id": 143}}
{"id": 147, "code": "df['cumsum'] = df.groupby('id')['val'].cumsum()\ndf['cumsum'] = df['cumsum'].where(df['val'] >= 0, 0)\ndf", "metadata": {"problem_id": 147, "library_problem_id": 147, "library": "Pandas", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 143}}
{"id": 148, "code": "\nresult = df.groupby('l')['v'].apply(lambda x: x.sum() if x.sum() != x.count() else np.nan).reset_index(name='v')\n", "metadata": {"problem_id": 148, "library_problem_id": 148, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 148}}
{"id": 149, "code": "\nresult = df.groupby('r')['v'].apply(lambda x: x.sum() if x.sum() != x.count() else np.nan).reset_index(name='v')\n", "metadata": {"problem_id": 149, "library_problem_id": 149, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 148}}
{"id": 150, "code": "\nresult = df.groupby('l')['v'].apply(lambda x: x.sum() if x.sum() != x.size else np.nan).reset_index(name='v')\n", "metadata": {"problem_id": 150, "library_problem_id": 150, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 148}}
{"id": 151, "code": "\ndef relationship(column1, column2):\n    if len(column1.unique()) == 1:\n        return 'one-to-many'\n    elif len(column2.unique()) == 1:\n        return 'many-to-one'\n    else:\n        return 'many-to-many'\n\nresult = [f'{column1} {column2} {relationship(column1, column2)}' for column1, column2 in zip(df.columns, df.columns)]\n", "metadata": {"problem_id": 151, "library_problem_id": 151, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 151}}
{"id": 152, "code": "\ndef relationship(col1, col2):\n    if len(df[col1]) == len(df[col2]):\n        return 'one-2-many'\n    elif len(df[col1]) < len(df[col2]):\n        return 'one-2-one'\n    else:\n        return 'many-2-many'\n\nresult = [f'{col1} {col2} {relationship(col1, col2)}' for col1 in df.columns for col2 in df.columns]\n", "metadata": {"problem_id": 152, "library_problem_id": 152, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 151}}
{"id": 153, "code": "\ndef relationship(x, y):\n    if len(x.unique()) == 1:\n        return 'one-to-one'\n    elif len(x.unique()) == len(y.unique()):\n        return 'one-to-many'\n    elif len(y.unique()) == 1:\n        return 'many-to-one'\n    else:\n        return 'many-to-many'\n\n\nresult = df.apply(lambda x: relationship(x, df[x.name]))\nresult.name = df.columns\nresult.index = df.columns\nresult", "metadata": {"problem_id": 153, "library_problem_id": 153, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 151}}
{"id": 154, "code": "\ndef relationship(x, y):\n    if len(x.unique()) == 1:\n        return 'one-2-one' if len(y.unique()) == 1 else 'one-2-many'\n    elif len(y.unique()) == 1:\n        return 'one-2-many' if len(x.unique()) == 1 else 'many-2-one'\n    else:\n        return 'many-2-many'\n\n\nresult = df.applymap(relationship)\nresult.index = ['Column1', 'Column2', 'Column3', 'Column4', 'Column5']\nresult.columns = ['Column1', 'Column2', 'Column3', 'Column4', 'Column5']\n\nprint(result)\n", "metadata": {"problem_id": 154, "library_problem_id": 154, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 151}}
{"id": 155, "code": "\n# get the index of unique values, based on firstname, lastname, email\nuniq_indx = (df.dropna(subset=['firstname', 'lastname', 'email'])\n.applymap(lambda s:s.lower() if type(s) == str else s)\n.applymap(lambda x: x.replace(\" \", \"\") if type(x)==str else x)\n.drop_duplicates(subset=['firstname', 'lastname', 'email'], keep='first')).index\n\n# save unique records\ndfiban_uniq = df.loc[uniq_indx]\n\n# sort by bank account\ndfiban_uniq = dfiban_uniq.sort_values(by='bank', ascending=False)\n\nresult = dfiban_uniq\nresult\n", "metadata": {"problem_id": 155, "library_problem_id": 155, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 155}}
{"id": 156, "code": "\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")\n    print(\"Hello, World\")", "metadata": {"problem_id": 156, "library_problem_id": 156, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 156}}
{"id": 157, "code": "\n# First, create a new column 'Family' that is True if 'SibSp' or 'Parch' is greater than 0\ndf['Family'] = df['SibSp'] > 0 | df['Parch'] > 0\n\n# Then, group by 'Survived' and 'Family', and calculate the mean of 'Survived'\nresult = df.groupby(['Survived', 'Family'])['Survived'].mean()\n", "metadata": {"problem_id": 157, "library_problem_id": 157, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 157}}
{"id": 158, "code": "\n# First, create a new column that indicates whether the passenger has family\ndf['HasFamily'] = (df['Survived'] > 0) | (df['Parch'] > 0)\n\n# Then, group by the new column and calculate the mean\nresult = df.groupby('HasFamily')['SibSp'].mean()\n\nprint(result)\n", "metadata": {"problem_id": 158, "library_problem_id": 158, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 157}}
{"id": 159, "code": "\nconditions = [(df['SibSp'] == 1) & (df['Parch'] == 1),\n              (df['SibSp'] == 0) & (df['Parch'] == 0),\n              (df['SibSp'] == 0) & (df['Parch'] == 1),\n              (df['SibSp'] == 1) & (df['Parch'] == 0)]\nchoices = ['Has Family', 'No Family', 'New Family', 'Old Family']\n\nresult = pd.Series(conditions, index=choices).groupby(df['Survived']).mean()\n", "metadata": {"problem_id": 159, "library_problem_id": 159, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 157}}
{"id": 160, "code": "\ndf = df.groupby('cokey').apply(lambda x: x.sort_values('A') if 'A' in x.columns else x).reset_index(drop=True)\nresult = df\n", "metadata": {"problem_id": 160, "library_problem_id": 160, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 160}}
{"id": 161, "code": "\ndf = df.groupby('cokey').apply(lambda x: x.sort_values('A') if x.shape[0] > 1 else x).reset_index(drop=True)\ndf = df.sort_values('cokey').reset_index(drop=True)\ndf = df.set_index('cokey')\nresult = df\n", "metadata": {"problem_id": 161, "library_problem_id": 161, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 160}}
{"id": 162, "code": "df.columns = pd.MultiIndex.from_tuples(df.columns.to_list(), names=['Caps', 'Lower'])", "metadata": {"problem_id": 162, "library_problem_id": 162, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 162}}
{"id": 163, "code": "df.columns = pd.MultiIndex.from_tuples(df.columns, names=['Caps', 'Middle', 'Lower'])", "metadata": {"problem_id": 163, "library_problem_id": 163, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 162}}
{"id": 164, "code": "df.columns = pd.MultiIndex.from_tuples(df.columns.to_series().apply(lambda x: (x[0], x[1], int(x[2]))))", "metadata": {"problem_id": 164, "library_problem_id": 164, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 162}}
{"id": 165, "code": "df = pd.DataFrame({'birdType': someTuple[0], 'birdCount': someTuple[1]})\nresult = df\n", "metadata": {"problem_id": 165, "library_problem_id": 165, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 165}}
{"id": 166, "code": "\ndf['mean'] = df.groupby('a')['b'].transform('mean')\ndf['std'] = df.groupby('a')['b'].transform(np.std)\ndf = df[['mean', 'std']]\nresult = df\n", "metadata": {"problem_id": 166, "library_problem_id": 166, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 166}}
{"id": 167, "code": "\ndf['mean'] = df.groupby('b')['a'].transform('mean')\ndf['std'] = df.groupby('b')['a'].transform(np.std)\ndf = df[['mean', 'std']]\nresult = df\n", "metadata": {"problem_id": 167, "library_problem_id": 167, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 166}}
{"id": 168, "code": "\n# First, we need to calculate the softmax and min-max normalization\ndf['softmax'] = df.groupby('a')['b'].transform(lambda x: x / x.sum())\ndf['min-max'] = df.groupby('a')['b'].transform(lambda x: x - x.min() + 1) / (x.max() - x.min())\n\n# Then, we need to reset the index\ndf = df.reset_index(drop=True)\n\ndf\n", "metadata": {"problem_id": 168, "library_problem_id": 168, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 166}}
{"id": 169, "code": "\n# First, we need to find the sum of each row and column\nrow_sum = df.sum(axis=1)\ncol_sum = df.sum(axis=0)\n\n# Then, we need to find the indices where the sum is 0\nindices = (row_sum == 0) | (col_sum == 0)\n\n# Finally, we can remove the rows and columns where the sum is 0\nresult = df[~indices]\n", "metadata": {"problem_id": 169, "library_problem_id": 169, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 169}}
{"id": 170, "code": "\n# First, we need to find the sum of each row and column\nrow_sum = df.sum(axis=1)\ncol_sum = df.sum(axis=0)\n\n# Then, we create a mask that will be used to filter out the rows and columns with sum of 0\nmask = row_sum == 0 | col_sum == 0\n\n# Finally, we apply the mask to the original dataframe\nresult = df[~mask]\n\nprint(result)\n", "metadata": {"problem_id": 170, "library_problem_id": 170, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 169}}
{"id": 171, "code": "\n# First, find the maximum value in each row\nmax_values = df.max(axis=1)\n\n# Then, create a mask where the maximum value is not equal to the maximum value itself\nmask = df.apply(lambda x: x != max_values.values[0], axis=1)\n\n# Finally, apply the mask to the original dataframe\nresult = df[mask]\n", "metadata": {"problem_id": 171, "library_problem_id": 171, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 169}}
{"id": 172, "code": "\n# First, find the maximum value in each row\nmax_values = df.max(axis=1)\n\n# Then, replace the maximum values with 0\ndf.replace(max_values, 0, inplace=True)\n\nresult = df\n", "metadata": {"problem_id": 172, "library_problem_id": 172, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 169}}
{"id": 173, "code": "result = s.sort_values(ascending=True)\nresult", "metadata": {"problem_id": 173, "library_problem_id": 173, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 173}}
{"id": 174, "code": "df = s.reset_index().sort_values(by=['index', 0]).set_index('index')\n", "metadata": {"problem_id": 174, "library_problem_id": 174, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 173}}
{"id": 175, "code": "\ndf['A'] = pd.to_numeric(df['A'], errors='coerce')\ndf = df[df['A'].notna()]\nresult = df\n", "metadata": {"problem_id": 175, "library_problem_id": 175, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 175}}
{"id": 176, "code": "result = df.loc[df['A'].astype(str).astype('category').cat.codes == df['A']]\n", "metadata": {"problem_id": 176, "library_problem_id": 176, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 175}}
{"id": 177, "code": "\n# First, find the maximum count for each group\nmax_counts = df.groupby(['Sp', 'Mt'])['count'].max().reset_index()\n\n# Then, join this with the original dataframe to get the rows with the maximum count\nresult = df.join(max_counts.set_index(['Sp', 'Mt'])['count'], on=['Sp', 'Mt']).loc[df['count'] == max_counts['count']]\n\n# Reset the index\nresult = result.reset_index(drop=True)\n", "metadata": {"problem_id": 177, "library_problem_id": 177, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 177}}
{"id": 178, "code": "\n# First, find the maximum count for each group\nmax_counts = df.groupby(['Sp','Mt'])['count'].max().reset_index()\n\n# Then, join the original dataframe with the maximum counts\nresult = df.join(max_counts.set_index(['Sp','Mt'])['count'], on=['Sp','Mt'])\n\n# Finally, filter the rows where count is equal to the maximum count\nresult = result[result['count'] == result['count'].max()]\n\nprint(result)\n", "metadata": {"problem_id": 178, "library_problem_id": 178, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 177}}
{"id": 179, "code": "\n# First, find the minimum count for each group\nmin_counts = df.groupby(['Sp', 'Mt'])['count'].min().reset_index()\n\n# Then, join the original dataframe with the minimum counts\nresult = df.join(min_counts.set_index(['Sp', 'Mt'])['count'], on=['Sp', 'Mt']).drop('count', 1)\n\n# Finally, filter the result to only include rows where count is equal to the minimum count\nresult = result[result['count'] == min_counts['count']].reset_index(drop=True)\n\nprint(result)\n", "metadata": {"problem_id": 179, "library_problem_id": 179, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 177}}
{"id": 180, "code": "\n# First, find the maximum count for each group\nmax_counts = df.groupby(['Sp','Value'])['count'].max().reset_index()\n\n# Then, join the original dataframe with the maximum counts\nresult = df.join(max_counts.set_index(['Sp','Value'])['count'], on=['Sp','Value'])\n\n# Finally, filter out the rows where count is not equal to the maximum count\nresult = result[result['count'] == result['count'].expanding().max()]\n\n# Reset the index\nresult = result.reset_index(drop=True)\n", "metadata": {"problem_id": 180, "library_problem_id": 180, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 177}}
{"id": 181, "code": "df['Date'] = df['Member'].map(dict)\ndf = df.drop('Member', axis=1)\n", "metadata": {"problem_id": 181, "library_problem_id": 181, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 181}}
{"id": 182, "code": "df['Date'] = df['Member'].map(dict)\ndf['Date'] = pd.to_datetime(df['Date'])\ndf = df.fillna(pd.to_datetime('17/8/1926'))\ndf['Date'] = df['Date'].dt.strftime('%d/%m/%Y')\n", "metadata": {"problem_id": 182, "library_problem_id": 182, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 181}}
{"id": 183, "code": "\n    df['Date'] = df['Member'].map(dict)\n    ### END SOLUTION\n    return df\n\nf(example_dict, example_df)\n", "metadata": {"problem_id": 183, "library_problem_id": 183, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 181}}
{"id": 184, "code": "\ndf['Date'] = df['Member'].map(dict).fillna('17/8/1926')\ndf['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%Y').dt.strftime('%d-%b-%Y')\ndf = df.drop(columns=['Member'])\ndf = df.rename(columns={'Date': 'Group'})\n", "metadata": {"problem_id": 184, "library_problem_id": 184, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 181}}
{"id": 185, "code": "df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%y')\ndf['Count_d'] = df.groupby([df['Date'].dt.year, df['Date'].dt.month]).Date.transform('count')\ndf['Count_m'] = df.groupby([df['Date'].dt.year, df['Date'].dt.month]).Date.transform('count')\ndf['Count_y'] = df.groupby([df['Date'].dt.year]).Date.transform('count')\ndf = df.sort_values(by=['Date'])\ndf\n", "metadata": {"problem_id": 185, "library_problem_id": 185, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 185}}
{"id": 186, "code": "df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%y')\ndf['Count_d'] = df.groupby(['Date','Val'])['Date'].transform('count')\ndf['Count_m'] = df.groupby([df['Date'].dt.year, df['Date'].dt.month, 'Val'])['Date'].transform('count')\ndf['Count_y'] = df.groupby([df['Date'].dt.year, 'Val'])['Date'].transform('count')\ndf['Count_Val'] = df.groupby(['Date','Val'])['Date'].transform('count')\ndf\n", "metadata": {"problem_id": 186, "library_problem_id": 186, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 185}}
{"id": 187, "code": "df['Date'] = pd.to_datetime(df['Date'], format='%d/%m/%y')\n\ndf['Count_d'] = df.groupby(['Date', 'Val']).Date.transform('count')\ndf['Count_m'] = df.groupby([df['Date'].dt.year, df['Date'].dt.month, 'Val']).Date.transform('count')\ndf['Count_y'] = df.groupby([df['Date'].dt.year, 'Val']).Date.transform('count')\ndf['Count_w'] = df.groupby([df['Date'].dt.week, 'Val']).Date.transform('count')\ndf['Count_Val'] = df.groupby(['Date', 'Val']).Date.transform('count')\n\ndf\n", "metadata": {"problem_id": 187, "library_problem_id": 187, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 185}}
{"id": 188, "code": "\n# First, we need to convert the 'Date' column to datetime\ndf['Date'] = pd.to_datetime(df['Date'])\n\n# Then, we group by 'Date' and 'B' and count non-zero values\nresult1 = df.groupby('Date')['B'].apply(lambda x: x.sum() - x.count()).reset_index(name='B')\n\n# For 'C', we do the same but with 'C'\nresult2 = df.groupby('Date')['C'].apply(lambda x: x.sum() - x.count()).reset_index(name='C')\n", "metadata": {"problem_id": 188, "library_problem_id": 188, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 188}}
{"id": 189, "code": "\ndf['Date'] = pd.to_datetime(df['Date'])\ndf.set_index('Date', inplace=True)\n\nresult1 = df.resample('D').apply(lambda x: pd.Series({'B': x.B.sum(), 'C': x.C.sum()}))\nresult1 = result1[result1['B'] % 2 == 0]\n\nresult2 = df.resample('D').apply(lambda x: pd.Series({'B': x.B.sum(), 'C': x.C.sum()}))\nresult2 = result2[result2['B'] % 2 != 0]\n", "metadata": {"problem_id": 189, "library_problem_id": 189, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 188}}
{"id": 190, "code": "\nresult = pd.pivot_table(df, values=['D','E'], index=['A','B'], aggfunc={'D':np.sum, 'E':np.mean})\n", "metadata": {"problem_id": 190, "library_problem_id": 190, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 190}}
{"id": 191, "code": "result = pd.pivot_table(df, values=['D','E'], index=['B'], aggfunc={'D':np.sum, 'E':np.mean})\n", "metadata": {"problem_id": 191, "library_problem_id": 191, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 190}}
{"id": 192, "code": "\nresult = pd.pivot_table(df, values=['D','E'], rows=['B'], aggfunc={'D':np.sum, 'E':np.mean})", "metadata": {"problem_id": 192, "library_problem_id": 192, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 190}}
{"id": 193, "code": "\nresult = pd.pivot_table(df, values=['D','E'], index=['A','B'], aggfunc={'D':np.max, 'E':np.min})\n", "metadata": {"problem_id": 193, "library_problem_id": 193, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 190}}
{"id": 194, "code": "\nimport dask.dataframe as dd\n\nddf = dd.from_pandas(df, npartitions=2)\n\ndef split_to_rows(df):\n    return df.assign(var2=df['var2'].str.split(','))\n\nresult = dd.from_pandas(df).map_partitions(split_to_rows).compute()\n", "metadata": {"problem_id": 194, "library_problem_id": 194, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 194}}
{"id": 195, "code": "\nimport dask.dataframe as dd\n\nddf = dd.from_pandas(df, npartitions=2)\n\ndef split_to_rows(df):\n    return df.assign(var2=df['var2'].str.split(','))\n\nresult = dd.from_pandas(df).map_partitions(split_to_rows).compute()\n", "metadata": {"problem_id": 195, "library_problem_id": 195, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 194}}
{"id": 196, "code": "\ndf_split = df['var2'].str.split(expand=True).add_prefix('var2_')\nresult = pd.concat([df.drop('var2', axis=1), df_split], axis=1)\n", "metadata": {"problem_id": 196, "library_problem_id": 196, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 194}}
{"id": 197, "code": "\ndef count_special_char(string):\n    special_char = 0\n    for i in range(len(string)):\n        if not string[i].isalpha():\n            special_char = special_char + 1\n    return special_char\n\ndf[\"new\"] = df[\"str\"].apply(count_special_char)\nprint(df)\n", "metadata": {"problem_id": 197, "library_problem_id": 197, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 197}}
{"id": 198, "code": "\ndef count_special_char(string):\n    special_char = 0\n    for i in range(len(string)):\n        if not string[i].isalpha():\n            special_char = special_char + 1\n    return special_char\n\ndf[\"new\"] = df[\"str\"].apply(count_special_char)\nprint(df)\n", "metadata": {"problem_id": 198, "library_problem_id": 198, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 197}}
{"id": 199, "code": "df[['fips', 'row']] = df['row'].str.split(' ', 1, expand=True)\ndf = df.drop(columns=['row'])\ndf = df.rename(columns={'fips': 'row'})\n", "metadata": {"problem_id": 199, "library_problem_id": 199, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 199}}
{"id": 200, "code": "df[['fips', 'row']] = df['row'].str.split(' ', 1, expand=True)\ndf = df.rename(columns={'row': 'fips'})\n", "metadata": {"problem_id": 200, "library_problem_id": 200, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 199}}
{"id": 201, "code": "df[['fips', 'medi']] = df['row'].str.split(' ', 1, expand=True)\ndf", "metadata": {"problem_id": 201, "library_problem_id": 201, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 199}}
{"id": 202, "code": "\ndf = df.set_index('Name').apply(lambda x: x.cumsum() / (1 + x.ne(0).cumsum()) * x.ne(0).cumsum(), axis=1)\ndf = df.reset_index()\ndf", "metadata": {"problem_id": 202, "library_problem_id": 202, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 202}}
{"id": 203, "code": "\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(-1, np.nan)\ndf = df.fillna(df.cumsum() / (np.arange(len(df.columns))[:, None] + 1))\ndf = df.replace(np.nan, 0)\ndf = df.set_index('Name').replace(np.nan, 0)\n", "metadata": {"problem_id": 203, "library_problem_id": 203, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 202}}
{"id": 204, "code": "\n    df = df.set_index('Name')\n    df = df.replace(0, np.nan)\n    df = df.replace(np.nan, 0)\n    df = df.fillna(df.mean(axis=1))\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.replace(np.nan, 0)\n    df = df.", "metadata": {"problem_id": 204, "library_problem_id": 204, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 202}}
{"id": 205, "code": "\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).replace(np.nan, 0)\ndf = df.add(1).sub(1).round(2)\ndf = df.set_index('Name').replace(0, np.nan)\ndf = df.replace(np.nan, 0).cumsum().div(np.arange(1, 7)).", "metadata": {"problem_id": 205, "library_problem_id": 205, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 202}}
{"id": 206, "code": "df['label'] = (df['Close'].diff() > 0).astype(int)\ndf.loc[0] = [df.loc[0, 'DateTime'], df.loc[0, 'Close'], 1]\ndf\n", "metadata": {"problem_id": 206, "library_problem_id": 206, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 206}}
{"id": 207, "code": "\ndf['label'] = df['Close'].diff().apply(lambda x: 1 if x > 0 else (-1 if x < 0 else 0))\ndf.loc[0, 'label'] = 1\ndf\n", "metadata": {"problem_id": 207, "library_problem_id": 207, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 206}}
{"id": 208, "code": "df['label'] = df['Close'].diff().apply(lambda x: -1 if x < 0 else (1 if x > 0 else 0))\ndf['DateTime'] = df['DateTime'].dt.strftime('%d-%b-%Y')\ndf", "metadata": {"problem_id": 208, "library_problem_id": 208, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 206}}
{"id": 209, "code": "df['Duration'] = pd.to_timedelta(df['departure_time'] - df['arrival_time'])\ndf['Duration'] = df['Duration'].dt.days.astype(str) + ' days ' + df['Duration'].dt.seconds.astype(str).str.zfill(2)\ndf\n", "metadata": {"problem_id": 209, "library_problem_id": 209, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 209}}
{"id": 210, "code": "df['Duration'] = pd.to_timedelta(df['departure_time']) - pd.to_timedelta(df['arrival_time'])\ndf['Duration'] = df['Duration'].dt.total_seconds()\ndf\n", "metadata": {"problem_id": 210, "library_problem_id": 210, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 209}}
{"id": 211, "code": "\ndf['arrival_time'] = pd.to_datetime(df['arrival_time'])\ndf['departure_time'] = pd.to_datetime(df['departure_time'])\ndf['Duration'] = df.departure_time - df.arrival_time\ndf['Duration'] = df['Duration'].dt.total_seconds()\ndf\n", "metadata": {"problem_id": 211, "library_problem_id": 211, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 209}}
{"id": 212, "code": "result = df[df['key2'] == 'one'].groupby('key1').size().reset_index(name='count')", "metadata": {"problem_id": 212, "library_problem_id": 212, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 212}}
{"id": 213, "code": "result = df[df['key2'] == 'two'].groupby('key1').size().reset_index(name='count')", "metadata": {"problem_id": 213, "library_problem_id": 213, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 212}}
{"id": 214, "code": "result = df[df['key2'].str.endswith('e')].groupby('key1').size()\n", "metadata": {"problem_id": 214, "library_problem_id": 214, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 212}}
{"id": 215, "code": "max_result = df.idxmax()\nmin_result = df.idxmin()\n", "metadata": {"problem_id": 215, "library_problem_id": 215, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 215}}
{"id": 216, "code": "\nmode_result = df.groupby(df.index)['value'].transform('mode')\nmedian_result = df.groupby(df.index)['value'].transform('median')\n", "metadata": {"problem_id": 216, "library_problem_id": 216, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 215}}
{"id": 217, "code": "\nresult = df[df['closing_price'].between(99, 101)]\n", "metadata": {"problem_id": 217, "library_problem_id": 217, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 217}}
{"id": 218, "code": "\nresult = df[df['closing_price'].between(99, 101)]\n", "metadata": {"problem_id": 218, "library_problem_id": 218, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 217}}
{"id": 219, "code": "df1 = df.groupby(\"item\")[\"diff\", \"otherstuff\"].min().reset_index()\nresult = df.merge(df1, on=\"item\", how=\"left\")\n", "metadata": {"problem_id": 219, "library_problem_id": 219, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 219}}
{"id": 220, "code": "df['SOURCE_NAME'] = df['SOURCE_NAME'].str.split('_').str[0]\n", "metadata": {"problem_id": 220, "library_problem_id": 220, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 220}}
{"id": 221, "code": "df['SOURCE_NAME'] = df['SOURCE_NAME'].str.split('_').str[0]\n", "metadata": {"problem_id": 221, "library_problem_id": 221, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 220}}
{"id": 222, "code": "\n    df['SOURCE_NAME'] = df['SOURCE_NAME'].str.split('_').str[0].where(df['SOURCE_NAME'].str.contains('_'), df['SOURCE_NAME'])\n    return df\n    ### END SOLUTION\n\nf(example_df)\n", "metadata": {"problem_id": 222, "library_problem_id": 222, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 220}}
{"id": 223, "code": "\n# First, we need to find the number of NaN values in each row\nnum_nan = df['Column_x'].isnull().sum()\n\n# Then, we calculate the number of rows to be replaced\nnum_repl = int(0.5 * num_nan)\n\n# We create a mask for the rows to be replaced\nmask = df['Column_x'].isnull()\n\n# We replace the NaN values with 0\ndf.loc[mask, 'Column_x'] = 0\n\n# We replace the remaining NaN values with 1\ndf.loc[~mask, 'Column_x'] = 1\n\n# We sort the DataFrame by the index\ndf = df.sort_index()\n", "metadata": {"problem_id": 223, "library_problem_id": 223, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 223}}
{"id": 224, "code": "\n# First, we need to calculate the number of NaN values in each row\nnum_nan = df['Column_x'].isna().sum()\n\n# Then, we calculate the number of rows to be replaced\nnum_repl = int(0.3 * num_nan)\n\n# We sort the indices by the number of NaN values in descending order\nindices = df[df['Column_x'].isna()].index.to_list()\nindices.sort(key=lambda x: num_nan[x], reverse=True)\n\n# We replace the first 'num_repl' rows with '0', the middle 'num_repl' with '0.5', and the rest with '1'\nfor i in range(num_repl):\n    df.loc[indices[i], 'Column_x'] = 1\n\ndf['Column_x'] = df['Column_x'].fillna(df['Column_x'].mean(), inplace=True)\n", "metadata": {"problem_id": 224, "library_problem_id": 224, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 223}}
{"id": 225, "code": "\n# First, we need to count the number of 0's and 1's in Column_x\ncount_0 = df['Column_x'].sum()\ncount_1 = len(df) - count_0\n\n# Then, we create a new column with the required number of 0's and 1's\ndf['new_Column_x'] = np.where(df['Column_x']==0, np.nan, 1)\n\n# Now, we fill the NaN values with the median of the new column\ndf['new_Column_x'].fillna(df['new_Column_x'].median(), inplace=True)\n\n# Finally, we drop the new column\ndf.drop('new_Column_x', axis=1, inplace=True)\n\ndf\n", "metadata": {"problem_id": 225, "library_problem_id": 225, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 223}}
{"id": 226, "code": "result = pd.DataFrame(list(zip(a['one'], b['one'])), columns=['one', 'two'])\nresult['one'], result['two'] = zip(a['two'], b['two'])\n", "metadata": {"problem_id": 226, "library_problem_id": 226, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 226}}
{"id": 227, "code": "result = pd.concat([a, b, c], axis=1).groupby(level=0, axis=1).apply(lambda x: x.iloc[0])\n", "metadata": {"problem_id": 227, "library_problem_id": 227, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 226}}
{"id": 228, "code": "\n# Create a new dataframe with the maximum length of the two original dataframes\nmax_length = max(a.shape[0], b.shape[0])\nresult = pd.DataFrame(np.empty((max_length, 2), dtype=object), columns=['one', 'two'])\n\n# Fill the new dataframe with the tuples from the original dataframes\nresult['one'] = a['one']\nresult['two'] = b['two']\n\n# If the original dataframes have different lengths, fill the new dataframe with np.nan\nresult['one'] = result['one'].fillna(np.nan)\nresult['two'] = result['two'].fillna(np.nan)\n\nresult\n", "metadata": {"problem_id": 228, "library_problem_id": 228, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 226}}
{"id": 229, "code": "result = df.groupby('username').views.apply(lambda x: pd.cut(x, bins=bins).value_counts()).unstack()\nresult", "metadata": {"problem_id": 229, "library_problem_id": 229, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 229}}
{"id": 230, "code": "result = df.groupby('username').views.apply(lambda x: pd.cut(x, bins=bins).value_counts()).unstack()\nresult", "metadata": {"problem_id": 230, "library_problem_id": 230, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 229}}
{"id": 231, "code": "result = df.groupby('username').views.apply(lambda x: pd.cut(x, bins=bins).value_counts()).unstack()\nresult", "metadata": {"problem_id": 231, "library_problem_id": 231, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 229}}
{"id": 232, "code": "\ndf['text'] = df['text'].apply(lambda x: ','.join(x.split()))\nresult = df['text'].str.cat(sep=', ')\n", "metadata": {"problem_id": 232, "library_problem_id": 232, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 232}}
{"id": 233, "code": "\ndf['text'] = df['text'].apply(lambda x: '-'.join(x.split('-')[::-1]))\nresult = df.iloc[0]\n", "metadata": {"problem_id": 233, "library_problem_id": 233, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 232}}
{"id": 234, "code": "\ndf['text'] = df['text'].apply(lambda x: ','.join(x.split(',')))\nresult = df['text'].str.cat(sep=', ')\n", "metadata": {"problem_id": 234, "library_problem_id": 234, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 232}}
{"id": 235, "code": "result = pd.Series(df['text'].values.tolist(), index=df['text'])\n", "metadata": {"problem_id": 235, "library_problem_id": 235, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 232}}
{"id": 236, "code": "df['text'] = df['text'].astype(str).str.cat(df['text'].shift(), '-')\ndf['text'] = df['text'].str.strip('-')\nresult = df['text'].iloc[0]\n", "metadata": {"problem_id": 236, "library_problem_id": 236, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 232}}
{"id": 237, "code": "df2 = df2.merge(df1[['id', 'city', 'district']], how='left', on=['id', 'city', 'district'])\nresult = pd.concat([df1, df2], axis=0)\nresult = result.sort_values('id').reset_index(drop=True)\nresult", "metadata": {"problem_id": 237, "library_problem_id": 237, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 237}}
{"id": 238, "code": "df1 = df1.merge(df2, on='id', how='left')\ndf1['date'] = df1['date'].dt.strftime('%d-%b-%Y')\nresult = pd.concat([df1, df2], axis=0)\nresult = result.sort_values(['id', 'date'])\nresult", "metadata": {"problem_id": 238, "library_problem_id": 238, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 237}}
{"id": 239, "code": "df2 = df2.merge(df1[['id', 'city', 'district']], how='left', on=['id', 'city', 'district'])\nresult = pd.concat([df1, df2]).sort_values(['id', 'date'])\n", "metadata": {"problem_id": 239, "library_problem_id": 239, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 237}}
{"id": 240, "code": "result = pd.merge(C, D, how='outer', on='A')\nresult['B'] = result['B_x']\nresult = result.drop(['B_x', 'B_y'], axis=1).rename(columns={'B_y': 'B'})\n", "metadata": {"problem_id": 240, "library_problem_id": 240, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 240}}
{"id": 241, "code": "result = pd.merge(C, D, how='outer', on='A')\nresult['B'] = result['B_x'].fillna(result['B_y'])\nresult.drop(['B_x', 'B_y'], axis=1, inplace=True)\nresult.rename(columns={'A': 'A_x', 'B': 'B_x'}, inplace=True)\nresult.sort_values('A_x', inplace=True)\nresult.reset_index(drop=True, inplace=True)\nresult\n", "metadata": {"problem_id": 241, "library_problem_id": 241, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 240}}
{"id": 242, "code": "\n# First, merge the dataframes on the 'A' column\nmerged = pd.merge(C, D, on='A', how='outer')\n\n# Then, create a new column 'duplicated' that is True if 'A' is in both dataframes and False otherwise\nmerged['duplicated'] = merged['A'].apply(lambda x: True if x in C.A and x in D.A else False)\n\n# Finally, sort the dataframe by 'A'\nresult = merged.sort_values('A')\n", "metadata": {"problem_id": 242, "library_problem_id": 242, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 240}}
{"id": 243, "code": "\ndf['time_amount'] = list(zip(df.time, df.amount))\nresult = df.groupby('user')['time_amount'].apply(list).reset_index(name='time_amount')\nresult['time_amount'] = result['time_amount'].apply(lambda x: [str(i) for i in x])\nresult = result.set_index('user')['time_amount'].apply(lambda x: [list(i) for i in x])\nresult = result.to_frame().reset_index()\nresult.columns = ['user', 'time_amount']\nresult\n", "metadata": {"problem_id": 243, "library_problem_id": 243, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 243}}
{"id": 244, "code": "\ndf['amount-time'] = list(zip(df['time'], df['amount']))\nresult = df.groupby('user')['amount-time'].apply(list).reset_index(name='amount-time')\nresult['amount-time'] = result['amount-time'].apply(lambda x: [str(i) for i in x])\nresult\n", "metadata": {"problem_id": 244, "library_problem_id": 244, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 243}}
{"id": 245, "code": "\ndf['amount-time'] = list(zip(df['time'], df['amount']))\nresult = df.groupby('user')['amount-time'].apply(list).reset_index(name='amount-time')\nresult['amount-time'] = result['amount-time'].apply(lambda x: [tuple(i) for i in x])\nresult\n", "metadata": {"problem_id": 245, "library_problem_id": 245, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 243}}
{"id": 246, "code": "\ndf = pd.concat([series.apply(pd.Series.to_frame).stack()], axis=1).reset_index(level=1, drop=True).T\ndf.columns = ['file1', 'file2', 'file3']\ndf = df.rename(index=str)\n", "metadata": {"problem_id": 246, "library_problem_id": 246, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 246}}
{"id": 247, "code": "\ndf = pd.DataFrame(series.tolist(), index=series.index).T\ndf.columns = ['0', '1', '2', '3']\ndf.index.name = 'name'\ndf = df.reset_index()\ndf_concatenated = df\n", "metadata": {"problem_id": 247, "library_problem_id": 247, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 246}}
{"id": 248, "code": "\nresult = [col for col in df.columns if s in col]\nprint(result)\n", "metadata": {"problem_id": 248, "library_problem_id": 248, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 248}}
{"id": 249, "code": "\n# Find the column name that contains 'spike'\nfor col in df.columns:\n    if s in col:\n        result = col\n        break\n\nprint(df[result])\n", "metadata": {"problem_id": 249, "library_problem_id": 249, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 248}}
{"id": 250, "code": "\n# Create a list of column names that contain the string 'spike'\ncols_with_spike = [col for col in df.columns if s in col]\n\n# Select the columns that contain 'spike'\nresult = df[cols_with_spike]\n\n# Rename the columns\nresult.columns = [col.replace('-', '') for col in result.columns]\n\nprint(result)\n", "metadata": {"problem_id": 250, "library_problem_id": 250, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 248}}
{"id": 251, "code": "\n# First, we need to flatten the list to a single series\nflat_codes = df['codes'].apply(pd.Series).stack()\n\n# Then, we use the `get_dummies` function to convert the list into a multi-column dataframe\nresult = pd.get_dummies(flat_codes)\n\n# Finally, we drop the original list column\nresult.drop('codes', axis=1, inplace=True)\n\n# If you want to rename the columns to 'code_0', 'code_1', etc.\nresult.columns = ['code_' + str(col) for col in result.columns]\n\nprint(result)\n", "metadata": {"problem_id": 251, "library_problem_id": 251, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 251}}
{"id": 252, "code": "\n# First, we need to flatten the list to a single series\nflat_codes = df['codes'].apply(pd.Series).stack()\n\n# Then, we need to drop the duplicates\nflat_codes = flat_codes.drop_duplicates()\n\n# Finally, we reshape the series into a dataframe\nresult = flat_codes.reset_index(drop=True).to_frame('codes')\n\n# Add a new column for the original index\nresult['code'] = df.index\n\n# Now, we can group by the original index and the new column\nresult = result.groupby('code').codes.apply(list).reset_index()\n\n# Rename the columns\nresult.columns = ['code', 'code_' + str(col)]\n\n# Convert the codes to float\nresult['code_' + str(col)] = result['code_' + str(col)].astype(float)\n\n# Fill NaNs\nresult['code_' + str(col)] = result['code_' + str(col)].fillna('')\n\n# Drop the original column\nresult = result.drop('code', axis=1)\n\nprint(result)\n", "metadata": {"problem_id": 252, "library_problem_id": 252, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 251}}
{"id": 253, "code": "\n# First, we need to flatten the list to a single series\nflat_codes = df['codes'].apply(pd.Series).stack()\n\n# Then, we need to split the series into multiple columns\nresult = flat_codes.groupby(level=0).apply(pd.Series.squeeze).reset_index(level=1, drop=True)\n\n# If there are missing values, we fill them with NaN\nresult = result.reindex(range(result.min(), result.max()+1), fill_value=float('NaN'))\n\n# Finally, we convert the final series to a dataframe\nresult = result.to_frame('codes')\n\n# Now, we can merge the original dataframe with the result\ndf = pd.merge(df, result, left_index=True, right_index=True)\n\nprint(df)\n", "metadata": {"problem_id": 253, "library_problem_id": 253, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 251}}
{"id": 254, "code": "\n# First, we need to convert the list to string\ndf['col1'] = df['col1'].apply(lambda x: '[' + ','.join(map(str, x)) + ']')\n\n# Then, we convert the string to list\nresult = df['col1'].str.split('[', expand=True).iloc[:, 1].apply(eval).apply(lambda x: [item[0] for item in x])\n", "metadata": {"problem_id": 254, "library_problem_id": 254, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 254}}
{"id": 255, "code": "\nresult = ','.join(str(i) for i in df['col1'].values.flatten())\n", "metadata": {"problem_id": 255, "library_problem_id": 255, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 254}}
{"id": 256, "code": "\n# Convert list to string\ndf['col1'] = df['col1'].apply(lambda x: ','.join(map(str, x)))\n\n# Flatten the list\nresult = df['col1'].str.cat(sep=',')\n", "metadata": {"problem_id": 256, "library_problem_id": 256, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 254}}
{"id": 257, "code": "df['Time'] = df['Time'].apply(lambda x: x.floor('2min'))\ndf.groupby('Time').mean()\n", "metadata": {"problem_id": 257, "library_problem_id": 257, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 257}}
{"id": 258, "code": "df['Time'] = df['Time'].apply(lambda x: x.floor('3min'))\ndf = df.groupby('Time').sum().reset_index()\ndf['Time'] = df['Time'].apply(lambda x: x + pd.to_timedelta(30, unit='min'))\ndf = df.set_index('Time')\ndf = df.interpolate(method='linear')\ndf = df.groupby(df.index.floor('3min')).sum().reset_index()\ndf = df.sort_index()\n", "metadata": {"problem_id": 258, "library_problem_id": 258, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 257}}
{"id": 259, "code": "df['TIME'] = pd.to_datetime(df['TIME'])\ndf['RANK'] = df.groupby('ID')['TIME'].rank(method='min')\ndf\n", "metadata": {"problem_id": 259, "library_problem_id": 259, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 259}}
{"id": 260, "code": "df['TIME'] = pd.to_datetime(df['TIME'])\ndf['RANK'] = df.groupby('ID')['TIME'].rank(method='min', ascending=False)\ndf\n", "metadata": {"problem_id": 260, "library_problem_id": 260, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 259}}
{"id": 261, "code": "df['TIME'] = pd.to_datetime(df['TIME'])\ndf['RANK'] = df.groupby('ID')['TIME'].rank(method=\"first\")\ndf['TIME'] = df['TIME'].dt.strftime('%d-%b-%Y %a %H:%M:%S')\n", "metadata": {"problem_id": 261, "library_problem_id": 261, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 259}}
{"id": 262, "code": "result = df[df.index.get_level_values('a').isin(filt.index)]", "metadata": {"problem_id": 262, "library_problem_id": 262, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 262}}
{"id": 263, "code": "result = df[~filt]\n", "metadata": {"problem_id": 263, "library_problem_id": 263, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 262}}
{"id": 264, "code": "\n# Selecting rows\nrows = df.iloc[[0, 8]]\n\n# Checking which columns are different\nresult = rows.columns[rows.ne(rows.iloc[0]).any(axis=1)]\n\n# Printing the result\nprint(result)\n", "metadata": {"problem_id": 264, "library_problem_id": 264, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 264}}
{"id": 265, "code": "\n# Selecting rows 0 and 8\nrow0 = df.iloc[0]\nrow8 = df.iloc[8]\n\n# Comparing the two rows\nresult = row0.eq(row8)\n\n# Printing the result\nprint(result)\n", "metadata": {"problem_id": 265, "library_problem_id": 265, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 264}}
{"id": 266, "code": "\nmask = df.iloc[0].ne(df.iloc[8])\nresult = df.columns[mask].tolist()\n", "metadata": {"problem_id": 266, "library_problem_id": 266, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 264}}
{"id": 267, "code": "\nresult = [(x, y) for x, y in zip(df.iloc[0], df.iloc[8]) if x != y or (x == np.nan and y != np.nan) or (y == np.nan and x != np.nan)]\n", "metadata": {"problem_id": 267, "library_problem_id": 267, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 264}}
{"id": 268, "code": "ts = pd.Series(df['Value'], index=df['Date'])\n", "metadata": {"problem_id": 268, "library_problem_id": 268, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 268}}
{"id": 269, "code": "df = df.T.iloc[0].to_frame().T\ndf.columns = [f'{c}_{i+1}' for i, c in enumerate(df.columns)]\ndf = df.iloc[0]\n", "metadata": {"problem_id": 269, "library_problem_id": 269, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 269}}
{"id": 270, "code": "df = df.T.iloc[0].to_frame().T\ndf.columns = [f'{c}_{i}' for i, c in enumerate(df.columns)]\ndf = df.reset_index(drop=True)\n", "metadata": {"problem_id": 270, "library_problem_id": 270, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 269}}
{"id": 271, "code": "df['dogs'] = df['dogs'].apply(lambda x: round(x, 2))\n", "metadata": {"problem_id": 271, "library_problem_id": 271, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 271}}
{"id": 272, "code": "df['dogs'] = df['dogs'].apply(lambda x: round(x, 2))\ndf['cats'] = df['cats'].apply(lambda x: round(x, 2))\n", "metadata": {"problem_id": 272, "library_problem_id": 272, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 271}}
{"id": 273, "code": "df['Sum'] = df[list_of_my_columns].sum(axis=1)\n", "metadata": {"problem_id": 273, "library_problem_id": 273, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 273}}
{"id": 274, "code": "\ndf['Avg'] = df[list_of_my_columns].mean(axis=1)\n", "metadata": {"problem_id": 274, "library_problem_id": 274, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 273}}
{"id": 275, "code": "\ndf['Avg'] = df[list_of_my_columns].mean(axis=1)\ndf['Min'] = df[list_of_my_columns].min(axis=1)\ndf['Max'] = df[list_of_my_columns].max(axis=1)\ndf['Median'] = df[list_of_my_columns].median(axis=1)\n", "metadata": {"problem_id": 275, "library_problem_id": 275, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 273}}
{"id": 276, "code": "\ndf.sort_index(level=2, ascending=True)\n", "metadata": {"problem_id": 276, "library_problem_id": 276, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 276}}
{"id": 277, "code": "df.sort_index(level=[0,1],ascending=[True,True])\n", "metadata": {"problem_id": 277, "library_problem_id": 277, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 276}}
{"id": 278, "code": "\n# Convert the date to datetime format\ndf['Date'] = pd.to_datetime(df['Date'])\n\n# Create a list of dates to be removed\nremove_list = ['2020-02-17', '2020-02-18']\n\n# Remove the dates from the DataFrame\ndf = df[~df.index.strftime('%Y-%m-%d').isin(remove_list)]\n\nresult = df\n", "metadata": {"problem_id": 278, "library_problem_id": 278, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 278}}
{"id": 279, "code": "\n# Create a list of dates to be removed\ndates_to_remove = ['2020-02-17', '2020-02-18']\n\n# Convert the list of dates to datetime format\ndates_to_remove = pd.to_datetime(dates_to_remove)\n\n# Remove the dates from the index\ndf.index = pd.to_datetime(df.index)\ndf.index = df.index.where(df.index.notin(dates_to_remove), df.index)\n\n# Reset the index\ndf.reset_index(inplace=True)\n\n# Convert the 'Date' column to the desired format\ndf['Date'] = df['Date'].dt.strftime('%d-%b-%Y %A')\n\nresult = df\n", "metadata": {"problem_id": 279, "library_problem_id": 279, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 278}}
{"id": 280, "code": "\n# Create a mask for the correlation matrix where the value is above 0.3\nmask = corr.abs() > 0.3\n\n# Create a DataFrame with the correlation values above 0.3\nresult = pd.DataFrame(corr.where(mask))\n\n# Rename the columns and index\nresult.columns = corr.columns\nresult.index = corr.columns\n\n# Print the result\nprint(result)\n", "metadata": {"problem_id": 280, "library_problem_id": 280, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 280}}
{"id": 281, "code": "\n# Filter the correlation matrix to only include the columns with correlation above 0.3\nabove_0_3 = corr.stack().reset_index()\nabove_0_3.columns = ['col1', 'col2', 'correlation']\nabove_0_3 = above_0_3[above_0_3['correlation'] > 0.3]\n\n# Get the unique pairs of columns\npairs = above_0_3[['col1', 'col2']].drop_duplicates()\n\n# Get the maximum correlation for each pair\nmax_corr = above_0_3.groupby(['col1', 'col2'])['correlation'].max().reset_index()\n\n# Merge the pairs with the maximum correlation\nresult = pd.merge(pairs, max_corr, on=['col1', 'col2'], how='inner')\n\n# Convert the result to a pandas Series\nresult = result.set_index(['col1', 'col2'])['correlation'].to_frame('correlation')\n\nprint(result)\n", "metadata": {"problem_id": 281, "library_problem_id": 281, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 280}}
{"id": 282, "code": "\ndf.rename(columns={df.columns[-1]: 'Test'}, inplace=True)\nresult = df\n", "metadata": {"problem_id": 282, "library_problem_id": 282, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 282}}
{"id": 283, "code": "df.rename(columns={df.columns[0]: 'Test'}, inplace=True)\nresult = df\n", "metadata": {"problem_id": 283, "library_problem_id": 283, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 282}}
{"id": 284, "code": "\ndf['frequent'] = df.apply(lambda row: 1 if row.value_counts().max() > 1 else 0, axis=1)\ndf['freq_count'] = df.apply(lambda row: row.value_counts().max(), axis=1)\n\ndf", "metadata": {"problem_id": 284, "library_problem_id": 284, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 284}}
{"id": 285, "code": "\ndf['frequent'] = df.apply(lambda row: row.value_counts().idxmax(), axis=1)\ndf['freq_count'] = df.apply(lambda row: row.value_counts().max(), axis=1)\n\nprint(df)\n", "metadata": {"problem_id": 285, "library_problem_id": 285, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 284}}
{"id": 286, "code": "\ndef find_frequent(x):\n    unique, counts = np.unique(x, return_counts=True)\n    return list(zip(unique, counts))\n\ndf['frequent'] = df.apply(find_frequent, axis=1)\ndf['freq_count'] = df['frequent'].apply(lambda x: [i[1] for i in x])\n", "metadata": {"problem_id": 286, "library_problem_id": 286, "library": "Pandas", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 284}}
{"id": 287, "code": "df['bar'] = pd.to_numeric(df['bar'], errors='coerce')\ndf = df.groupby(['id1', 'id2'])['foo', 'bar'].mean().reset_index()\nresult = df\n", "metadata": {"problem_id": 287, "library_problem_id": 287, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 287}}
{"id": 288, "code": "\ndf['bar'] = df['bar'].replace('NULL', 0)\ndf['bar'] = df['bar'].astype(float)\n\nresult = df.groupby(['id1', 'id2'])['foo', 'bar'].mean().reset_index()\n", "metadata": {"problem_id": 288, "library_problem_id": 288, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 287}}
{"id": 289, "code": "df_c = pd.merge(df_a, df_b, on='EntityNum', how='left')\nresult = df_c[['EntityNum','foo','a_col']]\n", "metadata": {"problem_id": 289, "library_problem_id": 289, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 289}}
{"id": 290, "code": "df_c = pd.merge(df_a, df_b, on='EntityNum', how='left')\nresult = df_c[['EntityNum','foo','b_col']]", "metadata": {"problem_id": 290, "library_problem_id": 290, "library": "Pandas", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 289}}
{"id": 291, "code": "result = a.shape\n", "metadata": {"problem_id": 291, "library_problem_id": 0, "library": "Numpy", "test_case_cnt": 4, "perturbation_type": "Origin", "perturbation_origin_id": 0}}
{"id": 292, "code": "x = x[np.logical_not(np.isnan(x))]", "metadata": {"problem_id": 292, "library_problem_id": 1, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 1}}
{"id": 293, "code": "x = np.where(np.isnan(x), np.inf, x)", "metadata": {"problem_id": 293, "library_problem_id": 2, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 1}}
{"id": 294, "code": "result = x.tolist()\nresult = [i for i in result if i != np.nan]\n", "metadata": {"problem_id": 294, "library_problem_id": 3, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 1}}
{"id": 295, "code": "b = np.eye(a.max() + 1)[a]", "metadata": {"problem_id": 295, "library_problem_id": 4, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 4}}
{"id": 296, "code": "b = np.eye(np.max(a) + 1)[a]\n", "metadata": {"problem_id": 296, "library_problem_id": 5, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 4}}
{"id": 297, "code": "b = np.zeros((len(a), max(a) + 1))\nb[:, a] = 1\n", "metadata": {"problem_id": 297, "library_problem_id": 6, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 4}}
{"id": 298, "code": "a_min = a.min()\na_max = a.max()\nb = np.zeros((len(a), a_max - a_min + 1))\nb[:, a - a_min] = 1", "metadata": {"problem_id": 298, "library_problem_id": 7, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 4}}
{"id": 299, "code": "\n# First, find the smallest and largest values in a\nmin_val = np.min(a)\nmax_val = np.max(a)\n\n# Then, create a one-hot encoding array\nb = np.zeros((a.shape[0], a.shape[1], max_val - min_val + 1))\n\n# Set the appropriate values in b to 1\nb[np.arange(a.shape[0]), np.arange(a.shape[1]), a - min_val] = 1", "metadata": {"problem_id": 299, "library_problem_id": 8, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 4}}
{"id": 300, "code": "result = np.percentile(a, p)\nprint(result)\n", "metadata": {"problem_id": 300, "library_problem_id": 9, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 9}}
{"id": 301, "code": "B = np.array(A).reshape(-1, ncol)\n", "metadata": {"problem_id": 301, "library_problem_id": 10, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 10}}
{"id": 302, "code": "B = np.reshape(A, (nrow, -1))\n", "metadata": {"problem_id": 302, "library_problem_id": 11, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 10}}
{"id": 303, "code": "B = np.array(A).reshape(-1, ncol)\n", "metadata": {"problem_id": 303, "library_problem_id": 12, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 10}}
{"id": 304, "code": "B = np.array(A).reshape(-1, ncol)\n", "metadata": {"problem_id": 304, "library_problem_id": 13, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 10}}
{"id": 305, "code": "result = np.roll(a, shift)\n", "metadata": {"problem_id": 305, "library_problem_id": 14, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 14}}
{"id": 306, "code": "result = np.pad(a, ((0, 0), (shift, 0)), mode='constant')\n", "metadata": {"problem_id": 306, "library_problem_id": 15, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 14}}
{"id": 307, "code": "result = np.roll(a, shift, axis=0)\n", "metadata": {"problem_id": 307, "library_problem_id": 16, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 14}}
{"id": 308, "code": "r_old = np.random.randint(3, size=(100, 2000)) - 1\nr_new = np.random.randint(3, size=(100, 2000)) - 1\n", "metadata": {"problem_id": 308, "library_problem_id": 17, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 17}}
{"id": 309, "code": "result = np.unravel_index(np.argmax(a, axis=None), a.shape)\nprint(result)\n", "metadata": {"problem_id": 309, "library_problem_id": 18, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 18}}
{"id": 310, "code": "result = np.unravel_index(np.argmin(a, axis=None), a.shape)\nprint(result)\n", "metadata": {"problem_id": 310, "library_problem_id": 19, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 18}}
{"id": 311, "code": "result = np.unravel_index(np.argmax(a), a.shape)\nprint(result)\n", "metadata": {"problem_id": 311, "library_problem_id": 20, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 18}}
{"id": 312, "code": "result = np.unravel_index(np.argmax(a), a.shape)\nprint(result)\n", "metadata": {"problem_id": 312, "library_problem_id": 21, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 18}}
{"id": 313, "code": "\n    max_value = np.max(a)\n    max_index = np.unravel_index(np.argmax(a, axis=None), a.shape, order='F')\n    return max_value, max_index\n    ### END SOLUTION\nf()\n", "metadata": {"problem_id": 313, "library_problem_id": 22, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 18}}
{"id": 314, "code": "\n# Get the maximum value in the array\nmax_value = np.amax(a)\n\n# Get the indices of the maximum value\nmax_indices = np.where(a == max_value)\n\n# Get the second largest value\nsecond_largest = np.partition(a.ravel(), -2)[-2]\n\n# Get the unraveled index of it\nresult = np.unravel_index(np.where(a == second_largest)[0], a.shape)\n\nprint(result)\n", "metadata": {"problem_id": 314, "library_problem_id": 23, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 18}}
{"id": 315, "code": "\na = a[:, ~np.isnan(a).any(axis=0)]", "metadata": {"problem_id": 315, "library_problem_id": 24, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 24}}
{"id": 316, "code": "a = a[~np.isnan(a).any(axis=1)]", "metadata": {"problem_id": 316, "library_problem_id": 25, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 24}}
{"id": 317, "code": "import numpy as np\na = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] \nresult = np.array(a)\n", "metadata": {"problem_id": 317, "library_problem_id": 26, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 26}}
{"id": 318, "code": "a = np.transpose(a[:, permutation])", "metadata": {"problem_id": 318, "library_problem_id": 27, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 27}}
{"id": 319, "code": "result = np.transpose(a, permutation)\n", "metadata": {"problem_id": 319, "library_problem_id": 28, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 27}}
{"id": 320, "code": "min_index = np.unravel_index(a.argmin(), a.shape)\nresult = (min_index[0], min_index[1])\n", "metadata": {"problem_id": 320, "library_problem_id": 29, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 29}}
{"id": 321, "code": "max_index = np.unravel_index(np.argmax(a), a.shape)\nresult = max_index\nprint(result)\n", "metadata": {"problem_id": 321, "library_problem_id": 30, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 29}}
{"id": 322, "code": "\n# Get the indices of the minimum value\nmin_indices = np.unravel_index(np.argmin(a, axis=None), a.shape)\n\n# Get the corresponding coordinates in the original array\nresult = np.array([a.shape[0]-1-i, i] for i in min_indices)\n\nprint(result)\n", "metadata": {"problem_id": 322, "library_problem_id": 31, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 29}}
{"id": 323, "code": "result = np.sin(np.deg2rad(degree))", "metadata": {"problem_id": 323, "library_problem_id": 32, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 32}}
{"id": 324, "code": "result = np.cos(np.deg2rad(degree))", "metadata": {"problem_id": 324, "library_problem_id": 33, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 32}}
{"id": 325, "code": "def is_degree(number):\n    if np.sin(np.radians(number)) > 0:\n        return 0\n    else:\n        return 1\n\nresult = is_degree(number)\n", "metadata": {"problem_id": 325, "library_problem_id": 34, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 32}}
{"id": 326, "code": "result = np.degrees(np.arcsin(value))\n", "metadata": {"problem_id": 326, "library_problem_id": 35, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 32}}
{"id": 327, "code": "\ndef pad(A, length):\n    return np.pad(A, (0, length - A.size), 'constant')\n\nresult = pad(A, length)\nprint(result)\n", "metadata": {"problem_id": 327, "library_problem_id": 36, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 36}}
{"id": 328, "code": "\ndef pad(A, length):\n    return np.pad(A, (0, length - A.size), 'constant')\n\nresult = pad(A, length)\nprint(result)\n", "metadata": {"problem_id": 328, "library_problem_id": 37, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 36}}
{"id": 329, "code": "a = np.power(a, power)", "metadata": {"problem_id": 329, "library_problem_id": 38, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 38}}
{"id": 330, "code": " ###\n    return np.power(a, power)\n    ### END SOLUTION ###\n\nprint(f(example_a, 2))\n", "metadata": {"problem_id": 330, "library_problem_id": 39, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 38}}
{"id": 331, "code": "result = np.divide(numerator, denominator)", "metadata": {"problem_id": 331, "library_problem_id": 40, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 40}}
{"id": 332, "code": " ###\n    result = np.divide(numerator, denominator)\n    return (result.astype(int), (numerator % denominator).astype(int))\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 332, "library_problem_id": 41, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Surface", "perturbation_origin_id": 40}}
{"id": 333, "code": "result = (numerator // denominator, denominator // numerator) if denominator != 0 else (np.nan, np.nan)\n", "metadata": {"problem_id": 333, "library_problem_id": 42, "library": "Numpy", "test_case_cnt": 4, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 40}}
{"id": 334, "code": "result = (a + b + c) / 3\n", "metadata": {"problem_id": 334, "library_problem_id": 43, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 43}}
{"id": 335, "code": "result = np.maximum.reduce([a, b, c])", "metadata": {"problem_id": 335, "library_problem_id": 44, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 43}}
{"id": 336, "code": "\nresult = np.diag(a.flatten()[::-1])\n", "metadata": {"problem_id": 336, "library_problem_id": 45, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 45}}
{"id": 337, "code": "\nresult = np.diag(a.flatten()[::-1])\n", "metadata": {"problem_id": 337, "library_problem_id": 46, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 45}}
{"id": 338, "code": "\nresult = np.diag(np.fliplr(a).diagonal())\n", "metadata": {"problem_id": 338, "library_problem_id": 47, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 45}}
{"id": 339, "code": "\nresult = np.diag(np.fliplr(a).sum(axis=1))\n", "metadata": {"problem_id": 339, "library_problem_id": 48, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 45}}
{"id": 340, "code": "result = [item for sublist in X for item in sublist]\n", "metadata": {"problem_id": 340, "library_problem_id": 49, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 49}}
{"id": 341, "code": "result = [X[i, j] for i in range(X.shape[0]) for j in range(X.shape[1])]\n", "metadata": {"problem_id": 341, "library_problem_id": 50, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 49}}
{"id": 342, "code": "\n    result = [item for sublist in X for item in sublist]\n    return result\n    ### END SOLUTION\n", "metadata": {"problem_id": 342, "library_problem_id": 51, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 49}}
{"id": 343, "code": "result = [X[i, j] for i in range(X.shape[0]) for j in range(X.shape[1])]\n", "metadata": {"problem_id": 343, "library_problem_id": 52, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 49}}
{"id": 344, "code": "result = np.array([int(i) for i in mystr])\n", "metadata": {"problem_id": 344, "library_problem_id": 53, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 53}}
{"id": 345, "code": "result = np.cumsum(a[:, col] * multiply_number)", "metadata": {"problem_id": 345, "library_problem_id": 54, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 54}}
{"id": 346, "code": "result = np.sum(a[row, :] * multiply_number)", "metadata": {"problem_id": 346, "library_problem_id": 55, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 54}}
{"id": 347, "code": "result = np.multiply(a[row, :], divide_number)", "metadata": {"problem_id": 347, "library_problem_id": 56, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 54}}
{"id": 348, "code": "\ndef get_max_independent_set(a):\n    n = len(a[0])\n    dp = [0] * (1 << n)\n    dp[0] = 1\n    for i in range(n):\n        if ((1 << i) & 0) == 0:\n            for j in range(i):\n                if ((1 << j) & i) == 0:\n                    dp[i] = max(dp[i], dp[i - j - 1] * a[j][i])\n    independent_set = []\n    for i in range(n):\n        if ((1 << i) & 0) == 0:\n            independent_set.append(dp[i])\n    return independent_set\n\nresult = get_max_independent_set(a)\nprint(result)\n", "metadata": {"problem_id": 348, "library_problem_id": 57, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 57}}
{"id": 349, "code": "\nresult = a.shape[0]\n", "metadata": {"problem_id": 349, "library_problem_id": 58, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 58}}
{"id": 350, "code": "t_statistic, p_value = scipy.stats.ttest_ind(a, b)\nprint(p_value)", "metadata": {"problem_id": 350, "library_problem_id": 59, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 59}}
{"id": 351, "code": "def weighted_t_test(a, b, alpha=0.05):\n    n_a = len(a)\n    n_b = len(b)\n    pooled_std = np.sqrt((np.var(a,ddof=1)*n_a + np.var(b,ddof=1)*n_b)/(n_a + n_b))\n    weight = (n_a + 1)*(n_b + 1) / ((n_a + 1) + (n_b + 1))\n    weighted_mean = weight*np.mean(a) + (1-weight)*np.mean(b)\n    t_statistic = (weighted_mean - (np.mean(a) + np.mean(b))) / pooled_std\n    p_value = 2 * (1 - scipy.stats.t.cdf(abs(t_statistic), n_a + n_b - 2))\n    return p_value\n\np_value = weighted_t_test(a, b)\nprint(p_value)\n", "metadata": {"problem_id": 351, "library_problem_id": 60, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 59}}
{"id": 352, "code": "from scipy.stats import ttest_ind\n\n# calculate the standard deviation\nstd_dev = np.sqrt((anobs-1)*avar + (bnobs-1)*bvar)\n\n# calculate the t-statistic\nt_stat = (bmean - amean) / (std_dev * np.sqrt(1/anobs + 1/bnobs))\n\n# calculate the p-value\np_value = 2 * (1 - scipy.stats.t.cdf(abs(t_stat), anobs+bnobs-2))\np_value\n", "metadata": {"problem_id": 352, "library_problem_id": 61, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 59}}
{"id": 353, "code": "\n# Convert the 2D arrays to 1D\nA = A.reshape(-1)\nB = B.reshape(-1)\n\n# Create a set from B\nB_set = set(B)\n\n# Create a list of elements in A that are not in B\noutput = [i for i in A if i not in B_set]\n\n# Convert the list back to a 2D array\noutput = np.array(output).reshape(-1, A.shape[1])\n", "metadata": {"problem_id": 353, "library_problem_id": 62, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 62}}
{"id": 354, "code": "\n# Convert the 2D arrays to 1D\nA = A.reshape(-1)\nB = B.reshape(-1)\n\n# Get the unique elements in A and B\nunique_A = np.unique(A)\nunique_B = np.unique(B)\n\n# Get the elements in A that are not in B\noutput = unique_A[~np.isin(unique_A, unique_B)]\n\n# Get the elements in B that are not in A\noutput = np.append(output, unique_B[~np.isin(unique_B, unique_A)])\n\n# Convert the output back to 2D\noutput = output.reshape(-1, 1)\n\nprint(output)\n", "metadata": {"problem_id": 354, "library_problem_id": 63, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Semantic", "perturbation_origin_id": 62}}
{"id": 355, "code": "sort_indices = np.argsort(a, axis=0)\nc = b[sort_indices]\n", "metadata": {"problem_id": 355, "library_problem_id": 64, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 64}}
{"id": 356, "code": "sort_indices = np.argsort(a, axis=0)\nc = b[sort_indices]\n", "metadata": {"problem_id": 356, "library_problem_id": 65, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 64}}
{"id": 357, "code": "sort_indices = np.argsort(a, axis=0)\nc = b[sort_indices]\n", "metadata": {"problem_id": 357, "library_problem_id": 66, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 64}}
{"id": 358, "code": "result = np.sort(b, axis=2) - np.sum(a, axis=2, keepdims=True)\nresult += np.argmax(a, axis=2)\nresult = b[np.argsort(result.sum(axis=2))]", "metadata": {"problem_id": 358, "library_problem_id": 67, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 64}}
{"id": 359, "code": "a = np.delete(a, 2, axis=1)", "metadata": {"problem_id": 359, "library_problem_id": 68, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 68}}
{"id": 360, "code": "a = np.delete(a, 2, axis=0)", "metadata": {"problem_id": 360, "library_problem_id": 69, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 68}}
{"id": 361, "code": "a = np.delete(a, [0, 2], axis=1)", "metadata": {"problem_id": 361, "library_problem_id": 70, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 68}}
{"id": 362, "code": "\n# Create a mask for the columns to be deleted\nmask = np.ones(a.shape[1], dtype=bool)\nfor i in del_col:\n    mask[i-1] = False\n\n# Apply the mask to the array\nresult = a[:, mask]\n", "metadata": {"problem_id": 362, "library_problem_id": 71, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 68}}
{"id": 363, "code": "a = np.insert(a, pos, element)\n", "metadata": {"problem_id": 363, "library_problem_id": 72, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 72}}
{"id": 364, "code": "a = np.insert(a, pos, element, axis=0)\n", "metadata": {"problem_id": 364, "library_problem_id": 73, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 72}}
{"id": 365, "code": "\n    a = np.insert(a, pos, element)\n    return a\n    ### END SOLUTION\n    print(a)\n", "metadata": {"problem_id": 365, "library_problem_id": 74, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 72}}
{"id": 366, "code": "a = np.insert(a, pos, element, axis=0)\n", "metadata": {"problem_id": 366, "library_problem_id": 75, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 72}}
{"id": 367, "code": "result = np.array([np.copy(x) for x in array_of_arrays])", "metadata": {"problem_id": 367, "library_problem_id": 76, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 76}}
{"id": 368, "code": "result = np.all(np.diff(a, axis=1) == 0, axis=1)", "metadata": {"problem_id": 368, "library_problem_id": 77, "library": "Numpy", "test_case_cnt": 5, "perturbation_type": "Origin", "perturbation_origin_id": 77}}
{"id": 369, "code": "result = np.all(np.diff(a, axis=1) == 0, axis=1)", "metadata": {"problem_id": 369, "library_problem_id": 78, "library": "Numpy", "test_case_cnt": 5, "perturbation_type": "Semantic", "perturbation_origin_id": 77}}
{"id": 370, "code": "\n    return np.all(np.equal(a, a[0]))\n    ### END SOLUTION\n\nprint(f(example_a))\n", "metadata": {"problem_id": 370, "library_problem_id": 79, "library": "Numpy", "test_case_cnt": 5, "perturbation_type": "Surface", "perturbation_origin_id": 77}}
{"id": 371, "code": "X, Y = np.meshgrid(x, y)\nZ = (np.cos(X))**4 + (np.sin(Y))**2\nresult = np.trapz(np.trapz(Z, x=x, y=y), y)", "metadata": {"problem_id": 371, "library_problem_id": 80, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 80}}
{"id": 372, "code": "\n    return (np.cos(x))**4 + (np.sin(y))**2\n    ### END SOLUTION\n\nresult = scipy.integrate.dblquad(f, 0, 1, lambda x: 0, lambda x: 1)\nprint(result)\n", "metadata": {"problem_id": 372, "library_problem_id": 81, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 80}}
{"id": 373, "code": "def ecdf(data):\n    x = np.sort(data)\n    y = np.arange(1, len(x)+1) / len(x)\n    return x, y\n\nresult = ecdf(grades)\n", "metadata": {"problem_id": 373, "library_problem_id": 82, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 82}}
{"id": 374, "code": "def ecdf(data):\n    # normalize data\n    x = np.sort(data)\n    y = np.arange(1, len(x)+1) / len(x)\n    return x, y\n\nx, y = ecdf(grades)\nresult = np.interp(eval, x, y)\n", "metadata": {"problem_id": 374, "library_problem_id": 83, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 82}}
{"id": 375, "code": "def ecdf(data):\n    # sort the data\n    x = np.sort(data)\n    # calculate the number of data points\n    n = x.shape[0]\n    # calculate the cumulative sum of the data\n    y = np.arange(1, n+1) / n\n    return y, x\n\ny, x = ecdf(grades)\n\n# find the index of the first value that is greater than the threshold\nindex = np.where(y > threshold)[0]\n\n# if there is no such index, set high to the maximum value\nif index.shape[0] == 0:\n    high = np.max(x)\nelse:\n    # otherwise, set high to the value at the index\n    high = x[index[0]]\n\n# find the index of the last value that is less than the threshold\nindex = np.where(y <= threshold)[0]\n\n# if there is no such index, set low to the minimum value\nif index.shape[0] == 0:\n    low = np.min(x)\nelse:\n    # otherwise, set low to the value at the index\n    low = x[index[-1]]\n\nprint(f'The longest interval [{low}, {high}) that satisfies ECDF(x) < {threshold} is [{low}, {high}).')\n", "metadata": {"problem_id": 375, "library_problem_id": 84, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 82}}
{"id": 376, "code": "nums = np.random.choice([0, 1], size=size, p=[one_ratio, 1-one_ratio])\n", "metadata": {"problem_id": 376, "library_problem_id": 85, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 85}}
{"id": 377, "code": "a_np = a.numpy()\n", "metadata": {"problem_id": 377, "library_problem_id": 86, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 86}}
{"id": 378, "code": "a_pt = torch.from_numpy(a)\n", "metadata": {"problem_id": 378, "library_problem_id": 87, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 86}}
{"id": 379, "code": "a_np = a.numpy()\n", "metadata": {"problem_id": 379, "library_problem_id": 88, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 88}}
{"id": 380, "code": "a_tf = tf.convert_to_tensor(a)\n", "metadata": {"problem_id": 380, "library_problem_id": 89, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 88}}
{"id": 381, "code": "result = a.argsort()[::-1]", "metadata": {"problem_id": 381, "library_problem_id": 90, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 90}}
{"id": 382, "code": "result = np.argsort(a) + np.arange(len(a))\n", "metadata": {"problem_id": 382, "library_problem_id": 91, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 90}}
{"id": 383, "code": "result = np.argsort(a)[-N:][::-1]\n", "metadata": {"problem_id": 383, "library_problem_id": 92, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 90}}
{"id": 384, "code": "result = np.linalg.matrix_power(A, n)", "metadata": {"problem_id": 384, "library_problem_id": 93, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 93}}
{"id": 385, "code": "\n# First, we need to reshape the array to a 3D array with shape (2, 2, 2)\na = a.reshape((2, 2, 2))\n\n# Then, we need to transpose the 3D array to get the desired output\nresult = a.transpose((0, 2, 1))\n\nprint(result)\n", "metadata": {"problem_id": 385, "library_problem_id": 94, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 94}}
{"id": 386, "code": "\ndef sliding_window(a, window_size):\n    shape = a.shape\n    strides = a.strides\n    sub_shape = (shape[0] - window_size[0] + 1, shape[1] - window_size[1] + 1)\n    sub_strides = (strides[0], strides[1])\n    result = np.lib.stride_tricks.as_strided(a, window_size, sub_strides)\n    return result\n\nwindow_size = (2, 2)\nresult = sliding_window(a, window_size)\nprint(result)\n", "metadata": {"problem_id": 386, "library_problem_id": 95, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 94}}
{"id": 387, "code": "\n# First, we need to reshape the array to (4, 2, 2)\na = a.reshape((4, 2, 2))\n\n# Then, we need to transpose the array to get the desired output\na = a.transpose((0, 2, 1))\n\n# Finally, we reshape the array back to the original shape\nresult = a.reshape((2, 2, 2))\n", "metadata": {"problem_id": 387, "library_problem_id": 96, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 94}}
{"id": 388, "code": "\n# Calculate the number of patches\nnum_rows = a.shape[0] // patch_size\nnum_cols = a.shape[1] // patch_size\n\n# Create an empty list to store the patches\npatches = []\n\n# Loop over the rows\nfor i in range(num_rows):\n    # Loop over the columns\n    for j in range(num_cols):\n        # Extract a patch of size patch_size\n        patch = a[i*patch_size:(i+1)*patch_size, j*patch_size:(j+1)*patch_size]\n        # Append the patch to the list\n        patches.append(patch)\n\n# Convert the list to a numpy array\nresult = np.array(patches)\n", "metadata": {"problem_id": 388, "library_problem_id": 97, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 94}}
{"id": 389, "code": "result = np.pad(a.reshape(-1, h, w), ((0, 0), (1, 1)), mode='constant')[:, :, :-1]\n", "metadata": {"problem_id": 389, "library_problem_id": 98, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 94}}
{"id": 390, "code": "\n# Calculate the number of patches\nnum_rows = a.shape[0] // patch_size\nnum_cols = a.shape[1] // patch_size\n\n# Create an empty list to store the patches\npatches = []\n\n# Loop over the rows\nfor i in range(num_rows):\n    # Loop over the columns\n    for j in range(num_cols):\n        # Extract a patch of size patch_size\n        patch = a[i*patch_size:(i+1)*patch_size, j*patch_size:(j+1)*patch_size]\n        # Append the patch to the list\n        patches.append(patch)\n\n# Convert the list to a numpy array\nresult = np.array(patches)\n", "metadata": {"problem_id": 390, "library_problem_id": 99, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 94}}
{"id": 391, "code": "result = a[:, low:high+1]", "metadata": {"problem_id": 391, "library_problem_id": 100, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 100}}
{"id": 392, "code": "result = a[low:high+1]", "metadata": {"problem_id": 392, "library_problem_id": 101, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 100}}
{"id": 393, "code": "result = a[:, low:high+1]", "metadata": {"problem_id": 393, "library_problem_id": 102, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 100}}
{"id": 394, "code": "a = np.array(eval(string))\n", "metadata": {"problem_id": 394, "library_problem_id": 103, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 103}}
{"id": 395, "code": "result = np.random.uniform(min, max, n)\nresult = np.power(result, 1/np.log(max/min))", "metadata": {"problem_id": 395, "library_problem_id": 104, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 104}}
{"id": 396, "code": "result = np.random.exponential(scale=np.power(np.e, max), size=n) + np.power(np.e, min)\n", "metadata": {"problem_id": 396, "library_problem_id": 105, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 104}}
{"id": 397, "code": " ###\n    return (np.random.uniform(low=np.log(min), high=np.log(max), size=n)) * (max - min) + min\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 397, "library_problem_id": 106, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 104}}
{"id": 398, "code": "B = A.copy()\nB[0] *= a\nfor t in range(1, len(A)):\n    B[t] = a * A[t] + b * B[t-1]\n", "metadata": {"problem_id": 398, "library_problem_id": 107, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 107}}
{"id": 399, "code": "B = A.copy()\nB[0] *= a\nfor i in range(1, len(A)):\n    B[i] = a * A[i] + b * B[i-1] + c * B[i-2]\n", "metadata": {"problem_id": 399, "library_problem_id": 108, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 107}}
{"id": 400, "code": "result = np.empty((0,))\n", "metadata": {"problem_id": 400, "library_problem_id": 109, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 109}}
{"id": 401, "code": "result = np.empty((3,0))\n", "metadata": {"problem_id": 401, "library_problem_id": 110, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 109}}
{"id": 402, "code": "result = np.sub2ind(a.shape, index) + 1", "metadata": {"problem_id": 402, "library_problem_id": 111, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 111}}
{"id": 403, "code": "result = sub2ind(dims, index)\n", "metadata": {"problem_id": 403, "library_problem_id": 112, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 111}}
{"id": 404, "code": "values = np.zeros((2,3), dtype='float32').astype(np.float32)\ndf = pd.DataFrame(data=values, index=index, columns=columns)\n", "metadata": {"problem_id": 404, "library_problem_id": 113, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 113}}
{"id": 405, "code": "\nresult = np.array([np.sum(a[accmap==i]) for i in np.unique(accmap)])\n", "metadata": {"problem_id": 405, "library_problem_id": 114, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 114}}
{"id": 406, "code": "result = np.max(a[index])\n", "metadata": {"problem_id": 406, "library_problem_id": 115, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 114}}
{"id": 407, "code": "result = np.cumsum(a[accmap >= 0])", "metadata": {"problem_id": 407, "library_problem_id": 116, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 114}}
{"id": 408, "code": "result = a[index]\n", "metadata": {"problem_id": 408, "library_problem_id": 117, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 114}}
{"id": 409, "code": "z = np.vectorize(elementwise_function)(x, y)", "metadata": {"problem_id": 409, "library_problem_id": 118, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 118}}
{"id": 410, "code": "result = np.random.choice(lista_elegir, samples, p=probabilit)", "metadata": {"problem_id": 410, "library_problem_id": 119, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 119}}
{"id": 411, "code": "\n# Create a new array with the desired size\nnew_a = np.zeros((max(low_index, 0),)*3 + (a.shape,))\n\n# Copy the original array into the new array\nnew_a[:a.shape[0], :a.shape[1], :a.shape[2]] = a\n\n# Now you can slice the new array\nresult = new_a[max(low_index, 0):, max(low_index, 0):, max(low_index, 0):]\n", "metadata": {"problem_id": 411, "library_problem_id": 120, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 120}}
{"id": 412, "code": "result = x[x >= 0]", "metadata": {"problem_id": 412, "library_problem_id": 121, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 121}}
{"id": 413, "code": "result = x[np.iscomplex(x)]", "metadata": {"problem_id": 413, "library_problem_id": 122, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 121}}
{"id": 414, "code": "bin_data = np.array_split(data, bin_size)\nbin_data_mean = [np.mean(b) for b in bin_data]\n", "metadata": {"problem_id": 414, "library_problem_id": 123, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 123}}
{"id": 415, "code": "bin_data = np.lib.split(data, np.arange(bin_size, len(data) + 1, bin_size))\nbin_data_max = [max(x) for x in bin_data]\n", "metadata": {"problem_id": 415, "library_problem_id": 124, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 123}}
{"id": 416, "code": "\n# First, we need to bin the data\nbins = np.array_split(data, bin_size)\n\n# Then, we calculate the mean for each bin\nbin_data_mean = [np.mean(bin) for bin in bins]\n\nprint(bin_data_mean)\n", "metadata": {"problem_id": 416, "library_problem_id": 125, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 123}}
{"id": 417, "code": "\n# Calculate the number of bins\nnum_bins = len(data) // bin_size\n\n# Create the bins\nbins = np.array_split(data, num_bins)\n\n# Calculate the mean of each bin\nbin_data_mean = [np.mean(bin) for bin in bins]\n\nprint(bin_data_mean)\n", "metadata": {"problem_id": 417, "library_problem_id": 126, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 123}}
{"id": 418, "code": "\ndef bin_data(data, bin_size):\n    return [data[i:i+bin_size] for i in range(len(data)-bin_size+1)]\n\ndef calculate_mean(bin_data):\n    return [sum(x)/len(x) for x in bin_data]\n\nbin_data_mean = calculate_mean(bin_data(data, bin_size))\n", "metadata": {"problem_id": 418, "library_problem_id": 127, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 123}}
{"id": 419, "code": "\n# First, we need to find the number of bins needed\nnum_bins = len(data) // bin_size\n\n# Then, we create the bins\nbins = np.array_split(data, num_bins)\n\n# Now, we calculate the mean of each bin\nbin_data_mean = [np.mean(bin, axis=0) for bin in bins]\n\n# We also need to remove the first few elements of each row\nbin_data_mean = [[bin[i] for i in range(len(bin)-num_bins*bin_size)] for bin in bin_data_mean]\n\nprint(bin_data_mean)\n", "metadata": {"problem_id": 419, "library_problem_id": 128, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 123}}
{"id": 420, "code": "\ndef smoothclamp(x, min_val, max_val):\n    t = (x-min_val) / (max_val-min_val)\n    return max_val * (3*(t)**2) - (max_val * (2*(t)**3))\n", "metadata": {"problem_id": 420, "library_problem_id": 129, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 129}}
{"id": 421, "code": "\ndef smoothclamp(x, x_min, x_max, N):\n    t = np.clip((x - x_min) / (x_max - x_min), 0.0, 1.0)\n    return x_min + (x_max - x_min) * (6*t**5 - 15*N*t**4 + 10*N**3)\n", "metadata": {"problem_id": 421, "library_problem_id": 130, "library": "Numpy", "test_case_cnt": 4, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 129}}
{"id": 422, "code": "\n# First, we need to create a circular version of b\nb_circular = np.concatenate((b[::-1], b))\n\n# Then, we perform the circular correlation\nresult = np.correlate(a, b_circular, mode='full')\n\n# Finally, we remove the extra elements from the result\nresult = result[len(a):]\n\nprint(result)\n", "metadata": {"problem_id": 422, "library_problem_id": 131, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 131}}
{"id": 423, "code": "result = df.groupby('major').apply(lambda x: x.values.reshape(1,15,5)).values", "metadata": {"problem_id": 423, "library_problem_id": 132, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 132}}
{"id": 424, "code": "result = df.groupby('major').apply(lambda x: x.values.reshape(-1, 1, 5)).values", "metadata": {"problem_id": 424, "library_problem_id": 133, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 132}}
{"id": 425, "code": "result = np.array([list(np.binary_repr(num, width=m)) for num in a])\nresult = [list(map(int, x)) for x in result]\nresult = np.array(result)\n", "metadata": {"problem_id": 425, "library_problem_id": 134, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 134}}
{"id": 426, "code": "\ndef int_to_bin(num):\n    return np.binary_repr(num, width=m)\n\nresult = np.array([list(map(int, x)) for x in a.astype(str).apply(int_to_bin)])\n", "metadata": {"problem_id": 426, "library_problem_id": 135, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 134}}
{"id": 427, "code": "\ndef int_to_bin(num, m):\n    return np.binary_repr(num, width=m)\n\nresult = np.array([int_to_bin(i, m) for i in a])\nresult = result.astype(int)\nresult = np.apply_along_axis(lambda x: x[::-1], 1, result)\nresult = np.apply_along_axis(lambda x: [int(i) for i in x], 0, result)\nresult = np.array([[np.bitwise_xor.reduce(row, 0) for row in result]])\nresult = result.T\nresult\n", "metadata": {"problem_id": 427, "library_problem_id": 136, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 134}}
{"id": 428, "code": "mu = np.mean(a)\nsigma = np.std(a)\nresult = (mu - 3*sigma, mu + 3*sigma)\n", "metadata": {"problem_id": 428, "library_problem_id": 137, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 137}}
{"id": 429, "code": "mu = np.mean(a)\nsigma = np.std(a)\nstart = mu - 2*sigma\nend = mu + 2*sigma\nresult = (start, end)\n", "metadata": {"problem_id": 429, "library_problem_id": 138, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 137}}
{"id": 430, "code": " ###\n    mean = np.mean(a)\n    std_dev = np.std(a)\n    start = mean - 3*std_dev\n    end = mean + 3*std_dev\n    return (start, end)\n    ### END SOLUTION ###\nf()\n", "metadata": {"problem_id": 430, "library_problem_id": 139, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 137}}
{"id": 431, "code": "\n# Calculate mean and standard deviation\nmean = np.mean(a)\nstd_dev = np.std(a)\n\n# Calculate the 2nd standard deviation\nsecond_std_dev = mean - 2*std_dev\n\n# Create a boolean mask for outliers\nmask = (a <= second_std_dev) | (a >= mean + 2*std_dev)\n\n# Assign True to outliers and False to non-outliers\nresult = mask\n", "metadata": {"problem_id": 431, "library_problem_id": 140, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 137}}
{"id": 432, "code": "masked_data = np.ma.masked_less(DataArray, 0)\nprob = np.percentile(masked_data.compressed(), percentile)\n", "metadata": {"problem_id": 432, "library_problem_id": 141, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 141}}
{"id": 433, "code": "a[zero_rows, :] = 0\na[:, zero_cols] = 0\n", "metadata": {"problem_id": 433, "library_problem_id": 142, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 142}}
{"id": 434, "code": "\nfor i in zero_rows:\n    a[i, :] = 0\nfor i in zero_cols:\n    a[:, i] = 0\n", "metadata": {"problem_id": 434, "library_problem_id": 143, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 142}}
{"id": 435, "code": "a[1, :] = 0\na[:, 0] = 0\n", "metadata": {"problem_id": 435, "library_problem_id": 144, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 142}}
{"id": 436, "code": "\nmax_values = np.amax(a, axis=1)\nmask = (a == max_values[:, None])\nmask = mask.astype(bool)\n", "metadata": {"problem_id": 436, "library_problem_id": 145, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 145}}
{"id": 437, "code": "\nmin_val = np.min(a, axis=1)[:, np.newaxis]\nmask = a == min_val", "metadata": {"problem_id": 437, "library_problem_id": 146, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 145}}
{"id": 438, "code": "\n# Convert the lists to numpy arrays\npost = np.array(post)\ndistance = np.array(distance)\n\n# Calculate the Pearson correlation coefficient\nresult, _ = np.pearsonr(post, distance)\n\nprint(result)\n", "metadata": {"problem_id": 438, "library_problem_id": 147, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 147}}
{"id": 439, "code": "result = np.einsum('ijk->ijm', X)", "metadata": {"problem_id": 439, "library_problem_id": 148, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 148}}
{"id": 440, "code": "X = np.einsum('ijk->ijm', Y)", "metadata": {"problem_id": 440, "library_problem_id": 149, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 148}}
{"id": 441, "code": "is_contained = number in a\n", "metadata": {"problem_id": 441, "library_problem_id": 150, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 150}}
{"id": 442, "code": "\n# Convert A to a set for faster lookup\nA_set = set(A)\n\n# Use set difference to find elements in B that are not in A\nC = list(A_set - set(B))\n\nprint(C)\n", "metadata": {"problem_id": 442, "library_problem_id": 151, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 151}}
{"id": 443, "code": "C = A[np.in1d(A, B)]", "metadata": {"problem_id": 443, "library_problem_id": 152, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 151}}
{"id": 444, "code": "mask = np.in1d(A, B)\nC = A[mask]", "metadata": {"problem_id": 444, "library_problem_id": 153, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 151}}
{"id": 445, "code": "result = rankdata(a, method='max') - 1", "metadata": {"problem_id": 445, "library_problem_id": 154, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 154}}
{"id": 446, "code": "result = len(a) - rankdata(a).astype(int)\nprint(result)\n", "metadata": {"problem_id": 446, "library_problem_id": 155, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 154}}
{"id": 447, "code": " ###\n    return rankdata(a, method='max').argsort()\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 447, "library_problem_id": 156, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 154}}
{"id": 448, "code": "dists = np.dstack((x_dists, y_dists))\n", "metadata": {"problem_id": 448, "library_problem_id": 157, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 157}}
{"id": 449, "code": "dists = np.dstack((x_dists, y_dists))\n", "metadata": {"problem_id": 449, "library_problem_id": 158, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 157}}
{"id": 450, "code": "result = a[:, second[0] : second[1], third[0] : third[1]]", "metadata": {"problem_id": 450, "library_problem_id": 159, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 159}}
{"id": 451, "code": "arr = np.zeros((20,10,10,2))", "metadata": {"problem_id": 451, "library_problem_id": 160, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 160}}
{"id": 452, "code": "l1 = np.linalg.norm(X, 1, axis=1)\nresult = X / l1[:, np.newaxis]\n", "metadata": {"problem_id": 452, "library_problem_id": 161, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 161}}
{"id": 453, "code": "\ndef l2_normalize(X):\n    norms = np.linalg.norm(X, axis=1, ord=2)\n    return X / norms[:, np.newaxis]\n\nresult = l2_normalize(X)\nprint(result)\n", "metadata": {"problem_id": 453, "library_problem_id": 162, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 161}}
{"id": 454, "code": "\ndef l_norm(X):\n    return np.array([LA.norm(v, np.inf) for v in X])\n\nresult = l_norm(X)\nprint(result)\n", "metadata": {"problem_id": 454, "library_problem_id": 163, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 161}}
{"id": 455, "code": "conditions = df['a'].apply(lambda x: target in str(x))\nresult = np.select(conditions, choices, default=np.nan)\n", "metadata": {"problem_id": 455, "library_problem_id": 164, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 164}}
{"id": 456, "code": "\ndef calculate_distance(a, b):\n    return np.sqrt(np.sum((a - b) ** 2))\n\nresult = np.array([calculate_distance(a[i], a) for i in range(len(a))])\nresult = np.maximum(result, result[:, np.newaxis])  # to avoid self-distance\nresult = 1 - result\nresult = result / np.sum(result)  # normalize\nresult = np.nan_to_num(result)\n", "metadata": {"problem_id": 456, "library_problem_id": 165, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 165}}
{"id": 457, "code": "\ndef calculate_distance(a):\n    n = a.shape[0]\n    result = np.zeros((n, n))\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                result[i, j] = np.sqrt(np.sum((a[i] - a[j]) ** 2))\n    return result\n\nresult = calculate_distance(a)\n", "metadata": {"problem_id": 457, "library_problem_id": 166, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 165}}
{"id": 458, "code": "\n# Calculate the Euclidean distance\ndistance = np.sqrt(np.sum((a - a.T)**2, axis=1))\n\n# Create a mask to exclude diagonal elements\nmask = np.eye(len(a), dtype=bool)\n\n# Create a masked array to exclude diagonal elements\nmasked_distance = np.ma.masked_array(distance, mask)\n\n# Calculate the upper triangle matrix\nresult = masked_distance.masked_less(0).transpose()\n", "metadata": {"problem_id": 458, "library_problem_id": 167, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 165}}
{"id": 459, "code": "AVG = np.mean(NA)\n", "metadata": {"problem_id": 459, "library_problem_id": 168, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 168}}
{"id": 460, "code": "AVG = np.mean(NA)\n", "metadata": {"problem_id": 460, "library_problem_id": 169, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 168}}
{"id": 461, "code": "AVG = np.mean(NA)\n", "metadata": {"problem_id": 461, "library_problem_id": 170, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 168}}
{"id": 462, "code": "\n# First, find the indices of non-zero elements\nindices = np.where(a != 0)[0]\n\n# Then, create a new array with only the unique non-zero elements\nresult = a[indices[1:]].reshape(-1,1)\n\nprint(result)\n", "metadata": {"problem_id": 462, "library_problem_id": 171, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 171}}
{"id": 463, "code": "\n# First, find the indices of non-zero elements\nindices = np.where(a != 0)[0]\n\n# Then, create a new array with only the non-zero elements\nresult = a[indices]\n\n# Finally, remove the adjacent duplicates\nresult = np.diff(result) != 0\n\n# Reshape the result to match the original shape\nresult = result.reshape(-1, 1)\n\nprint(result)\n", "metadata": {"problem_id": 463, "library_problem_id": 172, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 171}}
{"id": 464, "code": "df = pd.DataFrame(np.column_stack((lat[0], lon[0], val[0])), columns=['lat', 'lon', 'val'])\nfor i in range(1, len(lat)):\n    df = df.append(pd.DataFrame(np.column_stack((lat[i], lon[i], val[i])), columns=['lat', 'lon', 'val']), ignore_index=True)\n", "metadata": {"problem_id": 464, "library_problem_id": 173, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 173}}
{"id": 465, "code": "\n    df = pd.DataFrame({'lat': lat[0], 'lon': lon[0], 'val': val[0]})\n    for i in range(1, len(lat)):\n        df = df.append(pd.DataFrame({'lat': lat[i], 'lon': lon[i], 'val': val[i]}, ignore_index=True))\n    return df\n    ### END SOLUTION\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##\n    ##", "metadata": {"problem_id": 465, "library_problem_id": 174, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 173}}
{"id": 466, "code": "\n# Create a dataframe\ndf = pd.DataFrame({'lat': lat.flatten(), 'lon': lon.flatten(), 'val': val.flatten()})\n\n# Add a new column 'maximum' to the dataframe\ndf['maximum'] = df.max(axis=1)\n\n# Reset the index\ndf = df.reset_index(drop=True)\n\nprint(df)\n", "metadata": {"problem_id": 466, "library_problem_id": 175, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 173}}
{"id": 467, "code": "\ndef rolling_window(a, size):\n    shape = (a.shape[0]-size[0]+1, a.shape[1]-size[1]+1) + size\n    strides = a.strides + a.strides\n    return np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)\n\nresult = rolling_window(a, size)\nprint(result)\n", "metadata": {"problem_id": 467, "library_problem_id": 176, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 176}}
{"id": 468, "code": "\ndef rolling_window(a, size):\n    shape = (a.shape[0]-size[0]+1, a.shape[1]-size[1]+1) + size\n    strides = a.strides + a.strides\n    return np.lib.stride_tricks.as_strided(a, shape=shape, strides=strides)\n\nresult = rolling_window(a, size)\nprint(result)\n", "metadata": {"problem_id": 468, "library_problem_id": 177, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 176}}
{"id": 469, "code": "result = np.mean(a)\n", "metadata": {"problem_id": 469, "library_problem_id": 178, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 178}}
{"id": 470, "code": " ###\n    return np.mean(a)\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 470, "library_problem_id": 179, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 178}}
{"id": 471, "code": "result = Z[:,:,:-1]", "metadata": {"problem_id": 471, "library_problem_id": 180, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 180}}
{"id": 472, "code": "\n# For 2D array\nif len(a.shape) == 2:\n    result = a[-1:, :]\n\n# For 3D array\nelif len(a.shape) == 3:\n    result = a[-1:, :, :]\n", "metadata": {"problem_id": 472, "library_problem_id": 181, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 180}}
{"id": 473, "code": "result = any(np.array_equal(c, contour) for contour in CNTS)\n", "metadata": {"problem_id": 473, "library_problem_id": 182, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 182}}
{"id": 474, "code": "result = any(np.array_equal(c, cnt) for cnt in CNTS)\n", "metadata": {"problem_id": 474, "library_problem_id": 183, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 182}}
{"id": 475, "code": "f = intp.interp2d(x_new, y_new, a, kind='linear')\nresult = f(np.linspace(0, 2, 4), np.linspace(0, 2, 4))", "metadata": {"problem_id": 475, "library_problem_id": 184, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 184}}
{"id": 476, "code": "df[name] = np.cumsum(df.Q)\n", "metadata": {"problem_id": 476, "library_problem_id": 185, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 185}}
{"id": 477, "code": "i = np.eye(i.shape[0], dtype=int)\n", "metadata": {"problem_id": 477, "library_problem_id": 186, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 186}}
{"id": 478, "code": "a[np.triu_indices(len(a), k=1)] = 0\n", "metadata": {"problem_id": 478, "library_problem_id": 187, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 187}}
{"id": 479, "code": "start_date = pd.to_datetime(start)\nend_date = pd.to_datetime(end)\ndelta = end_date - start_date\nresult = np.linspace(start_date, end_date, n)\nresult = pd.DatetimeIndex(result)\n", "metadata": {"problem_id": 479, "library_problem_id": 188, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 188}}
{"id": 480, "code": "result = np.where((x == a) & (y == b))[0][0]\nif result == -1:\n    print(\"No such index\")\nelse:\n    print(\"Index: \", result)\n", "metadata": {"problem_id": 480, "library_problem_id": 189, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 189}}
{"id": 481, "code": "indices = np.where((x == a) & (y == b))[0]\nresult = indices if indices.size > 0 else []\nresult\n", "metadata": {"problem_id": 481, "library_problem_id": 190, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Semantic", "perturbation_origin_id": 189}}
{"id": 482, "code": "\n# calculate the coefficients a, b and c using the least squares method\ncoefficients = np.polyfit(x, y, 2)\na, b, c = coefficients\nresult = [a, b, c]\nprint(result)\n", "metadata": {"problem_id": 482, "library_problem_id": 191, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 191}}
{"id": 483, "code": "\n# create a matrix with the x values\nX = np.column_stack((np.ones(len(x)), np.array(x)))\n\n# calculate the coefficients\ncoefficients = np.linalg.lstsq(X, np.array(y), rcond=None)[0]\n\n# sort the coefficients by their absolute value\nresult = sorted(coefficients, key=abs, reverse=True)\n\nprint(result)\n", "metadata": {"problem_id": 483, "library_problem_id": 192, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 191}}
{"id": 484, "code": "\ntemp_arr = [0,1,2,3]\n\ndf = df.sub(temp_arr[0], axis=0)\ndf = df.sub(temp_arr[1], axis=0)\ndf = df.sub(temp_arr[2], axis=0)\ndf = df.sub(temp_arr[3], axis=0)\n\nprint(df)\n", "metadata": {"problem_id": 484, "library_problem_id": 193, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 193}}
{"id": 485, "code": "result = np.einsum('ijk,il->ik', A, B)", "metadata": {"problem_id": 485, "library_problem_id": 194, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 194}}
{"id": 486, "code": "scaler = MinMaxScaler()\nresult = scaler.fit_transform(a)\n", "metadata": {"problem_id": 486, "library_problem_id": 195, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 195}}
{"id": 487, "code": "scaler = MinMaxScaler()\nresult = scaler.fit_transform(arr)\n", "metadata": {"problem_id": 487, "library_problem_id": 196, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 195}}
{"id": 488, "code": "scaler = MinMaxScaler()\nresult = scaler.fit_transform(a)\n", "metadata": {"problem_id": 488, "library_problem_id": 197, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 195}}
{"id": 489, "code": "\nmask = arr < -10\nmask2 = arr >= 15\nmask3 = mask ^ mask2\n\narr[mask] = 0\narr[mask3] = arr[mask3] + 5\narr[~mask2] = 30\n", "metadata": {"problem_id": 489, "library_problem_id": 198, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 198}}
{"id": 490, "code": "\nfor i in range(arr.shape[0]):\n    mask = arr[i, :] < n1[i]\n    mask2 = arr[i, :] >= n2[i]\n    arr[i, mask] = 0\n    arr[i, mask2] = 30\n    arr[i, ~mask2] = arr[i, ~mask2] + 5\n", "metadata": {"problem_id": 490, "library_problem_id": 199, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 198}}
{"id": 491, "code": "result = np.nonzero(s1 != s2)[0].shape[0]\n", "metadata": {"problem_id": 491, "library_problem_id": 200, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 200}}
{"id": 492, "code": "# print the number of times s1 is not equal to s2 (should be 0)\nresult = np.nonzero(s1 != s2)[0].shape[0]\n", "metadata": {"problem_id": 492, "library_problem_id": 201, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 200}}
{"id": 493, "code": "result = np.array_equal(a[0], a)\n", "metadata": {"problem_id": 493, "library_problem_id": 202, "library": "Numpy", "test_case_cnt": 5, "perturbation_type": "Origin", "perturbation_origin_id": 202}}
{"id": 494, "code": "result = all(np.isnan(arr).all() for arr in a)\n", "metadata": {"problem_id": 494, "library_problem_id": 203, "library": "Numpy", "test_case_cnt": 5, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 202}}
{"id": 495, "code": "\n# Calculate how many zeros to add at the beginning and end of each dimension\npad_dims = tuple(np.array(shape) - np.array(a.shape))\n\n# Zero pad the array\nresult = np.pad(a, pad_dims, mode='constant')\n", "metadata": {"problem_id": 495, "library_problem_id": 204, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 204}}
{"id": 496, "code": "\n# Calculate how many zeros to add at the beginning and end of each dimension\npad_dims = tuple(np.array(shape) - np.array(a.shape))\n\n# Zero pad the array\nresult = np.pad(a, pad_dims, mode='constant')\n", "metadata": {"problem_id": 496, "library_problem_id": 205, "library": "Numpy", "test_case_cnt": 4, "perturbation_type": "Surface", "perturbation_origin_id": 204}}
{"id": 497, "code": "\n# Calculate how many times the array needs to be padded\npad_width = [(0, 0) for _ in range(len(a.shape))]\npad_width[0] = (max(0, shape[0] - a.shape[0]), 0)\npad_width[1] = (max(0, shape[1] - a.shape[1]), 0)\n\n# Pad the array\nresult = np.pad(a, pad_width, mode='constant', constant_values=element)\n", "metadata": {"problem_id": 497, "library_problem_id": 206, "library": "Numpy", "test_case_cnt": 4, "perturbation_type": "Semantic", "perturbation_origin_id": 204}}
{"id": 498, "code": "\n    diff_row = shape[0] - arr.shape[0]\n    diff_col = shape[1] - arr.shape[1]\n    padded_arr = np.pad(arr, ((0, diff_row), (0, diff_col)))\n    return padded_arr\n    ### END SOLUTION\n\nprint(f())\n", "metadata": {"problem_id": 498, "library_problem_id": 207, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 204}}
{"id": 499, "code": "\n# calculate the padding\npad_top = (shape[0] - a.shape[0]) // 2\npad_bottom = shape[0] - a.shape[0] - pad_top\npad_left = (shape[1] - a.shape[1]) // 2\npad_right = shape[1] - a.shape[1] - pad_left\n\n# apply padding\nresult = np.pad(a, ((pad_top, pad_bottom), (pad_left, pad_right)))\n", "metadata": {"problem_id": 499, "library_problem_id": 208, "library": "Numpy", "test_case_cnt": 4, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 204}}
{"id": 500, "code": "a = np.array([i for i in range(0,12)]).reshape(a.shape[0]/3,3)", "metadata": {"problem_id": 500, "library_problem_id": 209, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 209}}
{"id": 501, "code": "result = a[np.arange(a.shape[0]), np.arange(a.shape[1]), b]", "metadata": {"problem_id": 501, "library_problem_id": 210, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 210}}
{"id": 502, "code": "\nresult = a[np.arange(a.shape[0]), b[:, :, 0], b[:, :, 1]]", "metadata": {"problem_id": 502, "library_problem_id": 211, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 210}}
{"id": 503, "code": "result = a[np.arange(a.shape[0]), b[:, :, None], b[:, None, :]]", "metadata": {"problem_id": 503, "library_problem_id": 212, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 210}}
{"id": 504, "code": "result = np.sum(a[..., np.arange(b.shape[1])] * (b[..., np.newaxis] == np.arange(b.shape[1])))\n", "metadata": {"problem_id": 504, "library_problem_id": 213, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 210}}
{"id": 505, "code": "result = np.sum(a[np.arange(a.shape[0]), np.arange(a.shape[1]), b])\n", "metadata": {"problem_id": 505, "library_problem_id": 214, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 210}}
{"id": 506, "code": "\nmask = df['a'].between(1, 4)\nresult = df.loc[mask, 'b'].values\nresult = np.where(mask, result, np.nan)\nprint(result)\n", "metadata": {"problem_id": 506, "library_problem_id": 215, "library": "Numpy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 215}}
{"id": 507, "code": "\n# First, create a mask where the image is not completely black\nmask = im.copy()\nmask[mask != 0] = 1\n\n# Now, iterate over the mask, and for each zero, remove the corresponding row and column\nfor i in range(mask.shape[0]):\n    for j in range(mask.shape[1]):\n        if mask[i,j] == 0:\n            im[i,j] = 0\n            im[i-1,j] = 0\n            im[i+1,j] = 0\n            im[i,j-1] = 0\n            im[i,j+1] = 0\n\n# Finally, create a new mask where the image is not completely black\nmask = im.copy()\nmask[mask != 0] = 1\n\n# Now, iterate over the mask, and for each zero, remove the corresponding row and column\nfor i in range(mask.shape[0]):\n    for j in range(mask.shape[1]):\n        if mask[i,j] == 0:\n            im[i,j] = 0\n\nresult = im\n", "metadata": {"problem_id": 507, "library_problem_id": 216, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 216}}
{"id": 508, "code": "mask = A.any(axis=0)\nresult = A[mask]\n\nmask = A.any(axis=1)\nresult = result[:, mask]\n", "metadata": {"problem_id": 508, "library_problem_id": 217, "library": "Numpy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 216}}
{"id": 509, "code": "\n# First, find the non-zero elements in the image\nnon_zero_elements = im.flatten()\n\n# Then, find the indices of the non-zero elements\nindices = np.argwhere(non_zero_elements)\n\n# Now, create a mask where the non-zero elements are located\nmask = np.zeros_like(im, dtype=bool)\nmask[tuple(indices.T)] = True\n\n# Finally, remove the non-zero elements from the image\nresult = im * mask\n", "metadata": {"problem_id": 509, "library_problem_id": 218, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 216}}
{"id": 510, "code": "\n# First, find the non-zero elements in the array\nmask = im.any(axis=1)\n\n# Then, find the indices of the non-zero elements\nindices = np.argwhere(mask)\n\n# Finally, slice the array based on the indices\nresult = im[indices[:,0].min():indices[:,0].max()+1, indices[:,1].min():indices[:,1].max()+1]\n", "metadata": {"problem_id": 510, "library_problem_id": 219, "library": "Numpy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 216}}
{"id": 511, "code": "plt.figure(figsize=(10,6))\nplt.scatter(x, y, label='x vs y')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.legend()\nplt.show()\n", "metadata": {"problem_id": 511, "library_problem_id": 0, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 0}}
{"id": 512, "code": "plt.gca().yaxis.set_minor_locator(plt.MultipleLocator(0.1))\n", "metadata": {"problem_id": 512, "library_problem_id": 1, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 1}}
{"id": 513, "code": "plt.minorticks_on()\n", "metadata": {"problem_id": 513, "library_problem_id": 2, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 1}}
{"id": 514, "code": "plt.gca().xaxis.set_minor_locator(plt.MultipleLocator(0.1))\n", "metadata": {"problem_id": 514, "library_problem_id": 3, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 1}}
{"id": 515, "code": "plt.figure(figsize=(10, 6))\nplt.plot(x, np.sin(x), 'r--', label='sin')\nplt.plot(x, np.cos(x), 'bs', label='cos')\nplt.plot(x, np.tan(x), 'g^', label='tan')\nplt.legend(loc='best')\nplt.title('Sine, Cosine, and Tangent Functions')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.grid(True)\nplt.show()\n", "metadata": {"problem_id": 515, "library_problem_id": 4, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 4}}
{"id": 516, "code": "plt.figure(figsize=(10, 6))\nplt.plot(x, np.sin(x), 'r--', label='sin')\nplt.plot(x, np.cos(x), 'bs', label='cos')\nplt.plot(x, np.tan(x), 'g^', label='tan')\nplt.legend(loc='best')\nplt.title('Sine, Cosine, and Tangent Functions')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.grid(True)\nplt.show()\n", "metadata": {"problem_id": 516, "library_problem_id": 5, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 4}}
{"id": 517, "code": "plt.plot(x, y, marker='D')\nplt.show()\n", "metadata": {"problem_id": 517, "library_problem_id": 6, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 4}}
{"id": 518, "code": "plt.plot(x, y, marker='D', linestyle='-', linewidth=2)\nplt.show()\n", "metadata": {"problem_id": 518, "library_problem_id": 7, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 4}}
{"id": 519, "code": "ax.set_ylim(0, 40)\n", "metadata": {"problem_id": 519, "library_problem_id": 8, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 8}}
{"id": 520, "code": "plt.plot(x, 'r--')\nplt.fill_between(range(2, 4), x[2:4], color='red', alpha=0.5)\n", "metadata": {"problem_id": 520, "library_problem_id": 9, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 9}}
{"id": 521, "code": "x = np.linspace(0, 1, 100)\ny = 2 * x + 1\nplt.plot(x, y)\nplt.show()\n", "metadata": {"problem_id": 521, "library_problem_id": 10, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 10}}
{"id": 522, "code": "x = np.array([0, 1])\ny = np.array([0, 2])\nplt.plot(x, y, color='red')\nplt.show()\n", "metadata": {"problem_id": 522, "library_problem_id": 11, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 10}}
{"id": 523, "code": "seaborn.relplot(\n    data=df,\n    x=\"Height (cm)\",\n    y=\"Weight (kg)\",\n    hue=\"Gender\",\n    kind=\"scatter\",\n    palette=\"deep\",\n)\nplt.show()\n", "metadata": {"problem_id": 523, "library_problem_id": 12, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 12}}
{"id": 524, "code": "sns.set_style(\"whitegrid\")\nplt.figure(figsize=(10,6))\nsns.lineplot(x, y)\nplt.show()\n", "metadata": {"problem_id": 524, "library_problem_id": 13, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 13}}
{"id": 525, "code": "df = pd.DataFrame({'x': x, 'y': y})\nsns.lineplot(data=df, x='x', y='y')\nplt.show()\n", "metadata": {"problem_id": 525, "library_problem_id": 14, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 13}}
{"id": 526, "code": "plt.plot(x, y, '+', linewidth=7)\n", "metadata": {"problem_id": 526, "library_problem_id": 15, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 15}}
{"id": 527, "code": "plt.legend(fontsize=20)\n", "metadata": {"problem_id": 527, "library_problem_id": 16, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 16}}
{"id": 528, "code": "plt.legend(title='xyz', title_fontsize=20)\n", "metadata": {"problem_id": 528, "library_problem_id": 17, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 16}}
{"id": 529, "code": "plt.plot(range(10), \"o-\", lw=5, markersize=30, alpha=0.2)\n", "metadata": {"problem_id": 529, "library_problem_id": 18, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 18}}
{"id": 530, "code": "plt.scatter(range(10), x, color='black', s=30, marker='o')\nplt.scatter(range(10), y, color='black', s=30, marker='o')\n", "metadata": {"problem_id": 530, "library_problem_id": 19, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 18}}
{"id": 531, "code": "plt.plot(range(10), \"r-\", lw=5, markersize=30)\n", "metadata": {"problem_id": 531, "library_problem_id": 20, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 18}}
{"id": 532, "code": "plt.xticks(rotation=45)\n", "metadata": {"problem_id": 532, "library_problem_id": 21, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 21}}
{"id": 533, "code": "plt.xticks(rotation=45)\n", "metadata": {"problem_id": 533, "library_problem_id": 22, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 21}}
{"id": 534, "code": "plt.xticks(np.arange(0, 2*np.pi, 2))\n", "metadata": {"problem_id": 534, "library_problem_id": 23, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 21}}
{"id": 535, "code": "plt.legend(loc='upper right')\n", "metadata": {"problem_id": 535, "library_problem_id": 24, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 24}}
{"id": 536, "code": "plt.imshow(H, cmap='hot', interpolation='nearest')\nplt.show()\n", "metadata": {"problem_id": 536, "library_problem_id": 25, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 25}}
{"id": 537, "code": "plt.imshow(H, cmap='gray')\nplt.show()\n", "metadata": {"problem_id": 537, "library_problem_id": 26, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 25}}
{"id": 538, "code": "plt.xlabel(\"X\")\nplt.plot(x, y)\nplt.show()\n", "metadata": {"problem_id": 538, "library_problem_id": 27, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 27}}
{"id": 539, "code": "plt.xticks(rotation=90)\n", "metadata": {"problem_id": 539, "library_problem_id": 28, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 28}}
{"id": 540, "code": "plt.title(myTitle, fontsize=16, loc='left')\n", "metadata": {"problem_id": 540, "library_problem_id": 29, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 29}}
{"id": 541, "code": "plt.ylim(0, 2.5)\nplt.plot(x, y)\nplt.show()\n", "metadata": {"problem_id": 541, "library_problem_id": 30, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 30}}
{"id": 542, "code": "plt.xticks([0, 1.5])\n", "metadata": {"problem_id": 542, "library_problem_id": 31, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 31}}
{"id": 543, "code": "plt.yticks([-1, 1])\n", "metadata": {"problem_id": 543, "library_problem_id": 32, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 31}}
{"id": 544, "code": "plt.figure(figsize=(10, 6))\nplt.plot(x, label='x')\nplt.plot(y, label='y')\nplt.plot(z, label='z')\nplt.legend()\nplt.show()\n", "metadata": {"problem_id": 544, "library_problem_id": 33, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 33}}
{"id": 545, "code": "plt.scatter(x, y, c='black', s=50, facecolors='blue')\nplt.show()\n", "metadata": {"problem_id": 545, "library_problem_id": 34, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 34}}
{"id": 546, "code": "plt.xticks(np.arange(0, 10, 1))\nplt.yticks(np.arange(0, 10, 1))\n", "metadata": {"problem_id": 546, "library_problem_id": 35, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 35}}
{"id": 547, "code": "plt.gca().yaxis.set_major_formatter('{:,}')\nplt.show()\n", "metadata": {"problem_id": 547, "library_problem_id": 36, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 36}}
{"id": 548, "code": "sns.lineplot(x=x, y=y, linestyle='--')\n", "metadata": {"problem_id": 548, "library_problem_id": 37, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 37}}
{"id": 549, "code": "fig, ax = plt.subplots(2, sharex=True)\nax[0].plot(x, y1, label='sin')\nax[1].plot(x, y2, label='cos')\n\n# set labels and titles\nax[0].set_ylabel('sin')\nax[1].set_ylabel('cos')\nax[0].set_title('Sine Wave')\nax[1].set_title('Cosine Wave')\n\n# set legend\nax[0].legend()\nax[1].legend()\n\n# show the plot\nplt.show()\n", "metadata": {"problem_id": 549, "library_problem_id": 38, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 38}}
{"id": 550, "code": "plt.figure(figsize=(10, 5))\nplt.subplot(1, 2, 1)\nplt.plot(x, y1, 'r')\nplt.title('Sine Wave')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.grid(True)\nplt.spines['left'].set_color('none')\nplt.spines['right'].set_color('none')\nplt.spines['top'].set_color('none')\nplt.spines['bottom'].set_color('none')\nplt.tick_params(left='none', top='none', bottom='none', labelleft='none', labelright='none', labeltop='none', labelbottom='none')\n\nplt.subplot(1, 2, 2)\nplt.plot(x, y2, 'b')\nplt.title('Cosine Wave')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.grid(True)\nplt.spines['left'].set_color('none')\nplt.spines['right'].set_color('none')\nplt.spines['top'].set_color('none')\nplt.spines['bottom'].set_color('none')\nplt.tick_params(left='none', top='none', bottom='none', labelleft='none', labelright='none', labeltop='none', labelbottom='none')\n\nplt.tight_layout()\nplt.show()\n", "metadata": {"problem_id": 550, "library_problem_id": 39, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 38}}
{"id": 551, "code": "plt.xlabel('')\n", "metadata": {"problem_id": 551, "library_problem_id": 40, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 40}}
{"id": 552, "code": "plt.xticks(rotation=90)\n", "metadata": {"problem_id": 552, "library_problem_id": 41, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 40}}
{"id": 553, "code": "plt.xticks(np.arange(0, 10, 2))\nplt.grid(axis='x', which='both')\nplt.show()\n", "metadata": {"problem_id": 553, "library_problem_id": 42, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 42}}
{"id": 554, "code": "plt.yticks(np.arange(min(y), max(y), 1))\nplt.axvline(x=3, color='r', linestyle='--')\nplt.axvline(x=4, color='r', linestyle='--')\n", "metadata": {"problem_id": 554, "library_problem_id": 43, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 42}}
{"id": 555, "code": "plt.yticks(np.arange(min(y), max(y), 1))\nplt.xticks(np.arange(min(x), max(x), 1))\nplt.grid(axis='y', which='both', linestyle='-', linewidth=0.5)\nplt.grid(axis='x', which='both', linestyle='-', linewidth=0.5)\n", "metadata": {"problem_id": 555, "library_problem_id": 44, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 42}}
{"id": 556, "code": "plt.grid(True)\n", "metadata": {"problem_id": 556, "library_problem_id": 45, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 42}}
{"id": 557, "code": "plt.legend(loc='lower right')\n", "metadata": {"problem_id": 557, "library_problem_id": 46, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 46}}
{"id": 558, "code": "fig, axes = plt.subplots(ncols=2, nrows=2, figsize=(8, 6),\n                        subplot_kw={'xlim': (0, 1), 'ylim': (-2, 2)})\naxes = axes.flatten()\n\nfor ax in axes:\n    ax.set_ylabel(r\"$\\ln\\left(\\frac{x_a-x_b}{x_a-x_c}\\right)$\")\n    ax.set_xlabel(r\"$\\ln\\left(\\frac{x_a-x_d}{x_a-x_e}\\right)$\")\n\nplt.show()\nplt.clf()\n", "metadata": {"problem_id": 558, "library_problem_id": 47, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 47}}
{"id": 559, "code": "plt.plot(x, y, label='Y')\nplt.plot(x, z, label='Z')\nplt.legend()\n", "metadata": {"problem_id": 559, "library_problem_id": 48, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 48}}
{"id": 560, "code": "ax.xaxis.tick_top()\n", "metadata": {"problem_id": 560, "library_problem_id": 49, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 49}}
{"id": 561, "code": "plt.xlabel(\"X\")\nplt.xticks(np.arange(10))\nplt.ylabel(\"Y\")\nplt.yticks(np.arange(10))\nplt.plot(x, y)\nplt.show()\n", "metadata": {"problem_id": 561, "library_problem_id": 50, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 50}}
{"id": 562, "code": "plt.plot(x, y)\nplt.xticks([])\nplt.show()\n", "metadata": {"problem_id": 562, "library_problem_id": 51, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 51}}
{"id": 563, "code": "plt.plot(x, y)\nplt.gca().tick_params(axis='y')\nplt.show()\n", "metadata": {"problem_id": 563, "library_problem_id": 52, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 52}}
{"id": 564, "code": "plt.plot(x, y)\nplt.ylabel('Y')\nplt.xticks(rotation=90)\nplt.show()\n", "metadata": {"problem_id": 564, "library_problem_id": 53, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 52}}
{"id": 565, "code": "sns.jointplot(x=\"total_bill\", y=\"tip\", data=tips, kind='reg', \n              scatter_kws={'color':'green'}, line_kws={'color':'blue'})\nplt.show()\n", "metadata": {"problem_id": 565, "library_problem_id": 54, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 54}}
{"id": 566, "code": "sns.jointplot(x=\"total_bill\", y=\"tip\", data=tips, color='green')\nplt.show()\n", "metadata": {"problem_id": 566, "library_problem_id": 55, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 54}}
{"id": 567, "code": "sns.jointplot(x='total_bill', y='tip', data=tips, kind='reg')\nplt.show()\n", "metadata": {"problem_id": 567, "library_problem_id": 56, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 54}}
{"id": 568, "code": "plt.figure(figsize=(10,6))\nplt.bar(df[\"celltype\"], df[\"s1\"], label='s1')\nplt.bar(df[\"celltype\"], df[\"s2\"], bottom=df[\"s1\"], label='s2')\nplt.xlabel(\"celltype\")\nplt.xticks(rotation=90)\nplt.legend()\nplt.show()\n", "metadata": {"problem_id": 568, "library_problem_id": 57, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 57}}
{"id": 569, "code": "plt.figure(figsize=(10,6))\nplt.bar(df[\"celltype\"], df[\"s1\"], color='blue')\nplt.bar(df[\"celltype\"], df[\"s2\"], color='green')\nplt.xlabel(\"celltype\", rotation=45)\nplt.show()\n", "metadata": {"problem_id": 569, "library_problem_id": 58, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 57}}
{"id": 570, "code": "plt.plot(x, y)\nplt.xlabel('X', color='red')\nplt.ylabel('Y', color='red')\nplt.xticks(color='red')\nplt.yticks(color='red')\nplt.show()\n", "metadata": {"problem_id": 570, "library_problem_id": 59, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 59}}
{"id": 571, "code": "plt.plot(x, y, label='X')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.title('Line plot of Y over X')\nplt.legend()\nplt.show()\n", "metadata": {"problem_id": 571, "library_problem_id": 60, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 59}}
{"id": 572, "code": "plt.plot(x, y)\nplt.xticks(rotation=90)\nplt.yticks(rotation=0)\nplt.tight_layout()\nplt.show()\n", "metadata": {"problem_id": 572, "library_problem_id": 61, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 61}}
{"id": 573, "code": "plt.axvline(x=0.22058956, color='r', linestyle='--')\nplt.axvline(x=0.33088437, color='g', linestyle='--')\nplt.axvline(x=2.20589566, color='b', linestyle='--')\nplt.show()\n", "metadata": {"problem_id": 573, "library_problem_id": 62, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 62}}
{"id": 574, "code": "plt.imshow(rand_mat, cmap='hot', interpolation='nearest')\nplt.xticks(range(len(xlabels)), xlabels, rotation=90)\nplt.yticks(range(len(ylabels)), ylabels)\nplt.ylabel('Y-axis')\nplt.xlabel('X-axis')\nplt.show()\n", "metadata": {"problem_id": 574, "library_problem_id": 63, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 63}}
{"id": 575, "code": "\nfig = plt.figure()\nax = fig.add_subplot(111)\nax.plot(time, Swdown, \"-\", label=\"Swdown\")\nax.plot(time, Rn, \"-\", label=\"Rn\")\nax2 = ax.twinx()\nax2.plot(time, temp, \"-r\", label=\"temp\")\nax.legend(loc='upper right')\nax.grid()\nax.set_xlabel(\"Time (h)\")\nax.set_ylabel(r\"Radiation ($MJ\\,m^{-2}\\,d^{-1}$)\")\nax2.set_ylabel(r\"Temperature ($^\\circ$C)\")\nax2.set_ylim(0, 35)\nax.set_ylim(-20, 100)\nplt.show()\nplt.clf()\n\n", "metadata": {"problem_id": 575, "library_problem_id": 64, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 64}}
{"id": 576, "code": "fig, axs = plt.subplots(2)\naxs[0].plot(x, y, label='Y')\naxs[1].plot(x, y, label='Y')\n\naxs[0].set_title('Y')\naxs[1].set_title('Y')\n\nplt.tight_layout()\nplt.show()\n", "metadata": {"problem_id": 576, "library_problem_id": 65, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 65}}
{"id": 577, "code": "sns.scatterplot(data=df, x=\"bill_length_mm\", y=\"bill_depth_mm\", s=30)\nplt.show()\n", "metadata": {"problem_id": 577, "library_problem_id": 66, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 66}}
{"id": 578, "code": "plt.scatter(a, b, c)\nplt.annotate(c, (a[0], b[0]), textcoords=\"offset points\", xytext=(0,10), ha='center')\nplt.show()\n", "metadata": {"problem_id": 578, "library_problem_id": 67, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 67}}
{"id": 579, "code": "plt.plot(x, y, label='y over x')\nplt.legend(title='Legend')\nplt.show()\n", "metadata": {"problem_id": 579, "library_problem_id": 68, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 68}}
{"id": 580, "code": "plt.plot(x, y, label='y over x')\nplt.legend(label='Legend', title='Legend', title_fontsize='14', fontsize='12', loc='best')\nplt.show()\n", "metadata": {"problem_id": 580, "library_problem_id": 69, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 68}}
{"id": 581, "code": "plt.hist(x, bins=5, edgecolor='black', linewidth=1.2)\nplt.show()\n", "metadata": {"problem_id": 581, "library_problem_id": 70, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 70}}
{"id": 582, "code": "fig, axs = plt.subplots(2, 1, figsize=(10, 10))\nfig.suptitle('Two subplots')\n\naxs[0] = plt.subplot2grid((3, 1), (0, 0), rowspan=3, colspan=1)\naxs[1] = plt.subplot2grid((3, 1), (0, 0), rowspan=1, colspan=1, sharex=axs[0])\n\naxs[0].plot(x, y, 'r')  # Red plot\naxs[1].plot(x, y, 'b')  # Blue plot\n\nplt.show()\n", "metadata": {"problem_id": 582, "library_problem_id": 71, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 71}}
{"id": 583, "code": "plt.hist([x, y], bins, alpha=0.5, label=['x', 'y'])\nplt.legend()\nplt.show()\n", "metadata": {"problem_id": 583, "library_problem_id": 72, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 72}}
{"id": 584, "code": "plt.figure(figsize=(10,6))\nplt.hist([x, y], bins=5, label=['x', 'y'],\n         histtype='bar',\n         color=['blue', 'orange'],\n         stacked=True)\nplt.legend()\nplt.show()\n", "metadata": {"problem_id": 584, "library_problem_id": 73, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 72}}
{"id": 585, "code": "plt.plot([a, c], [b, d], 'r-')\nplt.xlim(0, 5)\nplt.ylim(0, 5)\nplt.show()\n", "metadata": {"problem_id": 585, "library_problem_id": 74, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 74}}
{"id": 586, "code": "fig, ax = plt.subplots(2, 1)\n\n# create a colormap\ncmap = plt.get_cmap('viridis')\n\n# create a colormap with x and y\ncmap_x = cmap(0.1)\ncmap_y = cmap(0.2)\n\n# plot x and y on the first subplot\nax[0].imshow(x, cmap=cmap_x)\nax[0].set_title('x')\n\n# plot x and y on the second subplot\nax[1].imshow(y, cmap=cmap_y)\nax[1].set_title('y')\n\n# create a colorbar for the first subplot\ncbar = plt.colorbar(plt.cm.ColorNorm(min=0.1, max=0.3), ax=ax[0])\n\n# create a colorbar for the second subplot\ncbar = plt.colorbar(plt.cm.ColorNorm(min=0.1, max=0.3), ax=ax[1])\n\nplt.show()\n", "metadata": {"problem_id": 586, "library_problem_id": 75, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 75}}
{"id": 587, "code": "plt.plot(x[:, 0], label='a')\nplt.plot(x[:, 1], label='b')\nplt.legend()\nplt.show()\n", "metadata": {"problem_id": 587, "library_problem_id": 76, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 76}}
{"id": 588, "code": "fig, axs = plt.subplots(2)\naxs[0].plot(x, y, label='Y over X')\naxs[0].set_title('Y and X')\naxs[1].plot(a, z, label='Z over A')\naxs[1].set_title('Z and A')\nplt.tight_layout()\nplt.show()\n", "metadata": {"problem_id": 588, "library_problem_id": 77, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 77}}
{"id": 589, "code": "plt.plot([x[0] for x in points], [x[1] for x in points], 'o-')\nplt.yscale('log')\nplt.show()\n", "metadata": {"problem_id": 589, "library_problem_id": 78, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 78}}
{"id": 590, "code": "plt.plot(x, y)\nplt.title('Plot of y over x', fontsize=20)\nplt.xlabel('x', fontsize=18)\nplt.ylabel('y', fontsize=16)\nplt.show()\n", "metadata": {"problem_id": 590, "library_problem_id": 79, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 79}}
{"id": 591, "code": "ax.set_xticks(x)\nax.set_yticks(y)\n", "metadata": {"problem_id": 591, "library_problem_id": 80, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 80}}
{"id": 592, "code": "plt.figure()\nfor line, color in zip(lines, c):\n    plt.plot(*line, color=color)\nplt.show()\n", "metadata": {"problem_id": 592, "library_problem_id": 81, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 81}}
{"id": 593, "code": "plt.plot(x, y)\nplt.xscale('log')\nplt.yscale('log')\nplt.xlabel('x')\nplt.ylabel('y')\nplt.title('Log-Log Plot')\nplt.grid(True)\nplt.show()\n", "metadata": {"problem_id": 593, "library_problem_id": 82, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 82}}
{"id": 594, "code": "plt.figure(figsize=(10, 5))\n\nfor column in df.columns:\n    plt.plot(df.index, df[column], label=column)\n\nplt.xlabel(\"Date\")\nplt.ylabel(\"Value\")\nplt.title(\"Line Plot of Data\")\nplt.legend(loc='best')\nplt.show()\n", "metadata": {"problem_id": 594, "library_problem_id": 83, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 83}}
{"id": 595, "code": "plt.hist(data, bins=[1000, 2000, 3000, 4000, 5000, 6000, 7000], edgecolor='black')\nplt.gca().set_ylim(0, 1)\nplt.gca().yaxis.set_major_formatter('%1.0f%%')\nplt.show()\n", "metadata": {"problem_id": 595, "library_problem_id": 84, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 84}}
{"id": 596, "code": "plt.plot(x, y, marker='o', markersize=5, markeredgecolor='r', markerfacecolor='None', markeredgecolor='None', alpha=0.5)\nplt.show()\n", "metadata": {"problem_id": 596, "library_problem_id": 85, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 85}}
{"id": 597, "code": "fig, axs = plt.subplots(2, 1, figsize=(10, 10))\n\naxs[0].plot(x, y, label='y')\naxs[0].plot(a, z, label='a')\naxs[0].legend(loc='upper right')\n\naxs[1].plot(x, y, label='y')\naxs[1].plot(a, z, label='a')\naxs[1].legend(loc='upper right')\n\nplt.tight_layout()\nplt.show()\n", "metadata": {"problem_id": 597, "library_problem_id": 86, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 86}}
{"id": 598, "code": "fig, axs = plt.subplots(2, 1, sharey=False)\nsns.regplot(x=\"bill_length_mm\", y=\"bill_depth_mm\", data=df, ax=axs[0])\nsns.regplot(x=\"bill_length_mm\", y=\"flipper_length_mm\", data=df, ax=axs[1])\nplt.tight_layout()\nplt.show()\n", "metadata": {"problem_id": 598, "library_problem_id": 87, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 87}}
{"id": 599, "code": "ax.set_xticklabels(['first', 'second', 'third', 'fourth', 'fifth', 'sixth', 'seventh', 'eighth', 'ninth', 'tenth'])\n", "metadata": {"problem_id": 599, "library_problem_id": 88, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 88}}
{"id": 600, "code": "plt.plot(x, y, label='$\\lambda$')\nplt.legend()\nplt.show()\n", "metadata": {"problem_id": 600, "library_problem_id": 89, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 89}}
{"id": 601, "code": "plt.xticks(np.arange(0, 10, 2))\n", "metadata": {"problem_id": 601, "library_problem_id": 90, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 90}}
{"id": 602, "code": "plt.xticks(rotation=-60)\nplt.tick_params(axis='x', which='both', direction='out')\n", "metadata": {"problem_id": 602, "library_problem_id": 91, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 91}}
{"id": 603, "code": "plt.gca().tick_params(axis='y', which='both', rotation=-60)\nplt.xticks(rotation='vertical')\n", "metadata": {"problem_id": 603, "library_problem_id": 92, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 91}}
{"id": 604, "code": "plt.gca().set_xticks(np.arange(2010, 2020, 2), minrotation=45)\nplt.gca().set_xticklabels(plt.gca().get_xticklabels(), rotation=45)\n", "metadata": {"problem_id": 604, "library_problem_id": 93, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 91}}
{"id": 605, "code": "plt.margins(x=0, y=0.05)\n", "metadata": {"problem_id": 605, "library_problem_id": 94, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 94}}
{"id": 606, "code": "plt.margins(x=0, y=0)\n", "metadata": {"problem_id": 606, "library_problem_id": 95, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 94}}
{"id": 607, "code": "fig, axs = plt.subplots(1, 2, figsize=(14, 7))\naxs[0].plot(x, y, label='y=x')\naxs[0].set_title('Figure 1: Subplot 1')\naxs[1].plot(x, y, label='y=x')\naxs[1].set_title('Figure 2: Subplot 2')\nfig.suptitle('Figure')\nplt.show()\n", "metadata": {"problem_id": 607, "library_problem_id": 96, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 96}}
{"id": 608, "code": "plt.figure(figsize=(10, 5))\nplt.plot(df['Type A'], marker='o', linestyle='-', label='Type A')\nplt.plot(df['Type B'], marker='o', linestyle='-', label='Type B')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.title('Line Chart of Data')\nplt.legend()\nplt.show()\n", "metadata": {"problem_id": 608, "library_problem_id": 97, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 97}}
{"id": 609, "code": "plt.scatter(x, y, marker='|', hatch='///')\nplt.show()\n", "metadata": {"problem_id": 609, "library_problem_id": 98, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 98}}
{"id": 610, "code": "plt.scatter(x, y, edgecolor='none', s=50, marker='|')\nplt.show()\n", "metadata": {"problem_id": 610, "library_problem_id": 99, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 98}}
{"id": 611, "code": "plt.scatter(x, y, marker='*', hatch='//')\nplt.show()\n", "metadata": {"problem_id": 611, "library_problem_id": 100, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 98}}
{"id": 612, "code": "plt.scatter(x, y, marker='*', s=100, hatch='v')\nplt.show()\n", "metadata": {"problem_id": 612, "library_problem_id": 101, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 98}}
{"id": 613, "code": "plt.xlim(0, 5)\nplt.ylim(0, 4)\nplt.imshow(data, extent=(1, 4, 1, 4), origin='lower', aspect='auto')\nplt.show()\n", "metadata": {"problem_id": 613, "library_problem_id": 102, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 102}}
{"id": 614, "code": "plt.stem(y, x, orientation='horizontal')\n", "metadata": {"problem_id": 614, "library_problem_id": 103, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 103}}
{"id": 615, "code": "plt.bar(d.keys(), d.values(), color=[c[key] for key in d.keys()])\nplt.show()\n", "metadata": {"problem_id": 615, "library_problem_id": 104, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 104}}
{"id": 616, "code": "plt.axvline(x=3, color='r', linestyle='--', label='cutoff')\nplt.legend()\nplt.show()\n", "metadata": {"problem_id": 616, "library_problem_id": 105, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 105}}
{"id": 617, "code": "plt.figure(figsize=(10, 10))\nplt.pie(height, labels=labels, autopct='%1.1f%%', startangle=140, shadow=True)\nplt.axis('equal')\nplt.show()\n", "metadata": {"problem_id": 617, "library_problem_id": 106, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 106}}
{"id": 618, "code": "plt.pie(data, labels=l, wedgeprops={'width' : 0.4})\nplt.show()\n", "metadata": {"problem_id": 618, "library_problem_id": 107, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 107}}
{"id": 619, "code": "plt.plot(x, y, 'b--')\nplt.show()\n", "metadata": {"problem_id": 619, "library_problem_id": 108, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 108}}
{"id": 620, "code": "plt.plot(x, y)\nplt.minorticks_on()\nplt.grid(which='minor', linestyle=':', linewidth='0.5', color='gray')\nplt.grid(which='major', linestyle='-', linewidth='0.5', color='black')\nplt.show()\n", "metadata": {"problem_id": 620, "library_problem_id": 109, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 109}}
{"id": 621, "code": "plt.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=140)\nplt.axis('equal')\nplt.legend(labels, loc='upper right')\nplt.show()\n", "metadata": {"problem_id": 621, "library_problem_id": 110, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 110}}
{"id": 622, "code": "plt.pie(sizes, labels=labels, colors=colors, autopct='%1.1f%%', startangle=140)\nplt.axis('equal')\nplt.legend(labels, loc='upper right')\nplt.show()\n", "metadata": {"problem_id": 622, "library_problem_id": 111, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 111}}
{"id": 623, "code": "plt.plot(x, y, 'r--o')\nplt.show()\n", "metadata": {"problem_id": 623, "library_problem_id": 112, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 112}}
{"id": 624, "code": "plt.axvline(55, color='green')\n", "metadata": {"problem_id": 624, "library_problem_id": 113, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 113}}
{"id": 625, "code": "plt.bar(np.arange(len(blue_bar)), blue_bar, color='b', align='center')\nplt.bar(np.arange(len(blue_bar)), orange_bar, color='orange', align='center')\n\n# Set the x-ticks\nplt.xticks(np.arange(len(blue_bar)), ('G1', 'G2', 'G3'))\n\n# Set the labels\nplt.xlabel('Groups')\nplt.ylabel('Scores')\nplt.title('Scores by group and gender')\n\n# Show the plot\nplt.show()\n", "metadata": {"problem_id": 625, "library_problem_id": 114, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 114}}
{"id": 626, "code": "fig, axs = plt.subplots(2)\naxs[0].plot(x, y, label='Line 1')\naxs[0].set_title('Line 1')\naxs[0].legend()\naxs[1].plot(a, z, label='Line 2')\naxs[1].set_title('Line 2')\naxs[1].legend()\nplt.tight_layout()\nplt.show()\n", "metadata": {"problem_id": 626, "library_problem_id": 115, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 115}}
{"id": 627, "code": "plt.scatter(x, y, c=y, cmap='Spectral')\nplt.show()\n", "metadata": {"problem_id": 627, "library_problem_id": 116, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 116}}
{"id": 628, "code": "plt.plot(x, y)\nplt.xticks(np.arange(0, max(x)+1, 1))\nplt.show()\n", "metadata": {"problem_id": 628, "library_problem_id": 117, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 117}}
{"id": 629, "code": "sns.catplot(x=\"bill_length_mm\", y=\"species\", hue=\"sex\", data=df, height=5, aspect=0.9, kind=\"bar\", col=\"species\")\nplt.show()\n", "metadata": {"problem_id": 629, "library_problem_id": 118, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 118}}
{"id": 630, "code": "plt.gca().add_patch(plt.Circle((0.5, 0.5), 0.2, fill=False, color='red'))\nplt.show()\n", "metadata": {"problem_id": 630, "library_problem_id": 119, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 119}}
{"id": 631, "code": "plt.plot(x, y)\nplt.title(r'$\\phi$', fontsize=16, fontweight='bold')\nplt.show()\n", "metadata": {"problem_id": 631, "library_problem_id": 120, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 120}}
{"id": 632, "code": "plt.plot(x, y, label='Line')\nplt.legend(labelspacing=0.1)\nplt.show()\n", "metadata": {"problem_id": 632, "library_problem_id": 121, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 121}}
{"id": 633, "code": "plt.plot(x, y, label='Line')\nplt.legend(loc='center left', bbox_to_anchor=(0.3, 0.5), prop={'size': 8})\nplt.show()\n", "metadata": {"problem_id": 633, "library_problem_id": 122, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 121}}
{"id": 634, "code": "plt.legend(loc='upper center', bbox_to_anchor=(0.5, 1.05), fancybox=True, ncol=3)\n", "metadata": {"problem_id": 634, "library_problem_id": 123, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 121}}
{"id": 635, "code": "plt.legend(loc='best')\nplt.show()\n", "metadata": {"problem_id": 635, "library_problem_id": 124, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 121}}
{"id": 636, "code": "plt.imshow(data, cmap='hot', interpolation='nearest')\nplt.colorbar()\nplt.show()\n", "metadata": {"problem_id": 636, "library_problem_id": 125, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 125}}
{"id": 637, "code": "plt.figure(1)\nplt.plot(x, y)\nplt.title(r\"$\\bf{Figure} \\bf{1}$\", fontsize=10, fontweight=\"bold\")\nplt.show()\n", "metadata": {"problem_id": 637, "library_problem_id": 126, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 126}}
{"id": 638, "code": "sns.pairplot(df, x_vars=\"x\", y_vars=\"y\", hue=\"id\")\nplt.show()\n", "metadata": {"problem_id": 638, "library_problem_id": 127, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 127}}
{"id": 639, "code": "plt.plot(x, y)\nplt.gca().invert_xaxis()\nplt.show()\n", "metadata": {"problem_id": 639, "library_problem_id": 128, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 128}}
{"id": 640, "code": "plt.scatter(x, y, clip_on=False)\nplt.xlim(0, 10)\nplt.ylim(0, 10)\nplt.show()\n", "metadata": {"problem_id": 640, "library_problem_id": 129, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 129}}
{"id": 641, "code": "plt.scatter(x, y, c='red', s=50)\nplt.show()\n", "metadata": {"problem_id": 641, "library_problem_id": 130, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 130}}
{"id": 642, "code": "plt.figure(figsize=(15, 15))\nplt.subplot(2, 2, 1)\nplt.plot(x, y, 'r')\nplt.subplot(2, 2, 2)\nplt.plot(x, y, 'g')\nplt.subplot(2, 2, 3)\nplt.plot(x, y, 'b')\nplt.subplot(2, 2, 4)\nplt.plot(x, y, 'y')\nplt.show()\n", "metadata": {"problem_id": 642, "library_problem_id": 131, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 131}}
{"id": 643, "code": "plt.hist(x, bins=np.arange(0, 11, 2), edgecolor='black')\nplt.show()\n", "metadata": {"problem_id": 643, "library_problem_id": 132, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 132}}
{"id": 644, "code": "plt.figure(figsize=(10, 6))\nplt.errorbar(x, y, yerr=error, fmt='o', capsize=5)\nplt.show()\n", "metadata": {"problem_id": 644, "library_problem_id": 133, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 133}}
{"id": 645, "code": "plt.plot([0, 0], [0, -1], 'w-')\nplt.plot([0, 1], [0, 0], 'w-')\n", "metadata": {"problem_id": 645, "library_problem_id": 134, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 134}}
{"id": 646, "code": "ax.errorbar(box_position, box_height, yerr=box_errors, fmt='o', color='red')\n", "metadata": {"problem_id": 646, "library_problem_id": 135, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 135}}
{"id": 647, "code": "fig, axs = plt.subplots(2, 1, figsize=(10, 10))\naxs[0].plot(x, y, label='Y')\naxs[0].set_title('Y')\naxs[1].plot(z, a, label='Z')\naxs[1].set_title('Z')\nplt.tight_layout()\nplt.show()\n", "metadata": {"problem_id": 647, "library_problem_id": 136, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 136}}
{"id": 648, "code": "fig, axs = plt.subplots(4, 4, figsize=(5, 5))\n\nfor ax in axs.flatten():\n    ax.plot(x, y)\n    ax.set_xticks([])\n    ax.set_yticks([])\n\nplt.tight_layout()\nplt.show()\n", "metadata": {"problem_id": 648, "library_problem_id": 137, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 137}}
{"id": 649, "code": "plt.matshow(d, fmticon=True)\nplt.colorbar()\nplt.title('Random 10x10 Matrix')\nplt.show()\n", "metadata": {"problem_id": 649, "library_problem_id": 138, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 138}}
{"id": 650, "code": "plt.figure(figsize=(10, 10))\nsns.heatmap(df, cmap=\"viridis\", cbar=False, annot=True, fmt=\".2f\")\nplt.title(\"Penguins Data\")\nplt.show()\n", "metadata": {"problem_id": 650, "library_problem_id": 139, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 139}}
{"id": 651, "code": "plt.plot(x, y)\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.title('Line Chart')\nplt.show()\n", "metadata": {"problem_id": 651, "library_problem_id": 140, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 140}}
{"id": 652, "code": "plt.plot(x, y)\nplt.xticks(x)\nplt.yticks(y)\nplt.show()\n", "metadata": {"problem_id": 652, "library_problem_id": 141, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 140}}
{"id": 653, "code": "plt.plot(x, y)\nplt.xticks(x, rotation=90)\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.show()\n", "metadata": {"problem_id": 653, "library_problem_id": 142, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 140}}
{"id": 654, "code": "plt.figure(figsize=(10,6))\nsns.catplot(x=\"time\", y=\"pulse\", hue=\"kind\", col=\"diet\", data=df, height=5, aspect=0.9, kind=\"point\")\nplt.suptitle('Group: Fat vs No Fat', fontsize=15)\nplt.show()\n", "metadata": {"problem_id": 654, "library_problem_id": 143, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 143}}
{"id": 655, "code": "plt.figure(figsize=(10,6))\nsns.catplot(x=\"time\", y=\"pulse\", hue=\"kind\", col=\"diet\", data=df, height=5, aspect=.7)\nplt.xticks(rotation=90)\nplt.xlabel(\"Exercise Time\")\nplt.ylabel(\"Pulse\")\nplt.title(\"Exercise Time vs Pulse by Kind and Diet\")\nplt.show()\n", "metadata": {"problem_id": 655, "library_problem_id": 144, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 143}}
{"id": 656, "code": "plt.figure(figsize=(10, 6))\n\nplt.subplot(1, 2, 1)\nsns.scatterplot(x=\"time\", y=\"pulse\", hue=\"kind\", col=\"diet\", data=df)\nplt.ylabel('Pulse')\nplt.title('Time vs Pulse')\nplt.legend(title='Exercise')\n\nplt.subplot(1, 2, 2)\nsns.scatterplot(x=\"time\", y=\"pulse\", hue=\"kind\", col=\"diet\", data=df)\nplt.ylabel('Pulse')\nplt.title('Time vs Pulse')\nplt.legend(title='Exercise')\n\nplt.tight_layout()\nplt.show()\n", "metadata": {"problem_id": 656, "library_problem_id": 145, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 143}}
{"id": 657, "code": "plt.plot(x, y, label='y')\nplt.legend(fontsize=8)\nplt.show()\n", "metadata": {"problem_id": 657, "library_problem_id": 146, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 146}}
{"id": 658, "code": "plt.figure(figsize=(5, 5), dpi=300)\nplt.plot(x, y)\nplt.show()\n", "metadata": {"problem_id": 658, "library_problem_id": 147, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 147}}
{"id": 659, "code": "plt.plot(x, y, label='y')\nplt.legend(loc='best', fancybox=True, framealpha=1)\nplt.show()\n", "metadata": {"problem_id": 659, "library_problem_id": 148, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 148}}
{"id": 660, "code": "fig, ax = plt.subplots()\nax.plot(t, a, label='sin(t)')\nax.plot(t, b, label='cos(t)')\nax.plot(t, c, label='sin(t) + cos(t)')\nax.legend()\nplt.show()\n", "metadata": {"problem_id": 660, "library_problem_id": 149, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 149}}
{"id": 661, "code": "plt.figure(figsize=(8,6))\nsns.stripplot(x=\"sex\", y=\"bill_length_mm\", hue=\"species\", data=df, jitter=True, palette=\"deep\")\nplt.title(\"Bill Length by Sex and Species\")\nplt.xlabel(\"Sex\")\nplt.ylabel(\"Bill Length (mm)\")\nplt.legend(title=\"Species\", loc=\"upper right\")\nplt.show()\n", "metadata": {"problem_id": 661, "library_problem_id": 150, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 150}}
{"id": 662, "code": "fig, axes = plt.subplots(2, 1, figsize=(10, 10))\ng = sns.FacetGrid(df, row=\"b\", hue=\"b\", sharex=False, sharey=False)\ng.map(sns.pointplot, \"a\", \"c\", order=df[\"a\"].sort_values().unique(), palette=\"viridis\")\ng.add_legend()\n\n# Set xticks\nax = g.axes_grid[0, 0]\nax.set_xticks(ax.get_xticks()[::2])\nax.set_xticklabels(ax.get_xticklabels()[::2])\n\nplt.tight_layout()\nplt.show()\n", "metadata": {"problem_id": 662, "library_problem_id": 151, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 151}}
{"id": 663, "code": "fig = plt.figure(figsize=(10, 7))\nax = fig.add_subplot(111, projection='3d')\nax.scatter(x, y, z)\nax.view_init(elev=30, azim=60)\nplt.show()\n", "metadata": {"problem_id": 663, "library_problem_id": 152, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 152}}
{"id": 664, "code": "plt.plot(x, y)\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.xticks([])\nplt.yticks([])\nplt.show()\n", "metadata": {"problem_id": 664, "library_problem_id": 153, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 153}}
{"id": 665, "code": "gs = gridspec.GridSpec(nrow, ncol, width_ratios=[0, 1], height_ratios=[0, 1])\naxes = []\nfor i in range(nrow * ncol):\n    ax = fig.add_subplot(gs[i])\n    ax.axis('off')\n    axes.append(ax)\n\nfor ax in axes:\n    ax.imshow(x[i], cmap='gray')\n", "metadata": {"problem_id": 665, "library_problem_id": 154, "library": "Matplotlib", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 154}}
{"id": 666, "code": "\n# create a session to run the operations\nwith tf.Session() as sess:\n    # initialize all variables\n    sess.run(tf.global_variables_initializer())\n    \n    # update the value of x\n    sess.run(tf.assign(x, 1))\n    \n    # print the updated value of x\n    print(sess.run(x))\n", "metadata": {"problem_id": 666, "library_problem_id": 0, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 0}}
{"id": 667, "code": "\n# create a session to run the operations\nwith tf.Session() as sess:\n    # initialize all variables\n    sess.run(tf.global_variables_initializer())\n    \n    # update the value of x\n    sess.run(tf.assign(x, 114514))\n    \n    # print the updated value of x\n    print(sess.run(x))\n", "metadata": {"problem_id": 667, "library_problem_id": 1, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 0}}
{"id": 668, "code": "\nnum_classes = 10\nnum_samples = len(labels)\n\n# Create a tensor of zeros with the same shape as the labels\nresult = tf.zeros((num_samples, num_classes), dtype=tf.int32)\n\n# Fill the tensor with the corresponding labels\nfor i, label in enumerate(labels):\n    result[i, label] = 1\n", "metadata": {"problem_id": 668, "library_problem_id": 2, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 2}}
{"id": 669, "code": "\nnum_classes = 10\nnum_samples = len(labels)\n\n# Create a tensor of zeros with the same shape as the labels\nresult = tf.zeros((num_samples, num_classes), dtype=tf.int32)\n\n# Fill the tensor with the corresponding labels\nfor i, label in enumerate(labels):\n    result[i, label] = 1\n", "metadata": {"problem_id": 669, "library_problem_id": 3, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 2}}
{"id": 670, "code": "\nnum_classes = 10\nnum_samples = len(labels)\n\n# Create a tensor of zeros with the same shape as the labels\nresult = tf.zeros((num_samples, num_classes), dtype=tf.int32)\n\n# Fill the tensor with the corresponding labels\nfor i, label in enumerate(labels):\n    result[i, label] = 1\n", "metadata": {"problem_id": 670, "library_problem_id": 4, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 2}}
{"id": 671, "code": "\n    result = tf.one_hot(labels, depth=10, dtype=tf.int32)\n    return result\n    ### END SOLUTION\n\nprint(f())\n", "metadata": {"problem_id": 671, "library_problem_id": 5, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 2}}
{"id": 672, "code": "\nnum_classes = 10\nnum_samples = len(labels)\n\n# Create a tensor of ones with the same shape as the labels\nones_tensor = tf.ones((num_samples, num_classes))\n\n# Create a tensor of zeros with the same shape as the labels\nzeros_tensor = tf.zeros((num_samples, num_classes))\n\n# Create a tensor of ones at the indices specified by the labels\nresult = tf.tensor_scatter_nd_update(ones_tensor, tf.constant(labels), 1)\n\n# Subtract the ones tensor from the zeros tensor\nresult = zeros_tensor - result\n\n# Add 1 to the result to get the class indices\nresult = tf.cast(result + 1, tf.int32)\n\nprint(result)\n", "metadata": {"problem_id": 672, "library_problem_id": 6, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 2}}
{"id": 673, "code": "\ndef my_map_func(i):\n  return [i, i+1, i+2]\n\nds = tf.data.Dataset.from_tensor_slices(input)\nds = ds.map(map_func=lambda input: tf.py_function(\n  func=my_map_func, inp=[input], Tout=(tf.int32, tf.int32, tf.int32)\n))\nds = ds.unbatch()\n\nelement = tf.compat.v1.data.make_one_shot_iterator(ds).get_next()\nresult = []\nwith tf.compat.v1.Session() as sess:\n  for _ in range(9):\n    result.append(sess.run(element))\nprint(result)\n", "metadata": {"problem_id": 673, "library_problem_id": 7, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 7}}
{"id": 674, "code": "\n    return [i for sublist in input for i in sublist]\n    ### END SOLUTION\n\nds = tf.data.Dataset.from_tensor_slices(example_input)\nds = ds.map(map_func=lambda input: tf.py_function(\n  func=f, inp=[input], Tout=[tf.int64]\n))\nelement = tf.compat.v1.data.make_one_shot_iterator(ds).get_next()\nresult = []\nwith tf.compat.v1.Session() as sess:\n  for _ in range(9):\n    result.append(sess.run(element))\nprint(result)\n", "metadata": {"problem_id": 674, "library_problem_id": 8, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 7}}
{"id": 675, "code": "\n# Create a tensor of zeros with the same shape as the lengths tensor\nmask = tf.sequence.fill_length_range(tf.constant(8)) - tf.sequence.lengths_adjust(tf.constant(lengths), tf.constant(1))\n\n# Convert the mask to a boolean tensor\nmask = tf.cast(mask >= 0, tf.int32)\n\n# Reverse the mask\nmask = tf.reverse(mask, [0])\n\n# Expand the dimensions of the mask\nmask = tf.expand_dims(mask, 0)\n\nresult = mask\n", "metadata": {"problem_id": 675, "library_problem_id": 9, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 9}}
{"id": 676, "code": "\n# Create a tensor of zeros with the same shape as the lengths tensor\nmask = tf.sequence_mask(lengths, 8, dtype=tf.int32)\n\n# Reverse the mask to get the desired output\nmask = tf.math.logical_not(mask)\n\n# Convert the mask to int32\nmask = tf.cast(mask, tf.int32)\n\nresult = mask\n", "metadata": {"problem_id": 676, "library_problem_id": 10, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 9}}
{"id": 677, "code": "\n# Create a tensor of zeros with the same shape as the lengths tensor\nmask = tf.sequence.fill_length_tensor(lengths, 8)\n\n# Create a mask where the length of the sequence is less than the length of the sequence in the lengths tensor\nmask = tf.sequence.mask(mask, lengths)\n\n# Convert the mask to a tensor of 1s and 0s\nmask = tf.cast(mask, tf.int32)\n\nresult = mask\n", "metadata": {"problem_id": 677, "library_problem_id": 11, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 9}}
{"id": 678, "code": "\n    max_length = tf.constant(8)\n    mask = tf.sequence_mask(lengths, max_length, dtype=tf.int32)\n    result = tf.cast(mask, tf.int32)\n    return result\n    ### END SOLUTION\n\nprint(f(example_lengths))\n", "metadata": {"problem_id": 678, "library_problem_id": 12, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 9}}
{"id": 679, "code": "\nmax_length = 8\nmask = tf.sequence_mask(lengths, max_length, dtype=tf.float32)\nmask = tf.cast(mask, tf.float32)\nmask = tf.math.subtract(1, mask)\nresult = tf.cast(mask, tf.float32)\nresult = tf.pad(result, [[0, 0], [1, 0]], 'CONSTANT')\nresult = tf.reduce_sum(result, axis=0)\nprint(result)\n", "metadata": {"problem_id": 679, "library_problem_id": 13, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 9}}
{"id": 680, "code": "cartesian_product = tf.expand_dims(a, 1) * tf.expand_dims(b, 0)\nresult = tf.reshape(cartesian_product, [-1, 2])\nprint(result)\n", "metadata": {"problem_id": 680, "library_problem_id": 14, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 14}}
{"id": 681, "code": "\n    cartesian_product = tf.expand_dims(a, 1) * tf.expand_dims(b, 0)\n    result = tf.concat(cartesian_product, axis=1)\n    return result\n    ### END SOLUTION\n\nprint(f(example_a, example_b))\n", "metadata": {"problem_id": 681, "library_problem_id": 15, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 14}}
{"id": 682, "code": "result = tf.squeeze(a, [2])", "metadata": {"problem_id": 682, "library_problem_id": 16, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 16}}
{"id": 683, "code": "\nresult = tf.expand_dims(a, axis=2)\n", "metadata": {"problem_id": 683, "library_problem_id": 17, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 16}}
{"id": 684, "code": "\n# Reshape the tensor\nresult = tf.reshape(a, (1, 50, 100, 1, 512))\n\n# Alternatively, you can use tf.expand_dims to add new dimensions\n# result = tf.expand_dims(a, axis=1)\n# result = tf.expand_dims(result, axis=3)\n# result = tf.expand_dims(result, axis=4)\n\nprint(result)\n", "metadata": {"problem_id": 684, "library_problem_id": 18, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 16}}
{"id": 685, "code": "result = tf.reduce_sum(A, axis=1)\nprint(result)\n", "metadata": {"problem_id": 685, "library_problem_id": 19, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 19}}
{"id": 686, "code": "result = tf.reduce_prod(A, axis=1)\nprint(result)\n", "metadata": {"problem_id": 686, "library_problem_id": 20, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 19}}
{"id": 687, "code": "result = tf.math.reciprocal(A)\n", "metadata": {"problem_id": 687, "library_problem_id": 21, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 19}}
{"id": 688, "code": "\n# Calculate the L2 distance\ndistance = tf.square(tf.subtract(a, b))\n\n# Reduce by row\nresult = tf.reduce_sum(distance, axis=0)\n\nprint(result)\n", "metadata": {"problem_id": 688, "library_problem_id": 22, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 22}}
{"id": 689, "code": "\n# Calculate the L2 distance\ndistance = tf.square(tf.subtract(a, b))\n\n# Reduce the distance by column\nresult = tf.reduce_sum(distance, axis=0)\n\nprint(result)\n", "metadata": {"problem_id": 689, "library_problem_id": 23, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 22}}
{"id": 690, "code": "\n    return tf.reduce_sum(tf.square(tf.sub(A, B)), axis=0)\n    ### END SOLUTION\n\nprint(f(example_a, example_b).numpy())\n", "metadata": {"problem_id": 690, "library_problem_id": 24, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 22}}
{"id": 691, "code": "\nm = tf.gather_nd(x, tf.stack([y, z]))\n\nresult = m.numpy()\n\nprint(result)\n", "metadata": {"problem_id": 691, "library_problem_id": 25, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 25}}
{"id": 692, "code": "m = tf.gather_nd(x, tf.stack([row, col], axis=1))\nresult = m.numpy()\n", "metadata": {"problem_id": 692, "library_problem_id": 26, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 25}}
{"id": 693, "code": "\n    return tf.gather_nd(x, tf.stack([y, z]))\n    ### END SOLUTION\n\nresult = f(example_x, example_y, example_z)\nprint(result)\n", "metadata": {"problem_id": 693, "library_problem_id": 27, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 25}}
{"id": 694, "code": "\n# reshape A and B to match the shape of the dot product\nA = tf.reshape(A, [10, 20, 30, 1])\nB = tf.reshape(B, [10, 20, 30, 1])\n\n# perform the dot product\nresult = tf.einsum('ijkl->ijk', A, B)\n\n# remove the extra dimension\nresult = tf.squeeze(result, [2])\n\nprint(result)\n", "metadata": {"problem_id": 694, "library_problem_id": 28, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 28}}
{"id": 695, "code": "\nresult = tf.einsum('ijk,ilk->ijl', A, B)\n\nprint(result)\n", "metadata": {"problem_id": 695, "library_problem_id": 29, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 28}}
{"id": 696, "code": "\n# Convert bytes to string\nx = [tf.strings.unicode_transcode(byte, \"UTF-8\") for byte in x]\n\n# Convert list of bytes to list of strings\nresult = tf.strings.unicode_transcode(tf.concat(x, axis=0), \"UTF-8\")\n", "metadata": {"problem_id": 696, "library_problem_id": 30, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 30}}
{"id": 697, "code": "\n    return [tf.strings.unicode_transcode(b, \"UTF-8\") for b in x]\n    ### END SOLUTION\n\nprint(f())\n", "metadata": {"problem_id": 697, "library_problem_id": 31, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 30}}
{"id": 698, "code": "\n# Get the sum of non-zero entries in the second to last dimension\nsum_2nd_last_dim = tf.reduce_sum(x, axis=-2, keepdims=True)\n\n# Get the count of non-zero entries in the second to last dimension\ncount_2nd_last_dim = tf.reduce_sum(tf.cast(tf.not_equal(x, 0), tf.float32), axis=-2, keepdims=True)\n\n# Average the second to last dimension\nresult = tf.divide(tf.reduce_sum(x, axis=-2), tf.maximum(count_2nd_last_dim, tf.constant(1.)))\n", "metadata": {"problem_id": 698, "library_problem_id": 32, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 32}}
{"id": 699, "code": "mask = tf.cast(tf.math.reduce_any(x, axis=-1), tf.float32)\nresult = (tf.reduce_sum(x, axis=-1) - mask * tf.cast(x, tf.float32)) / (tf.cast(1.0 - mask, tf.float32) - mask)\nresult = tf.where(tf.math.equal(mask, 0), tf.zeros_like(result), result)\n", "metadata": {"problem_id": 699, "library_problem_id": 33, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 32}}
{"id": 700, "code": "\n    mask = tf.cast(tf.math.reduce_any(x, axis=-1), tf.float32)\n    return tf.reduce_sum(x, axis=-1) / mask\n    ### END SOLUTION\n\nprint(f(example_x).numpy())\n", "metadata": {"problem_id": 700, "library_problem_id": 34, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 32}}
{"id": 701, "code": "\ntry:\n    Session = tf.compat.v1.Session\nexcept AttributeError:\n    Session = tf.Session\n\ntf.random.set_seed(10)\nA = tf.random.normal([100,100])\nB = tf.random.normal([100,100])\n\nwith Session() as sess:\n    result = sess.run(tf.reduce_sum(tf.matmul(A,B)))\n\n", "metadata": {"problem_id": 701, "library_problem_id": 35, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 35}}
{"id": 702, "code": "\n# Get the indices of the maximum values along the last dimension\nindices = tf.argmax(a, axis=-1)\n\n# Convert the indices to one-hot encoding\nresult = tf.one_hot(indices, depth=10)\n\nprint(result)\n", "metadata": {"problem_id": 702, "library_problem_id": 36, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 36}}
{"id": 703, "code": "\n# Get the indices of the maximum values along the last dimension\nindices = tf.argmax(a, axis=-1)\n\n# Convert the indices to one-hot encoding\nresult = tf.one_hot(indices, depth=6)\n\nprint(result)\n", "metadata": {"problem_id": 703, "library_problem_id": 37, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 36}}
{"id": 704, "code": "\n    max_indices = tf.argmax(a, axis=1)\n    result = tf.reduce_sum(tf.one_hot(max_indices, max_indices.shape[-1]), axis=1)\n    ### END SOLUTION\n    return result\n\nprint(f(example_a).numpy())\n", "metadata": {"problem_id": 704, "library_problem_id": 38, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 36}}
{"id": 705, "code": "\nresult = tf.argmin(a, axis=1) + 1\nprint(result)\n", "metadata": {"problem_id": 705, "library_problem_id": 39, "library": "Tensorflow", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 36}}
{"id": 706, "code": "\nmodel.save('export/1')\n", "metadata": {"problem_id": 706, "library_problem_id": 40, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 40}}
{"id": 707, "code": "\ntf.random.set_seed(seed_x)\nresult = tf.random.uniform(shape=[10], minval=1, maxval=4, dtype=tf.int32)\n", "metadata": {"problem_id": 707, "library_problem_id": 41, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 41}}
{"id": 708, "code": "\ntf.random.set_seed(seed_x)\nresult = tf.random.uniform(shape=[114], minval=2, maxval=5, dtype=tf.int32)\n", "metadata": {"problem_id": 708, "library_problem_id": 42, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 41}}
{"id": 709, "code": "\n    tf.random.set_seed(seed_x)\n    random_integers = tf.random.uniform(shape=[10], minval=1, maxval=4, dtype=tf.int32)\n    return random_integers\n    ### END SOLUTION\n\nprint(f())\n", "metadata": {"problem_id": 709, "library_problem_id": 43, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 41}}
{"id": 710, "code": "\nimport tensorflow as tf\n\nresult = tf.__version__\nprint(result)\n", "metadata": {"problem_id": 710, "library_problem_id": 44, "library": "Tensorflow", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 44}}
{"id": 711, "code": "coeff = np.polyfit(np.log(x), y, 1)\nresult = np.array([np.exp(coeff[1]), coeff[0]])\nprint(result)\n", "metadata": {"problem_id": 711, "library_problem_id": 0, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 0}}
{"id": 712, "code": "coeff = np.polyfit(x, y, 2)\nresult = np.poly1d(coeff)\n", "metadata": {"problem_id": 712, "library_problem_id": 1, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 0}}
{"id": 713, "code": "def func(x, a, b, c):\n    return a * np.exp(b * x) + c\n\nresult, _ = scipy.optimize.curve_fit(func, x, y, p0)\n", "metadata": {"problem_id": 713, "library_problem_id": 2, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 0}}
{"id": 714, "code": "statistic, p_value = stats.ks_2samp(x, y)\n", "metadata": {"problem_id": 714, "library_problem_id": 3, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 3}}
{"id": 715, "code": "test_stat = stats.ks_2samp(x, y)\np_value = test_stat.pvalue\nresult = p_value < alpha\n", "metadata": {"problem_id": 715, "library_problem_id": 4, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 3}}
{"id": 716, "code": "def f(x):\n    a, b, c = x\n    return ((a+b-c)-2)**2 + ((3*a-b-c))**2 + sin(b) + cos(b) + 4\n\nresult = optimize.minimize(f, initial_guess)\nprint(result.x)\n", "metadata": {"problem_id": 716, "library_problem_id": 5, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 5}}
{"id": 717, "code": "p_values = scipy.stats.norm.sf(abs(z_scores)) * 2\n", "metadata": {"problem_id": 717, "library_problem_id": 6, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 6}}
{"id": 718, "code": "z_scores = (z_scores - mu) / sigma\np_values = [2 * (1 - scipy.stats.norm.cdf(z)) for z in z_scores]\n", "metadata": {"problem_id": 718, "library_problem_id": 7, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 6}}
{"id": 719, "code": "z_scores = [(p - 0.5) * np.sqrt((p * (1 - p)) / np.sum(p)) for p in p_values]", "metadata": {"problem_id": 719, "library_problem_id": 8, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 6}}
{"id": 720, "code": "dist = stats.lognorm([mu],loc=stddev)\nresult = dist.cdf(x)", "metadata": {"problem_id": 720, "library_problem_id": 9, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 9}}
{"id": 721, "code": "dist = lognorm([stddev, mu])\nexpected_value = dist.mean()\nmedian = dist.median()\n", "metadata": {"problem_id": 721, "library_problem_id": 10, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 9}}
{"id": 722, "code": "result = sa.multiply(sb)", "metadata": {"problem_id": 722, "library_problem_id": 11, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 11}}
{"id": 723, "code": "\n    return sA.dot(sB)\n    ### END SOLUTION\n\nprint(f())\n", "metadata": {"problem_id": 723, "library_problem_id": 12, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 11}}
{"id": 724, "code": "\n# Create a grid from the points\nx, y, z = np.mgrid[points[:, 0].min():points[:, 0].max():100j,\n                   points[:, 1].min():points[:, 1].max():100j,\n                   points[:, 2].min():points[:, 2].max():100j]\n\n# Interpolate the moisture V at the grid points\ninterp = scipy.interpolate.griddata(points[:, :3], V, (x, y, z), method='linear')\n\n# Interpolate the moisture V at the requested point\nresult = interp(request[0, :3])\n\nprint(result)\n", "metadata": {"problem_id": 724, "library_problem_id": 13, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 13}}
{"id": 725, "code": "interp = scipy.interpolate.LinearNDInterpolator(points, V)\nresult = interp(request)\nprint(result)\n", "metadata": {"problem_id": 725, "library_problem_id": 14, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 13}}
{"id": 726, "code": "data_rot = rotate(data_orig, angle, mode='reflect')\nxrot, yrot = np.array(data_rot.shape) / 2, np.array(data_rot.shape) / 2\n", "metadata": {"problem_id": 726, "library_problem_id": 15, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 15}}
{"id": 727, "code": "\n# Extract the main diagonal\nresult = M.diagonal()\n\nprint(result.toarray())\n", "metadata": {"problem_id": 727, "library_problem_id": 16, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 16}}
{"id": 728, "code": "result = stats.kstest(times, \"uniform\")\nprint(result)", "metadata": {"problem_id": 728, "library_problem_id": 17, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 17}}
{"id": 729, "code": "\n    statistic, pvalue = stats.kstest(times, 'uniform')\n    return pvalue\n    ### END SOLUTION\nf()\n", "metadata": {"problem_id": 729, "library_problem_id": 18, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 17}}
{"id": 730, "code": "ks_result = stats.kstest(times, 'uniform')\nresult = ks_result.pvalue < 0.05\n", "metadata": {"problem_id": 730, "library_problem_id": 19, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 17}}
{"id": 731, "code": "Feature = sparse.vstack([c1, c2])", "metadata": {"problem_id": 731, "library_problem_id": 20, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 20}}
{"id": 732, "code": "Feature = sparse.vstack([c1, c2])", "metadata": {"problem_id": 732, "library_problem_id": 21, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 20}}
{"id": 733, "code": "Feature = sparse.vstack([c1, c2])", "metadata": {"problem_id": 733, "library_problem_id": 22, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 20}}
{"id": 734, "code": "dist_matrix = scipy.spatial.distance.cdist(points1, points2)\nresult = scipy.optimize.linear_sum_assignment(dist_matrix)\n", "metadata": {"problem_id": 734, "library_problem_id": 23, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 23}}
{"id": 735, "code": "dist_matrix = scipy.spatial.distance.cdist(points1, points2)\nresult = scipy.optimize.linear_sum_assignment(dist_matrix)\n", "metadata": {"problem_id": 735, "library_problem_id": 24, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 23}}
{"id": 736, "code": "b.data[:] = 0\n", "metadata": {"problem_id": 736, "library_problem_id": 25, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 25}}
{"id": 737, "code": "labels, num_labels = ndimage.label(img > threshold)\nresult = num_labels\n", "metadata": {"problem_id": 737, "library_problem_id": 26, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 26}}
{"id": 738, "code": "labels, num_labels = ndimage.label(img < threshold)\nresult = num_labels\n", "metadata": {"problem_id": 738, "library_problem_id": 27, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 26}}
{"id": 739, "code": "\n    labels, num_labels = ndimage.label(img > threshold)\n    return num_labels\n    ### END SOLUTION\n", "metadata": {"problem_id": 739, "library_problem_id": 28, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 26}}
{"id": 740, "code": "\n# Find the regions of cells which value exceeds a given threshold\nmask = img > threshold\n\n# Find the coordinates of the regions\ncoords = np.argwhere(mask)\n\n# Calculate the center of mass for each region\ncenters = [np.mean(coords[mask == i], axis=0) for i in range(np.max(mask) + 1)]\n\n# Calculate the distance between the center of mass and the top left corner\ndistances = [np.linalg.norm(np.array(centers[i]) - np.array((0, 0))) for i in range(len(centers))]\n\nresult = distances\n", "metadata": {"problem_id": 740, "library_problem_id": 29, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 26}}
{"id": 741, "code": "M = (M + M.T)/2\nM = M + M.T - np.diag(M.diagonal())\nM = sparse.csr_matrix(M)\n", "metadata": {"problem_id": 741, "library_problem_id": 30, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 30}}
{"id": 742, "code": "\n    sA = (sA + sA.T)/2\n    sA = sA + sA.T - np.diag(sA.diagonal())\n    ### END SOLUTION\n    return sA\n", "metadata": {"problem_id": 742, "library_problem_id": 31, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 30}}
{"id": 743, "code": "\n# Create a mask of the same shape as the original array, with all values set to 1\nmask = np.ones_like(square, dtype=bool)\n\n# Create a mask where the original array is 0\nmask[square == 0] = 0\n\n# Use scipy.ndimage.label to get the connected components\nlabels, n_components = scipy.ndimage.label(mask)\n\n# Create a new array with the same shape as the original array, but filled with 0\nnew_square = np.zeros_like(square, dtype=int)\n\n# For each component, if it's not isolated (i.e., it's not surrounded by other components),\n# set the corresponding value in the new array to 1\nfor i in range(1, n_components):\n    new_square[labels == i] = 1\n\n# Now new_square is a binary array with isolated cells set to 0\n", "metadata": {"problem_id": 743, "library_problem_id": 32, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 32}}
{"id": 744, "code": "\n# Create a mask of the same shape as the original image\nmask = square == 0\n\n# Use scipy.ndimage.label to label the connected components\nlabeled_image, n_components = scipy.ndimage.label(mask)\n\n# Create a new mask where the connected components are isolated\nisolated_mask = np.full(mask.shape, True)\nisolated_mask[np.where(labeled_image[:-1, :-1] != labeled_image[1:, :-1] & labeled_image[:-1, 1:] != labeled_image[1:, 1:])] = False\n\n# Use scipy.ndimage.binary_fill to fill the isolated components with zeros\neroded_image = scipy.ndimage.binary_fill(isolated_mask, labeled_image, index=0)\n\n# Use scipy.ndimage.binary_dilation to dilate the eroded image\ndilated_image = scipy.ndimage.binary_dilation(eroded_image)\n\n# Use scipy.ndimage.binary_erosion to erode the dilated image\nfinal_image = scipy.ndimage.binary_erosion(dilated_image)\n\nsquare = final_image\n", "metadata": {"problem_id": 744, "library_problem_id": 33, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 32}}
{"id": 745, "code": "mean = np.mean(col.toarray())\nstandard_deviation = np.std(col.toarray())\n", "metadata": {"problem_id": 745, "library_problem_id": 34, "library": "Scipy", "test_case_cnt": 4, "perturbation_type": "Origin", "perturbation_origin_id": 34}}
{"id": 746, "code": "max_val = np.max(col.toarray())\nmin_val = np.min(col.toarray())\n", "metadata": {"problem_id": 746, "library_problem_id": 35, "library": "Scipy", "test_case_cnt": 4, "perturbation_type": "Semantic", "perturbation_origin_id": 34}}
{"id": 747, "code": "\n# Convert the sparse column to a numpy array\ncol_array = col.toarray()\n\n# Get the median and mode\nMedian = np.median(col_array)\nMode = stats.mode(col_array)\n", "metadata": {"problem_id": 747, "library_problem_id": 36, "library": "Scipy", "test_case_cnt": 4, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 34}}
{"id": 748, "code": "def fourier(x, *args):\n    return sum(a * np.cos((i + 1) * np.pi / tau * x) for i, a in enumerate(args))\npopt, pcov = curve_fit(fourier, z, Ua, p0=[1] * degree)\n", "metadata": {"problem_id": 748, "library_problem_id": 37, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 37}}
{"id": 749, "code": "# Convert the array to a 1D array\nflat_array = example_array.ravel()\n\n# Calculate pairwise distances\ndistances = scipy.spatial.distance.pdist(flat_array, metric='euclidean')\n\n# Convert distances back to 2D array\ndistances_2D = np.array(distances).reshape(len(flat_array), len(flat_array))\n\n# Convert IDs to regions\nregions = np.unique(flat_array)\n\n# Create a dataframe with IDs, to IDs, distance\nresult = pd.DataFrame(list(zip(regions, regions, distances_2D)), columns=['from', 'to', 'distance'])\nresult['distance'] = result['distance'] * example_array.dx\nresult\n", "metadata": {"problem_id": 749, "library_problem_id": 38, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 38}}
{"id": 750, "code": "# Convert the 2D array to 1D\nflat_array = example_array.ravel()\n\n# Calculate pairwise distances\ndistances = scipy.spatial.distance.cdist(flat_array, flat_array, metric='cityblock')\n\n# Convert the 1D distances to 2D\ndistances = distances.reshape(len(flat_array), len(flat_array))\n\n# Find the minimum distance for each pair\nmin_distances = np.min(distances, axis=1)\n\n# Find the IDs of the regions\nregions = np.unique(flat_array)\n\n# Create a dataframe with the minimum distances and their corresponding regions\nresult = pd.DataFrame(list(zip(regions, min_distances)), columns=['Region', 'Minimum Distance'])\n", "metadata": {"problem_id": 750, "library_problem_id": 39, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 38}}
{"id": 751, "code": " ###\n    # Convert the raster to a 1D array\n    flat_array = example_array.flatten()\n    # Get the unique IDs\n    unique_ids = np.unique(flat_array)\n    # Initialize an empty array to store the minimum distances\n    min_distances = np.full(shape=(len(unique_ids), len(unique_ids)), fill_value=np.inf)\n    # Calculate the pairwise distances\n    for i, id1 in enumerate(unique_ids):\n        for j, id2 in enumerate(unique_ids):\n            if id1 < id2:\n                mask = (flat_array == id1) | (flat_array == id2)\n                distances = scipy.spatial.distance.cdist(example_array[mask].reshape(-1, 1), example_array[mask].reshape(-1, 1), metric='euclidean')\n                min_distances[i, j] = distances.min()\n                min_distances[j, i] = distances.min()\n    # Convert the 2D array to a 1D array again\n    min_distances = min_distances.flatten()\n    # Return the result\n    return unique_ids, unique_ids[min_distances != np.inf], min_distances\n    ### END SOLUTION ###\n\nThe function f(example_array) should return the minimum distance between each pair of unique IDs.\n\nI've tried to use the cdist function from scipy.spatial.distance, but it seems to be unable to handle the 2D array as input.\n\nI've also tried to use the scipy.spatial.distance.pdist function, but it returns a 1D array instead of a 2D array.\n\nI'm not sure what else to try. Any help would be greatly appreciated.\n\n\nA: You can use the scipy.spatial.distance.pdist function to calculate pairwise distances between all unique IDs. This function returns a 1D array where the i-th element is the distance between the i-th ID and all other IDs.\n\nHere is how you can use it:\n\n```python\nimport numpy as np\nimport scipy.spatial.distance\n\n# Convert the raster to a 1D array\nflat_array = example_array.flatten()\n\n# Get the unique IDs\nunique_ids = np.unique(flat_array)\n\n# Calculate the pairwise distances\ndistances = scipy.spatial.distance.pdist(example_array[unique_ids].reshape(-1, 1), metric='euclidean')\n\n# Convert the 1D array to a 2D array\nmin_distances = np.array(list(zip(unique_ids, unique_ids[distances != 0])))\n\n# The result is a 2D array where the i-th row contains the minimum distance between the i-th ID and all other IDs\nprint(min_distances)\n```\n\nThis will give you a 2D array where the i-th row contains the minimum distance between the i-th ID and all other IDs. The diagonal elements are infinity because there is no distance between a ID and itself.\n\nPlease note that the distances are in the same units as the raster resolution. If the raster resolution is in meters, you can convert the distances to meters by multiplying them by the raster resolution.\n", "metadata": {"problem_id": 751, "library_problem_id": 40, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 38}}
{"id": 752, "code": "for i in range(5):\n    tck = interpolate.splrep(x[:, i], y[:, i], k=3, s=3)\n    result[i] = interpolate.splev(x_val, tck)\n", "metadata": {"problem_id": 752, "library_problem_id": 41, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 41}}
{"id": 753, "code": "x = np.array([x1, x2, x3, x4])\nstatistic, critical_values, significance_level = ss.anderson_ksamp(x)\n", "metadata": {"problem_id": 753, "library_problem_id": 42, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 42}}
{"id": 754, "code": "x1 = np.array(x1)\nx2 = np.array(x2)\nresult = ss.anderson_ksamp([x1, x2])\nprint(result)", "metadata": {"problem_id": 754, "library_problem_id": 43, "library": "Scipy", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 42}}
{"id": 755, "code": "\ndef tau1(x):\n    y = np.array(df['A'])\n    tau, p_value = stats.kendalltau(x, y)\n    return tau\n\ndf['AB'] = df['B'].rolling(3).apply(tau1)\ndf['AC'] = df['C'].rolling(3).apply(tau1)\ndf['BC'] = df['B'].rolling(3).apply(lambda x: 1/tau1(x))\n\n", "metadata": {"problem_id": 755, "library_problem_id": 44, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 44}}
{"id": 756, "code": "result = bool(sa.nnz == 0)", "metadata": {"problem_id": 756, "library_problem_id": 45, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 45}}
{"id": 757, "code": "result = bool(sa.nnz == 0)", "metadata": {"problem_id": 757, "library_problem_id": 46, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 45}}
{"id": 758, "code": "result = block_diag(*a)\n", "metadata": {"problem_id": 758, "library_problem_id": 47, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 47}}
{"id": 759, "code": "\n# Run the ranksums test\nranksums_result = stats.ranksums(pre_course_scores, during_course_scores)\n\n# Extract the p-value\np_value = ranksums_result.pvalue\nprint(p_value)\n", "metadata": {"problem_id": 759, "library_problem_id": 48, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 48}}
{"id": 760, "code": " ###\n    result = stats.ranksums(pre_course_scores, during_course_scores)\n    return result.pvalue\n    ### END SOLUTION ###\n\nprint(f())\n", "metadata": {"problem_id": 760, "library_problem_id": 49, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 48}}
{"id": 761, "code": "\nfrom scipy.stats import kurtosis\n\nkurtosis_result = kurtosis(a)\nprint(kurtosis_result)\n", "metadata": {"problem_id": 761, "library_problem_id": 50, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 50}}
{"id": 762, "code": "kurtosis_result = scipy.stats.kurtosis(a, fisher=False)\n", "metadata": {"problem_id": 762, "library_problem_id": 51, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 50}}
{"id": 763, "code": "z_interp = scipy.interpolate.interp2d(s, t, z, kind='cubic')\nresult = z_interp(x, y)", "metadata": {"problem_id": 763, "library_problem_id": 52, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 52}}
{"id": 764, "code": " ###\n    interp_func = scipy.interpolate.interp2d(s, t, z, kind='cubic')\n    result = interp_func(s, t)\n    return result\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 764, "library_problem_id": 53, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 52}}
{"id": 765, "code": "result = [vor.point_region[i] for i in extraPoints]\n", "metadata": {"problem_id": 765, "library_problem_id": 54, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 54}}
{"id": 766, "code": "# Create a list of all points and the extra points\nall_points = points + extraPoints\n\n# Create a list of all regions\nregions = vor.regions\n\n# Create a list of all vertices\nvertices = vor.vertices\n\n# Create a list of all point-region mappings\npoint_region = vor.point_region\n\n# Create a list of all region-region mappings\nregion_region = vor.region_region\n\n# Create a list of all point-vertex mappings\npoint_vertex = vor.point_vertices\n\n# Create a list of all region-vertex mappings\nregion_vertex = vor.region_vertices\n\n# Create a list of all point-edge mappings\npoint_edge = vor.point_edges\n\n# Create a list of all region-edge mappings\nregion_edge = vor.region_edges\n\n# Create a list of all point-neighbor mappings\npoint_neighbor = vor.point_neighbors\n\n# Create a list of all region-neighbor mappings\nregion_neighbor = vor.region_neighbors\n\n# Create a list of all point-dihedral mappings\npoint_dihedral = vor.point_dihedrals\n\n# Create a list of all region-dihedral mappings\nregion_dihedral = vor.region_dihedrals\n\n# Create a list of all point-tetrahedron mappings\npoint_tetrahedron = vor.point_tetrahedrons\n\n# Create a list of all region-tetrahedron mappings\nregion_tetrahedron = vor.region_tetrahedrons\n\n# Create a list of all point-hexahedron mappings\npoint_hexahedron = vor.point_hexahedrons\n\n# Create a list of all region-hexahedron mappings\nregion_hexahedron = vor.region_hexahedrons\n\n# Create a list of all point-octahedron mappings\npoint_octahedron = vor.point_octahedrons\n\n# Create a list of all region-octahedron mappings\nregion_octahedron = vor.region_octahedrons\n\n# Create a list of all point-icosahedron mappings\npoint_icosahedron = vor.point_icosahedrons\n\n# Create a list of all region-icosahedron mappings\nregion_icosahedron = vor.region_icosahedrons\n\n# Create a list of all point-dodecahedron mappings\npoint_dodecahedron = vor.point_dodecahedrons\n\n# Create a list of all region-dodecahedron mappings\nregion_dodecahedron = vor.region_dodecahedrons\n\n# Create a list of all point-cone mappings\npoint_cone = vor.point_cones\n\n# Create a list of all region-cone mappings\nregion_cone = vor.region_cones\n\n# Create a list of all point-cylinder mappings\npoint_cylinder = vor.point_cylinders\n\n# Create a list of all region-cylinder mappings\nregion_cylinder = vor.region_cylinders\n\n# Create a list of all point-sphere mappings\npoint_sphere = vor.point_spheres\n\n# Create a list of all region-sphere mappings\nregion_sphere = vor.region_spheres\n\n# Create a list of all point-torus mappings\npoint_torus = vor.point_tori\n\n# Create a list of all region-torus mappings\nregion_torus = vor.region_tori\n\n# Create a list of all point-ellipsoid mappings\npoint_ellipsoid = vor.point_ellipsoids\n\n# Create a list of all region-ellipsoid mappings\nregion_ellipsoid = vor.region_ellipsoids\n\n# Create a list of all point-hyperboloid mappings\npoint_hyperboloid = vor.point_hyperboloids\n\n# Create a list of all region-hyperboloid mappings\nregion_hyperboloid = vor.region_hyperboloids\n\n# Create a list of all point-morphism m", "metadata": {"problem_id": 766, "library_problem_id": 55, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 54}}
{"id": 767, "code": "\n# find the maximum size among all vectors\nmax_size = max([len(v) for v in vectors])\n\n# create a sparse matrix with zeros\nresult = sparse.coo_matrix((max_size - len(v)) * np.ones(len(v)), shape=(len(vectors), max_size))\n\n# set the values of the sparse matrix\nfor i, v in enumerate(vectors):\n    result.rows[i].data[:] = v\n\n# convert the sparse matrix to a dense matrix\nresult = result.todense()\n", "metadata": {"problem_id": 767, "library_problem_id": 56, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 56}}
{"id": 768, "code": "b = scipy.ndimage.median_filter(a, size=3, mode='constant', origin=[1, 1])", "metadata": {"problem_id": 768, "library_problem_id": 57, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 57}}
{"id": 769, "code": "result = M.data[M.indices == column][M.indptr[row] : M.indptr[row+1]]\n", "metadata": {"problem_id": 769, "library_problem_id": 58, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 58}}
{"id": 770, "code": "result = [M.get_row_from_indices(i)[0][j] for i, j in zip(row, column)]", "metadata": {"problem_id": 770, "library_problem_id": 59, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 58}}
{"id": 771, "code": "f = scipy.interpolate.interp1d(x, array[:, 0, 0], kind='cubic')\nnew_array = f(x_new)", "metadata": {"problem_id": 771, "library_problem_id": 60, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 60}}
{"id": 772, "code": "def NormalDistro(u,o2,x):\n    dev = abs((x-u)/o2)\n    P_inner = scipy.integrate.quad(NDfx,-dev,dev)[0]\n    P_outer = 1 - P_inner\n    P = P_inner + P_outer/2\n    return(P)\n\nprob = NormalDistro(u,o2,x)\nprint(prob)\n", "metadata": {"problem_id": 772, "library_problem_id": 61, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 61}}
{"id": 773, "code": " ###\n    dev = abs((x-u)/o2)\n    P_inner = scipy.integrate.quad(NDfx, -dev, dev)[0]\n    P_outer = 1 - P_inner\n    P = P_inner + P_outer/2\n    return P\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 773, "library_problem_id": 62, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 61}}
{"id": 774, "code": "\n# Create a 2D array of size N x N with ones\nA = np.ones((N, N))\n\n# Compute the DCT of the 2D array\ndct_matrix = sf.dct(A)\n\n# Normalize the DCT matrix\nresult = dct_matrix / np.sqrt(N)\n", "metadata": {"problem_id": 774, "library_problem_id": 63, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 63}}
{"id": 775, "code": "diags(matrix, [0, -1, 1], format='csc').toarray()\n", "metadata": {"problem_id": 775, "library_problem_id": 64, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 64}}
{"id": 776, "code": "\ndef binomial_pmf(n, p, k):\n    return scipy.stats.binom.pmf(k, n, p)\n\nresult = np.array([[binomial_pmf(n, p, k) for k in range(n+1)] for n in range(n+1)])\n", "metadata": {"problem_id": 776, "library_problem_id": 65, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 65}}
{"id": 777, "code": "result = df.apply(lambda x: stats.zscore(x), axis=1)\nprint(result)\n", "metadata": {"problem_id": 777, "library_problem_id": 66, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 66}}
{"id": 778, "code": "z_scores = stats.zscore(df)\nresult = pd.DataFrame(z_scores, index=df.index)\nresult", "metadata": {"problem_id": 778, "library_problem_id": 67, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 66}}
{"id": 779, "code": "df['data'] = 'data'\ndf['zscore'] = stats.zscore(df, axis=0, nan_policy='omit')\nresult = df\nresult\n", "metadata": {"problem_id": 779, "library_problem_id": 68, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 66}}
{"id": 780, "code": "df['data'] = df.index\ndf['zscore'] = stats.zscore(df.values, axis=1)\ndf['zscore'] = df['zscore'].apply(lambda x: round(x, 3))\nresult = df\n", "metadata": {"problem_id": 780, "library_problem_id": 69, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 66}}
{"id": 781, "code": "result = scipy.optimize.line_search(test_func, test_grad, starting_point, direction)\nprint(result)", "metadata": {"problem_id": 781, "library_problem_id": 70, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 70}}
{"id": 782, "code": "y, x = np.ogrid[:shape[0], :shape[1]]\ncenter = np.array([[shape[0]//2, shape[1]//2]])\nresult = distance.cdist(center, [y, x], 'euclidean')\n", "metadata": {"problem_id": 782, "library_problem_id": 71, "library": "Scipy", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 71}}
{"id": 783, "code": "\ndef get_distance_2(shape):\n    y, x = np.ogrid[:shape[0], :shape[1]]\n    center = np.array([(shape[0] - 1) / 2, (shape[1] - 1) / 2])\n    result = distance.cdist(np.dstack((y, x)), center, 'cityblock')\n    return result\n\nresult = get_distance_2(shape)\nprint(result)\n", "metadata": {"problem_id": 783, "library_problem_id": 72, "library": "Scipy", "test_case_cnt": 3, "perturbation_type": "Semantic", "perturbation_origin_id": 71}}
{"id": 784, "code": "\n    y, x = np.ogrid[:shape[0], :shape[1]]\n    center = np.array([(shape[0] - 1) / 2, (shape[1] - 1) / 2])\n    return distance.cdist(np.dstack((y, x)), center, 'euclidean')\n    ### END SOLUTION\n", "metadata": {"problem_id": 784, "library_problem_id": 73, "library": "Scipy", "test_case_cnt": 3, "perturbation_type": "Surface", "perturbation_origin_id": 71}}
{"id": 785, "code": "\nzoom_factor = min(shape[0]/x.shape[0], shape[1]/x.shape[1])\nresult = scipy.ndimage.zoom(x, zoom_factor, order=1)\n", "metadata": {"problem_id": 785, "library_problem_id": 74, "library": "Scipy", "test_case_cnt": 4, "perturbation_type": "Origin", "perturbation_origin_id": 74}}
{"id": 786, "code": "def func(x):\n    return a.dot(x ** 2)\n\ndef residual(x):\n    return np.sum((func(x) - y) ** 2)\n\nout = scipy.optimize.minimize(residual, x0)['x']\n", "metadata": {"problem_id": 786, "library_problem_id": 75, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 75}}
{"id": 787, "code": "def func(x):\n    return np.sum((y - a.dot(x ** 2)) ** 2)\n\nout = scipy.optimize.minimize(func, x0, method='L-BFGS-B', bounds=[(-10 * x_true)] * 5)\n", "metadata": {"problem_id": 787, "library_problem_id": 76, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 75}}
{"id": 788, "code": "\ndef dN1_dt_simple(t, N1):\n    return -100 * N1 + np.sin(t)\n\nsol = scipy.integrate.solve_ivp(fun=dN1_dt_simple, t_span=time_span, y0=[N0,])\nresult = sol.y\n", "metadata": {"problem_id": 788, "library_problem_id": 77, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 77}}
{"id": 789, "code": "\ndef dN1_dt_simple(t, N1):\n    if 0 < t < 2*np.pi:\n        return -100 * N1 + np.sin(t)\n    else:\n        return 2*np.pi\n\nsol = scipy.integrate.solve_ivp(fun=dN1_dt_simple, t_span=time_span, y0=[N0,])\nresult = sol.y\n", "metadata": {"problem_id": 789, "library_problem_id": 78, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 77}}
{"id": 790, "code": "\ndef dN1_dt_simple(t, N1):\n    return -100 * N1 - np.cos(t)\n\nsol = scipy.integrate.solve_ivp(fun=dN1_dt_simple, t_span=time_span, y0=[N0,])\nresult = sol.y\n", "metadata": {"problem_id": 790, "library_problem_id": 79, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 77}}
{"id": 791, "code": "\nfor t in range (4):\n    def const(x):    \n        y=x[t]\n        return y\n    cons.append({'type':'ineq', 'fun': const})\n", "metadata": {"problem_id": 791, "library_problem_id": 80, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 80}}
{"id": 792, "code": "result = sparse.vstack([sa, sb])", "metadata": {"problem_id": 792, "library_problem_id": 81, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 81}}
{"id": 793, "code": "result = sparse.hstack([sa, sb])", "metadata": {"problem_id": 793, "library_problem_id": 82, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 81}}
{"id": 794, "code": "I = []\nfor c_value in c:\n    result, error = scipy.integrate.quad(lambda x: 2*x*c_value, low, high)\n    I.append(result)\nI = array(I)\n", "metadata": {"problem_id": 794, "library_problem_id": 83, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 83}}
{"id": 795, "code": "\n    result, error = scipy.integrate.quad(lambda x: 2*x*c, low, high)\n    return result\n    ### END SOLUTION\n    # return the result\n\n# call the function\nprint(f(c=5, low=0, high=1))\n", "metadata": {"problem_id": 795, "library_problem_id": 84, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 83}}
{"id": 796, "code": "\n# Create a dense matrix with the scalar value x\nx_matrix = np.array([x]).reshape(-1, 1)\n\n# Add the scalar to the non-zero values in V\nV.data += x_matrix.flatten()\n\n# Convert the sparse matrix to a dense matrix\nV_dense = V.toarray()\n\n# Now V_dense is a dense matrix with the scalar value x added to non-zero values in V\nV = V_dense\n", "metadata": {"problem_id": 796, "library_problem_id": 85, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 85}}
{"id": 797, "code": "mask = V.data != 0\nV.data += x\nV = sparse.coo_matrix(V.data, (V.shape[0], V.shape[1]), dtype = V.data.dtype)\nV = V.multiply(mask)\n", "metadata": {"problem_id": 797, "library_problem_id": 86, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 85}}
{"id": 798, "code": "mask = V.data != 0\nV.data += x\nV.data += y\nV = sparse.coo_matrix(V.data, (V.shape[0], V.shape[1]), dtype = V.data.dtype)\nV = V.todense()\n", "metadata": {"problem_id": 798, "library_problem_id": 87, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 85}}
{"id": 799, "code": "#csc sparse matrix\nsa = sa.tocsc()\n\n#iterate through columns\nfor Col in xrange(sa.shape[1]):\n   Column = sa[:,Col].data\n   List = [x**2 for x in Column]\n   #get the column length\n   Len = math.sqrt(sum(List))\n   #here I assumed dot(number,Column) would do a basic scalar product\n   dot((1/Len),Column)\n   #now what? how do I update the original column of the matrix, everything that have been returned are copies, which drove me nuts and missed pointers so much\n   #you can directly modify the original column of the matrix\n   sa[:,Col] = sa[:,Col] / Len\n", "metadata": {"problem_id": 799, "library_problem_id": 88, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 88}}
{"id": 800, "code": "\n# iterate through columns\nfor Col in range(sa.shape[1]):\n    # get the column\n    Column = sa[:,Col].toarray()\n    # calculate the length\n    Len = math.sqrt(sum([i**2 for i in Column]))\n    # normalize the column\n    sa[:,Col] = sa[:,Col] / Len\n", "metadata": {"problem_id": 800, "library_problem_id": 89, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 88}}
{"id": 801, "code": "\na = (a > 0).astype(int)\n", "metadata": {"problem_id": 801, "library_problem_id": 90, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 90}}
{"id": 802, "code": "\na = (a > 0).astype(int)\n", "metadata": {"problem_id": 802, "library_problem_id": 91, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 90}}
{"id": 803, "code": "\n# Calculate the Euclidean distance between each data point and each centroid\ndistances = scipy.spatial.distance.cdist(data, centroids, 'euclidean')\n\n# Find the index of the minimum distance for each data point\nresult = np.argmin(distances, axis=0)\n\nprint(result)\n", "metadata": {"problem_id": 803, "library_problem_id": 92, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 92}}
{"id": 804, "code": "\n# Calculate the Euclidean distance between each data point and each centroid\ndistances = scipy.spatial.distance.cdist(data, centroids, 'euclidean')\n\n# Find the index of the minimum distance for each data point\nclosest = np.argmin(distances, axis=1)\n\n# Extract the closest data point from the original data\nresult = data[closest]\n", "metadata": {"problem_id": 804, "library_problem_id": 93, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 92}}
{"id": 805, "code": "\n# Compute the distance matrix\ndist_matrix = scipy.spatial.distance.cdist(data, centroids)\n\n# Find the k-th closest element to the centroid\nclosest_indices = np.argpartition(dist_matrix, k, axis=0)[:k, :]\n\n# Store the result\nresult = closest_indices\n", "metadata": {"problem_id": 805, "library_problem_id": 94, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 92}}
{"id": 806, "code": "for x, b in zip(xdata, bdata):\n    result.append(fsolve(eqn, x0=x, args=(a, b))[0])\n", "metadata": {"problem_id": 806, "library_problem_id": 95, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 95}}
{"id": 807, "code": "for x, a in zip(xdata, adata):\n    result.append(fsolve(eqn, x0=x, args=(a,)))\nresult = [sorted(x) for x in result]\nprint(result)\n", "metadata": {"problem_id": 807, "library_problem_id": 96, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 95}}
{"id": 808, "code": "# Fit the data to the model\npopt, pcov = sp.optimize.curve_fit(bekkers, range_start, sample_data, p0=[estimated_a, estimated_m, estimated_d])\n\n# Calculate the goodness of fit\nresult = sp.stats.kstest(sample_data, bekkers(range_start, *popt))\nresult", "metadata": {"problem_id": 808, "library_problem_id": 97, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 97}}
{"id": 809, "code": "# Fit the curve to the data\npopt, pcov = sp.optimize.curve_fit(bekkers, range_start, sample_data, p0=[estimated_a, estimated_m, estimated_d])\n\n# Calculate the K-S test statistic\nkstest_statistic, p_value = sp.stats.kstest(sample_data, bekkers(range_start, *popt))\n\n# Calculate the critical value at 95% confidence level\ncritical_value = sp.stats.kstest.critical(0.95, len(sample_data)-1)\n\n# Check if p-value is less than critical value\nresult = p_value < critical_value\n", "metadata": {"problem_id": 809, "library_problem_id": 98, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 97}}
{"id": 810, "code": "\n# Convert the 'Time' column to datetime\ndf['Time'] = pd.to_datetime(df['Time'])\n\n# Set the 'Time' column as the DataFrame index\ndf.set_index('Time', inplace=True)\n\n# Calculate the rolling integral\nintegral_df = df['A'].rolling(window='25S').apply(integrate.trapz)\n", "metadata": {"problem_id": 810, "library_problem_id": 99, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 99}}
{"id": 811, "code": "x_new = [i[0] for i in x]\ny_new = [i[1] for i in x]\nresult = scipy.interpolate.griddata(x_new, y_new, eval, method='linear')\n", "metadata": {"problem_id": 811, "library_problem_id": 100, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 100}}
{"id": 812, "code": "\n# calculate the total number of observations\nn = a.shape[0]\n\n# calculate the total sum of the data\ns = a.sum()\n\n# calculate the probabilities\np = a / s\n\n# calculate the weights\nw = p * np.ones(p.shape) / n\n\n# calculate the parameters\nparams = sciopt.curve_fit(lambda t, a, b: a * np.log(t) + b, range(n), a, p0=[1, 1])[0]\n\nweights = params[1]\n", "metadata": {"problem_id": 812, "library_problem_id": 101, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 101}}
{"id": 813, "code": "result = sciopt.fminbound(e, pmin, pmax, args=(x,y))\n", "metadata": {"problem_id": 813, "library_problem_id": 102, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 102}}
{"id": 814, "code": "\n# find the local maxima and minima\npeaks, _ = signal.find_peaks(arr, width=n)\n\n# find the local minima and maxima\nvalleys, _ = signal.find_valleys(arr, width=n)\n\n# combine the peaks and valleys\nextrema = np.concatenate([peaks, valleys])\n\n# sort the extrema\nresult = np.sort(extrema)\n\nprint(result)\n", "metadata": {"problem_id": 814, "library_problem_id": 103, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 103}}
{"id": 815, "code": "\n# Create a 2D array with the same shape as the input array, filled with False\nmask = np.zeros_like(arr, dtype=bool)\n\n# Create a 2D array with the same shape as the input array, filled with True\nresult = np.ones_like(arr, dtype=bool)\n\n# Use scipy's signal.local_maximum and signal.local_minimum functions to find the local maxima and minima\nfor i in range(arr.shape[0]):\n    forward_mask = signal.local_maximum(arr[i], width=n)\n    backward_mask = signal.local_minimum(arr[i], width=n)\n    mask[i] = forward_mask | backward_mask\n\n# Find the indices of the True values in the mask\nresult[mask] = np.arange(result.shape[0])\n\n# Print the result\nprint(result)\n", "metadata": {"problem_id": 815, "library_problem_id": 104, "library": "Scipy", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 103}}
{"id": 816, "code": "\n# Select only numeric columns\nnum_cols = df.select_dtypes(include=['int64', 'float64']).columns\n\n# Calculate z-scores\nz_scores = np.abs(stats.zscore(df[num_cols]))\n\n# Filter rows based on z-scores\ndf = df[(z_scores < 3).all(axis=1)]\n", "metadata": {"problem_id": 816, "library_problem_id": 105, "library": "Scipy", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 105}}
{"id": 817, "code": "data1 = pd.DataFrame(data=np.c_[data['data'], data['target']],\n                     columns=list(data['feature_names']) + ['target'])\n", "metadata": {"problem_id": 817, "library_problem_id": 0, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 0}}
{"id": 818, "code": "data1 = pd.DataFrame(data=np.c_[data['data'], data['target']],\n                     columns=list(data['feature_names']) + ['target'])\n", "metadata": {"problem_id": 818, "library_problem_id": 1, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 0}}
{"id": 819, "code": "\ndata1 = pd.DataFrame(data=np.c_[data['data'], data['target']],\n                     columns=np.append(data['feature_names'], ['target']))\n", "metadata": {"problem_id": 819, "library_problem_id": 2, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 0}}
{"id": 820, "code": "\n    df = pd.DataFrame(data=np.c_[data['data'], data['target']],\n                     columns=data['feature_names'] + ['target'])\n    return df\n    ### END SOLUTION\n\nprint(solve(data))\n", "metadata": {"problem_id": 820, "library_problem_id": 3, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 0}}
{"id": 821, "code": "\n# First, we need to extract the unique elements from the list\nunique_elements = set(element for sublist in df['Col3'].tolist() for element in sublist)\n\n# Then, we create a new dataframe with the unique elements as columns\ndf_out = pd.DataFrame(np.zeros((len(df), len(unique_elements))), columns=unique_elements)\n\n# Now, we need to iterate over the original dataframe and update the new dataframe with 1s and 0s\nfor index, row in df.iterrows():\n    for element in row['Col3']:\n        df_out.loc[index, element] = 1\n\ndf_out\n", "metadata": {"problem_id": 821, "library_problem_id": 4, "library": "Sklearn", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 4}}
{"id": 822, "code": "\n# First, we need to flatten the list of lists into a single list\ndf['Col3'] = df['Col3'].apply(lambda x: [item for sublist in x for item in sublist])\n\n# Then, we can use the pandas get_dummies function to convert the list into a one-hot-encoded DataFrame\ndf_out = pd.get_dummies(df['Col3'].apply(pd.Series).stack()).sum(level=0)\n\n# Finally, we can drop the original column\ndf = df.drop('Col3', axis=1)\n\n# Now, we can merge the original dataframe with the one-hot-encoded dataframe\ndf = pd.concat([df, df_out], axis=1)\n\nprint(df)\n", "metadata": {"problem_id": 822, "library_problem_id": 5, "library": "Sklearn", "test_case_cnt": 3, "perturbation_type": "Surface", "perturbation_origin_id": 4}}
{"id": 823, "code": "\n# First, we need to extract the unique elements from the list in the last column\nunique_elements = set(df['Col4'].str.split(',').str[0].dropna().values.flatten())\n\n# Then, we create a DataFrame with zeros for each unique element\ndf_out = pd.DataFrame(np.zeros((df.shape[0], len(unique_elements))), columns=unique_elements)\n\n# Now, we iterate over the DataFrame and update the corresponding columns\nfor index, row in df.iterrows():\n    for col in row['Col4']:\n        df_out.loc[index, col] = 1\n\n# Finally, we drop the last column\ndf_out = df_out.drop(columns=['Col4'])\n\n# And rename the first column\ndf_out = df_out.rename(columns={df_out.columns[0]: 'Col1'})\n", "metadata": {"problem_id": 823, "library_problem_id": 6, "library": "Sklearn", "test_case_cnt": 3, "perturbation_type": "Surface", "perturbation_origin_id": 4}}
{"id": 824, "code": "\n# First, we need to flatten the list of fruits from the dataframe\ndf['Col3'] = df['Col3'].apply(pd.Series).stack().reset_index(level=-1, drop=True)\n\n# Then, we create a dictionary where the keys are the unique fruits and the values are 0s\nfruit_dict = dict.fromkeys(df['Col3'].unique(), 0)\n\n# Now, we apply the dictionary to the dataframe\ndf = df['Col3'].map(fruit_dict)\n\n# Finally, we pivot the dataframe\ndf_out = df.pivot_table(index=['Col1', 'Col2'], columns='Col3', values='Col3').fillna(0)\n", "metadata": {"problem_id": 824, "library_problem_id": 7, "library": "Sklearn", "test_case_cnt": 4, "perturbation_type": "Semantic", "perturbation_origin_id": 4}}
{"id": 825, "code": "\n# First, we need to flatten the list of fruits from the dataframe\ndf['Col3'] = df['Col3'].apply(pd.Series).stack().reset_index(level=-1, drop=True)\n\n# Then, we create a dictionary where the keys are the unique fruits and the values are 0s\nfruit_dict = dict.fromkeys(df['Col3'].unique(), 0)\n\n# Now, we apply the dictionary to the dataframe\ndf = df.replace({'Col3': fruit_dict})\n\n# Finally, we pivot the dataframe\ndf_out = df.pivot_table(index='Col1', columns='Col2', values='Col3').fillna(0)\n", "metadata": {"problem_id": 825, "library_problem_id": 8, "library": "Sklearn", "test_case_cnt": 4, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 4}}
{"id": 826, "code": "svmmodel.fit(X, y)\npredicted_test= svmmodel.predict_proba(x_test)\nproba = [p[1] for p in predicted_test]", "metadata": {"problem_id": 826, "library_problem_id": 9, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 9}}
{"id": 827, "code": "\nmodel.fit(X, y)\nproba = model.predict_proba(x_predict)\n", "metadata": {"problem_id": 827, "library_problem_id": 10, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 9}}
{"id": 828, "code": "\n# Convert sparse matrix to DataFrame\ndf_transform = pd.DataFrame(transform_output.toarray())\n\n# Concatenate original dataframe and transformed dataframe\ndf = pd.concat([df_origin, df_transform], axis=1)\n", "metadata": {"problem_id": 828, "library_problem_id": 11, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 11}}
{"id": 829, "code": "\n# Convert the sparse matrix to a DataFrame\ndf_transform = pd.DataFrame(transform_output.toarray())\n\n# Merge the original DataFrame with the transformed DataFrame\ndf = pd.concat([df_origin, df_transform], axis=1)\n", "metadata": {"problem_id": 829, "library_problem_id": 12, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 11}}
{"id": 830, "code": "\n    ## Step 1: Convert the sparse matrix to a DataFrame\n    df_transform_output = pd.DataFrame.sparse.from_spmatrix(transform_output)\n    ## Step 2: Merge the original DataFrame and the transformed DataFrame\n    result = pd.concat([df, df_transform_output], axis=1)\n    return result\n", "metadata": {"problem_id": 830, "library_problem_id": 13, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 11}}
{"id": 831, "code": "\nclf.steps.pop(1)\n", "metadata": {"problem_id": 831, "library_problem_id": 14, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 14}}
{"id": 832, "code": "\nclf.steps.pop(1)\n", "metadata": {"problem_id": 832, "library_problem_id": 15, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 14}}
{"id": 833, "code": "\nclf.steps.pop(1)\n", "metadata": {"problem_id": 833, "library_problem_id": 16, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 14}}
{"id": 834, "code": "\nclf.steps.append(('new_step', SomeNewStep()))\nclf.fit(X_train, y_train)\n", "metadata": {"problem_id": 834, "library_problem_id": 17, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 17}}
{"id": 835, "code": "\nclf.steps.append(('new_step', LinearSVC()))\nclf.fit(X_train, y_train)\n", "metadata": {"problem_id": 835, "library_problem_id": 18, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 17}}
{"id": 836, "code": "\nclf.steps.insert(1, ('t1919810', PCA()))\nclf", "metadata": {"problem_id": 836, "library_problem_id": 19, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 17}}
{"id": 837, "code": "\nmodel = xgb.XGBRegressor()\nparam_grid = {\n    'n_estimators': [50, 100, 150],\n    'learning_rate': [0.01, 0.1, 0.2],\n    'max_depth': [3, 5, 7]\n}\n\n# Define the grid\ngrid = GridSearchCV(model, param_grid, verbose=1, cv=TimeSeriesSplit(n_splits=5).get_n_splits([trainX, trainY]), n_jobs=-1, iid=True)\n\n# Fit the grid\ngrid.fit(trainX, trainY)\n\n# Get the best model\nbest_model = grid.best_estimator_\n\n# Get the best parameters\nbest_params = grid.best_params_\n\n# Get the score\nb = grid.best_score_\n\n# Get the prediction\nc = best_model.predict(testX)\n", "metadata": {"problem_id": 837, "library_problem_id": 20, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 20}}
{"id": 838, "code": "\nmodel = xgb.XGBRegressor()\nparamGrid = {\n    'n_estimators': [50, 100, 150],\n    'learning_rate': [0.01, 0.1, 0.2],\n    'max_depth': [3, 5, 7]\n}\n\n# define the grid\ngridsearch = GridSearchCV(model, paramGrid, verbose=1, cv=TimeSeriesSplit(n_splits=3).get_n_splits([trainX, trainY]), n_jobs=-1, iid=True)\n\n# fit the model\ngridsearch.fit(trainX, trainY)\n\n# get the best parameters\nbest_params = gridsearch.best_params_\nprint('Best Parameters:', best_params)\n\n# get the best score\nbest_score = gridsearch.best_score_\nprint('Best Score:', best_score)\n\n# get the prediction\nc = gridsearch.predict(testX)\n\n# get the score on the test set\nb = gridsearch.score(testX, testY)\nprint('Test Score:', b)\n", "metadata": {"problem_id": 838, "library_problem_id": 21, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 20}}
{"id": 839, "code": "proba = []\nfor train_index, test_index in cv:\n    X_train, X_test = X[train_index], X[test_index]\n    y_train, y_test = y[train_index], y[test_index]\n    logreg.fit(X_train, y_train)\n    proba.append(logreg.predict_proba(X_test))\nproba = np.array(proba)\n", "metadata": {"problem_id": 839, "library_problem_id": 22, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 22}}
{"id": 840, "code": "proba = []\nfor train_index, test_index in cv:\n    X_train, X_test = X[train_index], X[test_index]\n    y_train, y_test = y[train_index], y[test_index]\n    logreg.fit(X_train, y_train)\n    proba.append(logreg.predict_proba(X_test))\nproba = np.array(proba)\n", "metadata": {"problem_id": 840, "library_problem_id": 23, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 22}}
{"id": 841, "code": "inversed = scaler.inverse_transform(scaled)", "metadata": {"problem_id": 841, "library_problem_id": 24, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 24}}
{"id": 842, "code": " ###\n    t_predicted = scaler.inverse_transform(scaled)\n    return t_predicted\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 842, "library_problem_id": 25, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 24}}
{"id": 843, "code": "\nmodel_name = model.__class__.__name__\nprint(f'Name model: {model_name}, Mean score: {scores.mean()}')\n", "metadata": {"problem_id": 843, "library_problem_id": 26, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 26}}
{"id": 844, "code": "\nmodel_name = model.__class__.__name__\nprint(f'Name model: {model_name}, Mean score: {scores.mean()}')\n", "metadata": {"problem_id": 844, "library_problem_id": 27, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 26}}
{"id": 845, "code": "\nmodel_name = model.__class__.__name__\nprint(f'Name model: {model_name}, Mean score: {scores.mean()}')\n", "metadata": {"problem_id": 845, "library_problem_id": 28, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 26}}
{"id": 846, "code": "pipe.fit_transform(data.test)\ntf_idf_out = pipe.named_steps[\"tf_idf\"].transform(data.test)", "metadata": {"problem_id": 846, "library_problem_id": 29, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 29}}
{"id": 847, "code": "pipe.fit_transform(data)\ntf_idf_out = pipe.named_steps[\"tf_idf\"].transform(data)", "metadata": {"problem_id": 847, "library_problem_id": 30, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 29}}
{"id": 848, "code": "pipe.fit(data, target)\nselect_out = pipe.named_steps['select'].transform(data)", "metadata": {"problem_id": 848, "library_problem_id": 31, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 29}}
{"id": 849, "code": "\ngrid_search = GridSearchCV(bc, param_grid, cv=5, scoring='accuracy')\ngrid_search.fit(X_train, y_train)\nclf = grid_search.best_estimator_\nproba = clf.predict_proba(X_test)\n", "metadata": {"problem_id": 849, "library_problem_id": 32, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 32}}
{"id": 850, "code": "\nregressor = RandomForestRegressor(n_estimators=150, min_samples_split=2, random_state=42)\nrgr = regressor.fit(X, y)\n\n# Predict\npredict = rgr.predict(X_test)\n", "metadata": {"problem_id": 850, "library_problem_id": 33, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 33}}
{"id": 851, "code": "\nregressor = RandomForestRegressor(n_estimators=150, min_samples_split=2, random_state=42)\nrgr = regressor.fit(X, y)\n\n# Predict\npredict = rgr.predict(X_test)\n", "metadata": {"problem_id": 851, "library_problem_id": 34, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 33}}
{"id": 852, "code": "\n\ndef preprocess(s):\n    return s.upper()\n\nvectorizer = TfidfVectorizer(preprocessor=preprocess)\n\n# example variable\nexample = [\"This is an example sentence.\", \"Another example sentence.\"]\n\n# fit_transform() does both fitting and transforming, so we split it into two steps\nX = vectorizer.fit_transform(example)\n\n# print the shape of the matrix\nprint(X.shape)\n", "metadata": {"problem_id": 852, "library_problem_id": 35, "library": "Sklearn", "test_case_cnt": 0, "perturbation_type": "Origin", "perturbation_origin_id": 35}}
{"id": 853, "code": "\ndef prePro(text):\n    return text.lower()\n\nvectorizer = TfidfVectorizer(preprocessor=prePro)\ntfidf = vectorizer.fit_transform(corpus)\n", "metadata": {"problem_id": 853, "library_problem_id": 36, "library": "Sklearn", "test_case_cnt": 0, "perturbation_type": "Semantic", "perturbation_origin_id": 35}}
{"id": 854, "code": "\n# First, you need to convert your DataFrame to a numpy array\ndata_array = data.values\n\n# Then, apply the preprocessing.scale function to the numpy array\nscaled_data = preprocessing.scale(data_array)\n\n# Finally, convert the scaled numpy array back to a DataFrame\nscaled_data_df = pd.DataFrame(scaled_data, index=data.index, columns=data.columns)\n\ndf_out = scaled_data_df\n", "metadata": {"problem_id": 854, "library_problem_id": 37, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 37}}
{"id": 855, "code": "\n# First, we need to convert the DataFrame to a numpy array\ndata_array = data.values\n\n# Then, we apply the preprocessing.scale function to the numpy array\nscaled_data = preprocessing.scale(data_array)\n\n# Now, we need to convert the scaled numpy array back to a DataFrame\nscaled_data_df = pd.DataFrame(scaled_data, index=data.index, columns=data.columns)\n\ndf_out = scaled_data_df\n", "metadata": {"problem_id": 855, "library_problem_id": 38, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 37}}
{"id": 856, "code": "grid.fit(X, y)\ncoef = grid.best_estimator_.named_steps['model'].coef_", "metadata": {"problem_id": 856, "library_problem_id": 39, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 39}}
{"id": 857, "code": "grid.fit(X, y)\ncoef = grid.best_estimator_.named_steps['model'].coef_", "metadata": {"problem_id": 857, "library_problem_id": 40, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 39}}
{"id": 858, "code": "\nfeature_names = X.columns.values[model.get_support()]\nprint(feature_names)\n", "metadata": {"problem_id": 858, "library_problem_id": 41, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 41}}
{"id": 859, "code": "\nmodel = SelectFromModel(clf, prefit=True)\nX_new = model.transform(X)\n\n# Get the feature names\nfeature_names = X.columns[model.get_support()]\n\n# Assign the feature names to the variable you want to store them\ncolumn_names = feature_names\n", "metadata": {"problem_id": 859, "library_problem_id": 42, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 41}}
{"id": 860, "code": "\nfeature_names = X.columns.tolist()\nimportances = clf.feature_importances_\nfeature_importances = pd.Series(importances, index=feature_names).sort_values(ascending=False)\nselected_features = feature_importances.head(5) # select top 5 features\nprint(selected_features)\n", "metadata": {"problem_id": 860, "library_problem_id": 43, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 41}}
{"id": 861, "code": "\nfeature_names = X.columns.tolist()\nselected_features = [feature_names[i] for i in np.where(model.get_support())[0]]\nprint(selected_features)\n", "metadata": {"problem_id": 861, "library_problem_id": 44, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 41}}
{"id": 862, "code": "km.fit(X)\ndistances = km.transform(X)\nindices = np.argsort(distances[:, p])\nclosest_50_samples = X[indices[:50]]", "metadata": {"problem_id": 862, "library_problem_id": 45, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 45}}
{"id": 863, "code": "km.fit(X)\ndistances = km.transform(X)\nindices = np.argsort(distances[:, p])\nclosest_50_samples = X[indices[:50]]", "metadata": {"problem_id": 863, "library_problem_id": 46, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 45}}
{"id": 864, "code": "km.fit(X)\ndistances = km.transform(X)\nindices = np.argsort(distances[:, p])\nclosest_100_samples = X[indices[:100]]\n", "metadata": {"problem_id": 864, "library_problem_id": 47, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 45}}
{"id": 865, "code": " ###\n    km.fit(X)\n    centers = km.cluster_centers_\n    distances = np.linalg.norm(X - centers[p], axis=1)\n    closest_samples = X[np.argmin(distances)]\n    return closest_samples\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 865, "library_problem_id": 48, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 45}}
{"id": 866, "code": "\n# convert categorical variable to dummy variables\nX_train = pd.get_dummies(X_train)\n", "metadata": {"problem_id": 866, "library_problem_id": 49, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 49}}
{"id": 867, "code": "\n# convert categorical variable to dummy variables\nX_train = pd.get_dummies(X_train)\n", "metadata": {"problem_id": 867, "library_problem_id": 50, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 49}}
{"id": 868, "code": "from sklearn.svm import SVR\n\nregressor = SVR(kernel = 'rbf')\nregressor.fit(X, y)\npredict = regressor.predict(X)\n", "metadata": {"problem_id": 868, "library_problem_id": 51, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 51}}
{"id": 869, "code": "from sklearn import svm\nfrom sklearn.model_selection import train_test_split\n\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\nclf = svm.SVC(kernel='rbf')\nclf.fit(X_train, y_train)\n\npredict = clf.predict(X_test)\n", "metadata": {"problem_id": 869, "library_problem_id": 52, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 51}}
{"id": 870, "code": "from sklearn.svm import SVR\n\nmodel = SVR(kernel='poly', degree=2)\nmodel.fit(X, y)\npredict = model.predict(X)\n", "metadata": {"problem_id": 870, "library_problem_id": 53, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 51}}
{"id": 871, "code": "from sklearn.svm import SVR\n\n# define model\nmodel = SVR(kernel='poly', degree=2)\n\n# fit model\nmodel.fit(X, y)\n\n# predict\npredict = model.predict(X)\n", "metadata": {"problem_id": 871, "library_problem_id": 54, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 53}}
{"id": 872, "code": "tfidf_query = tfidf.transform(queries)\ncosine_similarities_of_queries = cosine_similarity(tfidf_query, tfidf.transform(documents))\n", "metadata": {"problem_id": 872, "library_problem_id": 55, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 55}}
{"id": 873, "code": "\ntfidf_query = TfidfVectorizer().fit_transform(queries)\ncosine_similarities_of_queries = cosine_similarity(tfidf_query, tfidf.transform(documents))\n", "metadata": {"problem_id": 873, "library_problem_id": 56, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 55}}
{"id": 874, "code": " ###\n    query_vectors = tfidf.transform(queries)\n    cosine_similarities_of_queries = cosine_similarity(query_vectors, tfidf.transform(documents))\n    return cosine_similarities_of_queries\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 874, "library_problem_id": 57, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 55}}
{"id": 875, "code": "\n# Create a DataFrame\ndf = pd.DataFrame(features)\n\n# Convert the DataFrame to a numpy array\nnew_features = df.values\n\n# Convert the numpy array to a 2D array\nnew_features = np.array(new_features)\n", "metadata": {"problem_id": 875, "library_problem_id": 58, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 58}}
{"id": 876, "code": "\n# Create a DataFrame\ndf = pd.DataFrame(f)\n\n# Convert the DataFrame to a numpy array\nnew_f = df.values\n\n# Convert the numpy array to a 2D array\nnew_f = np.array([list(map(int, i)) for i in new_f.tolist()])\n", "metadata": {"problem_id": 876, "library_problem_id": 59, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 58}}
{"id": 877, "code": "\n# Create a DataFrame\ndf = pd.DataFrame(features)\n\n# Convert the DataFrame to a numpy array\nnew_features = df.values\n\n# Convert the numpy array to a 2D array\nnew_features = np.array(new_features)\n", "metadata": {"problem_id": 877, "library_problem_id": 60, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 58}}
{"id": 878, "code": " ###\n    # Convert the features to a DataFrame\n    df = pd.DataFrame(features)\n\n    # Convert the DataFrame to a numpy array\n    arr = df.values\n\n    # Convert the numpy array to a 2D array\n    new_features = np.array([list(x) for x in arr])\n\n    return new_features\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 878, "library_problem_id": 61, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 58}}
{"id": 879, "code": "\n# Create a DataFrame\ndf = pd.DataFrame(features)\n\n# Convert the DataFrame to a numpy array\nnew_features = df.values\n\n# Convert the numpy array to a 2D array\nnew_features = np.array([[1 if feature == 't'+str(i) else 0 for i in range(1, len(features)+1)] for feature in features])\n", "metadata": {"problem_id": 879, "library_problem_id": 62, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 58}}
{"id": 880, "code": "from sklearn.cluster import AgglomerativeClustering\n\n# Convert the 2-D list to a numpy array\ndata_matrix = np.array(data_matrix)\n\n# Perform hierarchical clustering\ncluster = AgglomerativeClustering(n_clusters=2, affinity='precomputed', linkage='average')\ncluster_labels = cluster.fit_predict(data_matrix)\n", "metadata": {"problem_id": 880, "library_problem_id": 63, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 63}}
{"id": 881, "code": "from sklearn.cluster import AgglomerativeClustering\n\n# Create a distance matrix\ndist_matrix = pd.DataFrame(data_matrix)\n\n# Create an instance of the AgglomerativeClustering model\nclustering = AgglomerativeClustering(n_clusters=2, affinity='precomputed', linkage='average')\n\n# Fit the model to the distance matrix\nclustering.fit(dist_matrix)\n\n# Get the cluster labels\ncluster_labels = clustering.labels_\n", "metadata": {"problem_id": 881, "library_problem_id": 64, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 63}}
{"id": 882, "code": "from sklearn.cluster import AgglomerativeClustering\n\n# Convert the 2-D list to a numpy array\nsimM = np.array(simM)\n\n# Perform hierarchical clustering\ncluster = AgglomerativeClustering(n_clusters=2, affinity='precomputed', linkage='average')\ncluster_labels = cluster.fit_predict(simM)\n", "metadata": {"problem_id": 882, "library_problem_id": 65, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 63}}
{"id": 883, "code": "from scipy.cluster.hierarchy import linkage, fcluster\n\n# Compute the linkage matrix\nZ = linkage(data_matrix, 'ward')\n\n# Perform clustering\ncluster_labels = fcluster(Z, 2, criterion='maxclust')\n", "metadata": {"problem_id": 883, "library_problem_id": 66, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 66}}
{"id": 884, "code": "from scipy.cluster.hierarchy import linkage, fcluster\n\n# compute the linkage matrix\nZ = linkage(data_matrix, 'ward')\n\n# perform clustering\ncluster_labels = fcluster(Z, 2, criterion='maxclust')\n", "metadata": {"problem_id": 884, "library_problem_id": 67, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 66}}
{"id": 885, "code": "from scipy.cluster.hierarchy import linkage, fcluster\n\n# Convert your data into a numpy array\nsimM = np.array(simM)\n\n# Perform hierarchical clustering\nZ = linkage(simM, 'ward')\ncluster_labels = fcluster(Z, 2, criterion='maxclust')\n", "metadata": {"problem_id": 885, "library_problem_id": 68, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 66}}
{"id": 886, "code": "from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\ncentered_scaled_data = scaler.fit_transform(data)", "metadata": {"problem_id": 886, "library_problem_id": 69, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 69}}
{"id": 887, "code": "from sklearn.preprocessing import StandardScaler\nscaler = StandardScaler()\ncentered_scaled_data = scaler.fit_transform(data)", "metadata": {"problem_id": 887, "library_problem_id": 70, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 69}}
{"id": 888, "code": "from sklearn.preprocessing import PowerTransformer\npt = PowerTransformer(method='box-cox')\nbox_cox_data = pt.fit_transform(data)\n", "metadata": {"problem_id": 888, "library_problem_id": 71, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 71}}
{"id": 889, "code": "from scipy.special import boxcox\n\nbox_cox_data, fitted_lambda = boxcox(data)", "metadata": {"problem_id": 889, "library_problem_id": 72, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 71}}
{"id": 890, "code": "from sklearn.preprocessing import PowerTransformer\npt = PowerTransformer(method='yeo-johnson')\nyeo_johnson_data = pt.fit_transform(data)\n", "metadata": {"problem_id": 890, "library_problem_id": 73, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 73}}
{"id": 891, "code": "from sklearn.preprocessing import PowerTransformer\npt = PowerTransformer(method='yeo-johnson')\nyeo_johnson_data = pt.fit_transform(data)\n", "metadata": {"problem_id": 891, "library_problem_id": 74, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 73}}
{"id": 892, "code": "vectorizer = CountVectorizer()\ntransformed_text = vectorizer.fit_transform(text)\n", "metadata": {"problem_id": 892, "library_problem_id": 75, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 75}}
{"id": 893, "code": "from sklearn.model_selection import train_test_split\n\n# Split the data into training and testing sets\nx_train, x_test, y_train, y_test = train_test_split(dataset.iloc[:, :-1], dataset.iloc[:, -1], test_size=0.2, random_state=42)\n", "metadata": {"problem_id": 893, "library_problem_id": 76, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 76}}
{"id": 894, "code": "from sklearn.model_selection import train_test_split\n\n# Split the data into features and target\nX = data.iloc[:, :-1]\ny = data.iloc[:, -1]\n\n# Split the data into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n", "metadata": {"problem_id": 894, "library_problem_id": 77, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 76}}
{"id": 895, "code": "from sklearn.model_selection import train_test_split\n\n# Split the data into train and test sets\nx_train, x_test, y_train, y_test = train_test_split(dataset.iloc[:, :-1], dataset.iloc[:, -1], test_size=0.2, random_state=42)\n", "metadata": {"problem_id": 895, "library_problem_id": 78, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 76}}
{"id": 896, "code": "\n    from sklearn.model_selection import train_test_split\n    X = data.iloc[:, :-1]\n    y = data.iloc[:, -1]\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n    return X_train, y_train, X_test, y_test\n    ### END SOLUTION\n\n\nA: Here is a solution using sklearn's train_test_split function:\n\n```python\nfrom sklearn.model_selection import train_test_split\n\n# Split the data into features and target variable\nX = dataset.iloc[:, :-1]\ny = dataset.iloc[:, -1]\n\n# Split the data into training and testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n```\n\nIn this code, the `test_size` parameter is set to 0.2, which means that 20% of the data will be used for testing and the remaining 80% will be used for training. The `random_state` parameter is set to 42, which ensures that the split is reproducible.\n\nThe `iloc` function is used to select all rows and all columns except the last one, and the `iloc` function is used to select only the last column.\n\nThe `train_test_split` function from sklearn.model_selection module is used to split the data into training and testing sets.\n\nThe `X` variable contains the features (columns except the last one) and the `y` variable contains the target variable (the last column).\n\nThe `train_test_split` function returns four variables: `X_train`, `y_train`, `X_test`, `y_test`. These variables contain the training and testing sets for the features and the target variable, respectively.\n", "metadata": {"problem_id": 896, "library_problem_id": 79, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 76}}
{"id": 897, "code": "\nmse = df['mse'].values\nmse = mse.reshape(-1,1)\nkmeans = KMeans(n_clusters=2, n_init=10).fit(mse)\nlabels = kmeans.predict(mse)\n", "metadata": {"problem_id": 897, "library_problem_id": 80, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 80}}
{"id": 898, "code": "\n# Reshape the data\nX = df['mse'].values.reshape(-1,1)\n\n# Fit the model\nkmeans = KMeans(n_clusters=2, n_init=10).fit(X)\n\n# Get the labels\nlabels = kmeans.predict(X)\n\n", "metadata": {"problem_id": 898, "library_problem_id": 81, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 80}}
{"id": 899, "code": "svc = LinearSVC(C=1.0, penalty='l1', dual=False)\nsvc.fit(X, y)\nselected_feature_names = np.asarray(vectorizer.get_feature_names())[np.where(svc.coef_ != 0)]\n", "metadata": {"problem_id": 899, "library_problem_id": 82, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 82}}
{"id": 900, "code": "svc = LinearSVC(C=1.0, penalty='l1', dual=False)\nsvc.fit(X, y)\nselected_feature_names = np.asarray(vectorizer.get_feature_names())[np.where(svc.coef_ != 0)]\n", "metadata": {"problem_id": 900, "library_problem_id": 83, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 82}}
{"id": 901, "code": "\n    svc = LinearSVC(C=1.0, penalty='l1', dual=False)\n    svc.fit(X, y)\n    selected_feature_names = np.asarray(vectorizer.get_feature_names())[featureSelector.get_support()]\n    return selected_feature_names\n    ### END SOLUTION\n\n# Call the function\nselected_feature_names = solve(corpus, y, vectorizer, X)\nprint(selected_feature_names)\n", "metadata": {"problem_id": 901, "library_problem_id": 84, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 82}}
{"id": 902, "code": "vectorizer = CountVectorizer(stop_words=\"english\",binary=True,lowercase=False, vocabulary={'Jscript','.Net','TypeScript','SQL', 'NodeJS','Angular','Mongo','CSS','Python','PHP','Photoshop','Oracle','Linux','C++',\"Java\",'TeamCity','Frontend','Backend','Full stack', 'UI Design', 'Web','Integration','Database design','UX'})\nX = vectorizer.fit_transform(corpus)\nfeature_names = vectorizer.get_feature_names_out()\nX = X.toarray()\n", "metadata": {"problem_id": 902, "library_problem_id": 85, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 85}}
{"id": 903, "code": "vectorizer = CountVectorizer(stop_words=\"english\",binary=True,lowercase=False, vocabulary={'Jscript','.Net','TypeScript','NodeJS','Angular','Mongo','CSS','Python','PHP','Photoshop','Oracle','Linux','C++',\"Java\",'TeamCity','Frontend','Backend','Full stack', 'UI Design', 'Web','Integration','Database design','UX'})\nX = vectorizer.fit_transform(corpus)\nfeature_names = vectorizer.get_feature_names_out()\nX = X.toarray()\n", "metadata": {"problem_id": 903, "library_problem_id": 86, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 85}}
{"id": 904, "code": "\nvectorizer = CountVectorizer(stop_words=\"english\",binary=True,lowercase=False,vocabulary={'Jscript','.Net','TypeScript','SQL', 'NodeJS','Angular','Mongo','CSS','Python','PHP','Photoshop','Oracle','Linux','C++',\"Java\",'TeamCity','Frontend','Backend','Full stack', 'UI Design', 'Web','Integration','Database design','UX'})\nX = vectorizer.fit_transform(corpus)\n\n# Get the feature names in the same order as the vocabulary\nfeature_names = vectorizer.get_feature_names_out()\n\n# Convert the sparse matrix to a numpy array\nX_array = X.toarray()\n\n# Create a numpy array with the same shape as X_array but filled with zeros\n# This will be used to create the desired output\noutput = np.zeros(X_array.shape)\n\n# Loop over the rows of X_array\nfor i in range(X_array.shape[0]):\n    # Loop over the columns of X_array\n    for j in range(X_array.shape[1]):\n        # If the value at the current position is greater than 0, set the corresponding\n        # value in output to 1\n        if X_array[i, j] > 0:\n            output[i, j] = 1\n\nfeature_names, output\n", "metadata": {"problem_id": 904, "library_problem_id": 87, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 85}}
{"id": 905, "code": "vectorizer = CountVectorizer(stop_words=\"english\",binary=True,lowercase=False,vocabulary={'Jscript','.Net','TypeScript','NodeJS','Angular','Mongo','CSS','Python','PHP','Photoshop','Oracle','Linux','C++',\"Java\",'TeamCity','Frontend','Backend','Full stack', 'UI Design', 'Web','Integration','Database design','UX'})\nX = vectorizer.fit_transform(corpus)\nfeature_names = vectorizer.get_feature_names_out()\nX = X.toarray()\n\n# Reverse the order of the features\nfeature_names = feature_names[::-1]\nX = X[:,::-1]\n", "metadata": {"problem_id": 905, "library_problem_id": 88, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 85}}
{"id": 906, "code": "\nslopes = []\nfor col in df1.columns[1:]:\n    df2 = df1[['Time', col]].dropna()\n    X = df2['Time'].values.reshape(-1,1)\n    Y = df2[col].values.reshape(-1,1)\n    regression = LinearRegression().fit(X, Y)\n    slopes.append(regression.coef_[0][0])\n\nslopes = np.array(slopes)\n", "metadata": {"problem_id": 906, "library_problem_id": 89, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 89}}
{"id": 907, "code": "\nslopes = []\nfor col in df1.columns[1:]:\n    df2 = df1[['Time', col]].dropna()\n    X = df2['Time'].values.reshape(-1,1)\n    Y = df2[col].values.reshape(-1,1)\n    regression = LinearRegression().fit(X, Y)\n    slopes.append(regression.coef_[0][0])\n\nslopes = np.array(slopes)\n", "metadata": {"problem_id": 907, "library_problem_id": 90, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 89}}
{"id": 908, "code": "\n# Create a label encoder object\nle = LabelEncoder()\n\n# Fit and transform the 'Sex' column\ndf['Sex'] = le.fit_transform(df['Sex'])\n\ntransformed_df = df\n", "metadata": {"problem_id": 908, "library_problem_id": 91, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 91}}
{"id": 909, "code": "\n# Initialize the LabelEncoder\nle = LabelEncoder()\n\n# Fit and transform the 'Sex' column\ndf['Sex'] = le.fit_transform(df['Sex'])\n\ntransformed_df = df\n", "metadata": {"problem_id": 909, "library_problem_id": 92, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 91}}
{"id": 910, "code": "\n    le = LabelEncoder()\n    df['Sex'] = le.fit_transform(df['Sex'])\n    return df\n    ### END SOLUTION\n\ndf = Transform(df)\n", "metadata": {"problem_id": 910, "library_problem_id": 93, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 91}}
{"id": 911, "code": "# ElasticNet Regression\nElasticNet = linear_model.ElasticNet() # create a lasso instance\nElasticNet.fit(X_train, y_train) # fit data\n\n# print(lasso.coef_)\n# print (lasso.intercept_) # print out the coefficients\n\nprint (\"R^2 for training set:\"),\nprint (ElasticNet.score(X_train, y_train))\n\nprint ('-'*50)\n\nprint (\"R^2 for test set:\"),\nprint (ElasticNet.score(X_test, y_test))\n", "metadata": {"problem_id": 911, "library_problem_id": 94, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 94}}
{"id": 912, "code": "scaler = MinMaxScaler()\nnp_array_transformed = scaler.fit_transform(np_array)\ntransformed = pd.DataFrame(np_array_transformed)\n", "metadata": {"problem_id": 912, "library_problem_id": 95, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 95}}
{"id": 913, "code": "scaler = MinMaxScaler()\nnp_array_transformed = scaler.fit_transform(np_array)\ntransformed = pd.DataFrame(np_array_transformed)\n", "metadata": {"problem_id": 913, "library_problem_id": 96, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 95}}
{"id": 914, "code": "\n    scaler = MinMaxScaler()\n    a = scaler.fit_transform(a)\n    return a\n    ### END SOLUTION\n\nnp_array = Transform(np_array)\n", "metadata": {"problem_id": 914, "library_problem_id": 97, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 95}}
{"id": 915, "code": "close_buy1 = close[:-1]\nm5 = ma_50[:-1]\nm10 = ma_100[:-1]\nma20 = ma_200[:-1]\nb = np.concatenate([close_buy1, m5, m10, ma20], axis=1)\n\npredict = clf.predict(b)\n", "metadata": {"problem_id": 915, "library_problem_id": 98, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 98}}
{"id": 916, "code": "\n# Convert string data to numerical data\nnew_X = pd.get_dummies(pd.DataFrame(X))\nclf.fit(new_X, ['2', '3'])\n", "metadata": {"problem_id": 916, "library_problem_id": 99, "library": "Sklearn", "test_case_cnt": 0, "perturbation_type": "Origin", "perturbation_origin_id": 99}}
{"id": 917, "code": "\nnew_X = []\nfor i in X:\n    new_X.append([int(j) for j in i])\nclf.fit(new_X, ['2', '3'])\n", "metadata": {"problem_id": 917, "library_problem_id": 100, "library": "Sklearn", "test_case_cnt": 0, "perturbation_type": "Surface", "perturbation_origin_id": 99}}
{"id": 918, "code": "\n# Convert string data to numerical data\nnew_X = pd.DataFrame(X, columns=['feature1', 'feature2'])\nnew_X = new_X.apply(LabelEncoder().fit_transform)\nclf.fit(new_X, ['4', '5'])\n", "metadata": {"problem_id": 918, "library_problem_id": 101, "library": "Sklearn", "test_case_cnt": 0, "perturbation_type": "Surface", "perturbation_origin_id": 99}}
{"id": 919, "code": "\n# Separating the data into dependent and independent variables\nX = dataframe.iloc[:, :-1].astype(float)\ny = dataframe.iloc[:, -1]\n\nlogReg = LogisticRegression()\nlogReg.fit(X, y)\n\n# Predict\npredict = logReg.predict(X)\nprint(predict)\n", "metadata": {"problem_id": 919, "library_problem_id": 102, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 102}}
{"id": 920, "code": "\n# Separate the features and the target variable\nX = dataframe.iloc[:, :-1].astype(float)\ny = dataframe.iloc[:, -1]\nlogReg = LogisticRegression()\nlogReg.fit(X, y)\n\n# Predict the target variable\npredict = logReg.predict(X)\nprint(predict)\n", "metadata": {"problem_id": 920, "library_problem_id": 103, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 102}}
{"id": 921, "code": "\n# First, we need to find the index where the test set should start\ntest_start_index = int(len(features_dataframe) * train_size)\n\n# Then, we split the dataframe into train and test\ntrain_dataframe = features_dataframe.iloc[:test_start_index]\ntest_dataframe = features_dataframe.iloc[test_start_index:]\n\n# Sort the dataframes by date\ntrain_dataframe = train_dataframe.sort_values(\"date\")\ntest_dataframe = test_dataframe.sort_values(\"date\")\n\n# Now, split the dataframe into train and test\ntrain_dataframe, test_dataframe = train_test_split(features_dataframe, test_size=0.2)\n", "metadata": {"problem_id": 921, "library_problem_id": 104, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 104}}
{"id": 922, "code": "\n# First, we need to convert the 'date' column to datetime format\nfeatures_dataframe['date'] = pd.to_datetime(features_dataframe['date'])\n\n# Then, sort the dataframe by date\nfeatures_dataframe = features_dataframe.sort_values(by='date')\n\n# Get the index of the last date in the sorted dataframe\nlast_date_index = len(features_dataframe)\n\n# Get the index of the first date in the sorted dataframe\nfirst_date_index = 0\n\n# Calculate the number of days between the first and last date\nnum_days = last_date_index - first_date_index\n\n# Calculate the number of days to be used for training\ntrain_days = int(num_days * train_size)\n\n# Get the train dataframe\ntrain_dataframe = features_dataframe[:train_days]\n\n# Get the test dataframe\ntest_dataframe = features_dataframe[train_days:]\n", "metadata": {"problem_id": 922, "library_problem_id": 105, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 104}}
{"id": 923, "code": "\n    features_dataframe['date'] = pd.to_datetime(features_dataframe['date'])\n    features_dataframe = features_dataframe.set_index('date')\n    last_day = features_dataframe.index[-1]\n    train_dataframe = features_dataframe.loc[features_dataframe.index < last_day - pd.DateOffset(days=int(len(features_dataframe) * 0.2))]\n    test_dataframe = features_dataframe.loc[features_dataframe.index >= last_day - pd.DateOffset(days=int(len(features_dataframe) * 0.2))]\n    return train_dataframe, test_dataframe\n    ### END SOLUTION\n\ntrain_dataframe, test_dataframe = solve(features_dataframe)\n", "metadata": {"problem_id": 923, "library_problem_id": 106, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 104}}
{"id": 924, "code": "df[['X2_scale', 'X3_scale']] = scaler.fit_transform(df[['X2', 'X3']])\n", "metadata": {"problem_id": 924, "library_problem_id": 107, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 107}}
{"id": 925, "code": "for col in myData.columns[2:4]:\n    myData['new_' + col] = scaler.fit_transform(myData[[col]])\n", "metadata": {"problem_id": 925, "library_problem_id": 108, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 107}}
{"id": 926, "code": "count = CountVectorizer(lowercase=False)\nvocabulary = count.fit_transform([words])\nfeature_names = count.get_feature_names()\nprint(feature_names)\n", "metadata": {"problem_id": 926, "library_problem_id": 109, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 109}}
{"id": 927, "code": "count = CountVectorizer(lowercase=False, token_pattern='[^\\s]+')\nvocabulary = count.fit_transform([words])\nfeature_names = count.get_feature_names_out()\nprint(feature_names)\n", "metadata": {"problem_id": 927, "library_problem_id": 110, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 109}}
{"id": 928, "code": "full_results = pd.DataFrame(GridSearch_fitted.cv_results_)\n", "metadata": {"problem_id": 928, "library_problem_id": 111, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 111}}
{"id": 929, "code": "full_results = pd.DataFrame(GridSearch_fitted.cv_results_)\nfull_results = full_results.sort_values('mean_fit_time')\n", "metadata": {"problem_id": 929, "library_problem_id": 112, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 111}}
{"id": 930, "code": "\nfrom sklearn.externals.joblib import dump, load\n\n# Save the model\ndump(fitted_model, 'sklearn_model.pkl')\n", "metadata": {"problem_id": 930, "library_problem_id": 113, "library": "Sklearn", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 113}}
{"id": 931, "code": "\n# TF-IDF vectors\ntfidf_matrix = tfidf.fit_transform(df['description'])\n\n# Compute cosine similarity\ncosine_similarity_matrix = sklearn.metrics.pairwise.cosine_similarity(tfidf_matrix, tfidf_matrix)\n", "metadata": {"problem_id": 931, "library_problem_id": 114, "library": "Sklearn", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 114}}
{"id": 932, "code": "\n\n# Get the current learning rate\ncurrent_lr = optim.param_groups[0]['lr']\nprint('Current learning rate:', current_lr)\n\n# Create a new optimizer with a new learning rate\noptim = torch.optim.SGD(..., lr=0.001)\n\n# Get the new learning rate\nnew_lr = optim.param_groups[0]['lr']\nprint('New learning rate:', new_lr)\n", "metadata": {"problem_id": 932, "library_problem_id": 0, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 0}}
{"id": 933, "code": "\n\n# Define a custom learning rate scheduler\nclass CustomLearningRateScheduler(torch.optim.lr_scheduler._LRScheduler):\n    def __init__(self, optimizer, last_epoch=-1):\n        self.optimizer = optimizer\n        self.base_lrs = [group['lr'] for group in optimizer.param_groups]\n        super(CustomLearningRateScheduler, self).__init__(optimizer, last_epoch)\n\n    def step(self, epoch=None):\n        if epoch is not None:\n            self.last_epoch = epoch\n            self.update_lr()\n        else:\n            super(CustomLearningRateScheduler, self).step()\n\n    def update_lr(self):\n        for param_group, lr in zip(self.optimizer.param_groups, self.base_lrs):\n            param_group['lr'] = lr * (self.last_epoch / self.decay)\n\n# Create an instance of the custom scheduler\nscheduler = CustomLearningRateScheduler(optim)\n\n# Set the learning rate to 0.001\nfor param_group in optim.param_groups:\n    param_group['lr'] = 0.001\n\n# Train your model\nfor epoch in range(num_epochs):\n    train_model(model, optim, scheduler)\n", "metadata": {"problem_id": 933, "library_problem_id": 1, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 0}}
{"id": 934, "code": "\n\n# Get the current learning rate\ncurrent_lr = optim.param_groups[0]['lr']\nprint('Current learning rate:', current_lr)\n\n# Create a new optimizer with a new learning rate\noptim = torch.optim.SGD(..., lr=0.0005)\n\n# Get the new learning rate\nnew_lr = optim.param_groups[0]['lr']\nprint('New learning rate:', new_lr)\n", "metadata": {"problem_id": 934, "library_problem_id": 2, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 0}}
{"id": 935, "code": "\n\n# Define a custom learning rate scheduler\nclass CustomLearningRateScheduler(torch.optim.lr_scheduler._LRScheduler):\n    def __init__(self, optimizer, last_epoch=-1):\n        self.optimizer = optimizer\n        self.base_lrs = [group['lr'] for group in optimizer.param_groups]\n        super(CustomLearningRateScheduler, self).__init__(optimizer, last_epoch)\n\n    def step(self, epoch=None):\n        if epoch is not None:\n            self.last_epoch = epoch\n            self.update_lr()\n        else:\n            super(CustomLearningRateScheduler, self).step()\n\n    def update_lr(self):\n        for param_group, lr in zip(self.optimizer.param_groups, self.base_lrs):\n            param_group['lr'] = lr * (1 + 0.1 * np.sin(self.last_epoch / 10))\n\n# Create the scheduler\nscheduler = CustomLearningRateScheduler(optim)\n", "metadata": {"problem_id": 935, "library_problem_id": 3, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 0}}
{"id": 936, "code": "# Convert gensim's word2vec model to PyTorch's tensor\nweight = torch.tensor(word2vec[word2vec.wv.vocab], dtype=torch.float32)\n\n# Create an embedding layer with the weights\nembedding = torch.nn.Embedding.from_pretrained(weight)\n\n# Now you can use the embedding layer to embed your input data\nembedded_input = embedding(input_Tensor)\n", "metadata": {"problem_id": 936, "library_problem_id": 4, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 4}}
{"id": 937, "code": "\n    word2vec_weights = torch.tensor(word2vec[word2vec.wv.vocab], dtype=torch.float32)\n    embedding = torch.nn.Embedding.from_pretrained(word2vec_weights)\n    input_Tensor = embedding(input_Tensor)\n    return input_Tensor\n    ### END SOLUTION\nget_embedded_input(input_Tensor)\n", "metadata": {"problem_id": 937, "library_problem_id": 5, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 4}}
{"id": 938, "code": "px = pd.DataFrame(x.numpy())", "metadata": {"problem_id": 938, "library_problem_id": 6, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 6}}
{"id": 939, "code": "px = pd.DataFrame(x.numpy())", "metadata": {"problem_id": 939, "library_problem_id": 7, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 6}}
{"id": 940, "code": "px = pd.DataFrame(x.numpy())\n", "metadata": {"problem_id": 940, "library_problem_id": 8, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 6}}
{"id": 941, "code": "C = B[:, A_log]", "metadata": {"problem_id": 941, "library_problem_id": 9, "library": "Pytorch", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 9}}
{"id": 942, "code": "\nC = torch.masked_select(B, A_logical.bool())\n", "metadata": {"problem_id": 942, "library_problem_id": 10, "library": "Pytorch", "test_case_cnt": 3, "perturbation_type": "Surface", "perturbation_origin_id": 9}}
{"id": 943, "code": "\nC = B[:, A_log]", "metadata": {"problem_id": 943, "library_problem_id": 11, "library": "Pytorch", "test_case_cnt": 3, "perturbation_type": "Surface", "perturbation_origin_id": 9}}
{"id": 944, "code": "C = B[:, A_log]", "metadata": {"problem_id": 944, "library_problem_id": 12, "library": "Pytorch", "test_case_cnt": 3, "perturbation_type": "Semantic", "perturbation_origin_id": 9}}
{"id": 945, "code": " ###\n    C = B[:, A_log]\n    return C\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 945, "library_problem_id": 13, "library": "Pytorch", "test_case_cnt": 3, "perturbation_type": "Surface", "perturbation_origin_id": 9}}
{"id": 946, "code": "\nC = B[:, A_log]", "metadata": {"problem_id": 946, "library_problem_id": 14, "library": "Pytorch", "test_case_cnt": 3, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 9}}
{"id": 947, "code": "\nidx = idx.cpu().numpy()\nB = B.cpu().numpy()\n\nC = torch.from_numpy(B[:, idx])\n", "metadata": {"problem_id": 947, "library_problem_id": 15, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 9}}
{"id": 948, "code": "\n# Convert numpy array to pandas dataframe\ndf = pd.DataFrame(x_array)\n\n# Convert pandas dataframe to torch tensor\nx_tensor = torch.tensor(df.values, dtype=torch.float)\n", "metadata": {"problem_id": 948, "library_problem_id": 16, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 16}}
{"id": 949, "code": "\n# Convert numpy array to pandas dataframe\ndf = pd.DataFrame(x_array)\n\n# Convert pandas dataframe to torch tensor\nx_tensor = torch.tensor(df.values, dtype=torch.float)\n", "metadata": {"problem_id": 949, "library_problem_id": 17, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 16}}
{"id": 950, "code": " ###\n    return torch.tensor(np.array(a))\n    ### END SOLUTION ###\n\n# Test the function\nprint(Convert(x_array))\n", "metadata": {"problem_id": 950, "library_problem_id": 18, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 16}}
{"id": 951, "code": "\nmax_len = max(lens)\nmask = torch.zeros(len(lens), max_len)\nfor i, length in enumerate(lens):\n    mask[i, :length] = 1\n", "metadata": {"problem_id": 951, "library_problem_id": 19, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 19}}
{"id": 952, "code": "\nmax_len = max(lens)\nmask = torch.zeros(len(lens), max_len)\nfor i, length in enumerate(lens):\n    mask[i, :length] = 1\n", "metadata": {"problem_id": 952, "library_problem_id": 20, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 19}}
{"id": 953, "code": "\nmax_len = max(lens)\nmask = torch.zeros(len(lens), max_len)\nfor i, length in enumerate(lens):\n    mask[i, :length] = 1\n", "metadata": {"problem_id": 953, "library_problem_id": 21, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 19}}
{"id": 954, "code": " ###\n    max_len = max(lens)\n    batch_size = len(lens)\n    mask = torch.zeros(batch_size, max_len)\n    for i, length in enumerate(lens):\n        mask[i, :length] = 1\n    return mask.long()\n    ### END SOLUTION ###\n\nget_mask(lens)\n", "metadata": {"problem_id": 954, "library_problem_id": 22, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 19}}
{"id": 955, "code": "\n# Create a 2D tensor with the same size as the input tensor\ndiag_ele = torch.ones(Tensor_2D.size(0), device=Tensor_2D.device)\n\n# Create a 3D tensor with the same size as the input tensor\nTensor_3D = torch.diag(diag_ele)\n\nprint(Tensor_3D.shape)\n", "metadata": {"problem_id": 955, "library_problem_id": 23, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 23}}
{"id": 956, "code": " ###\n    return torch.diag(t)\n    ### END SOLUTION ###\n\nTensor_3D = Convert(Tensor_2D)\n", "metadata": {"problem_id": 956, "library_problem_id": 24, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 23}}
{"id": 957, "code": "a = torch.cat([a.unsqueeze(0), b.unsqueeze(0)], 0)\nab = torch.stack([a, b], 0)\n", "metadata": {"problem_id": 957, "library_problem_id": 25, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 25}}
{"id": 958, "code": "\n# Resize a and b to match the size of the tensor you want to create\na = a.resize_(114, 514)\nb = b.resize_(24, 514)\n\n# Stack a and b along the first dimension\nab = torch.stack((a, b), 0)\n\n", "metadata": {"problem_id": 958, "library_problem_id": 26, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 25}}
{"id": 959, "code": " ###\n    ab = torch.cat([a, b], 0)\n    return ab\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 959, "library_problem_id": 27, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 25}}
{"id": 960, "code": "\nmask = torch.arange(max(lengths)).expand_as(lengths).t()\na[mask] = 0\n", "metadata": {"problem_id": 960, "library_problem_id": 28, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 28}}
{"id": 961, "code": "\nmask = torch.arange(max(lengths)).expand_as(lengths).to(device) < lengths.unsqueeze(1)\na[mask] = 2333\n", "metadata": {"problem_id": 961, "library_problem_id": 29, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 28}}
{"id": 962, "code": "\nmask = torch.arange(max(lengths)).expand_as(lengths).to(device) < lengths.unsqueeze(1)\na[mask] = 0\n", "metadata": {"problem_id": 962, "library_problem_id": 30, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 28}}
{"id": 963, "code": "\nmask = torch.arange(max(lengths)).expand(*lengths.shape, 1000).to(device)\nmask = mask[:, :lengths, :]\na.masked_fill_(mask == 0, 2333)\n", "metadata": {"problem_id": 963, "library_problem_id": 31, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 28}}
{"id": 964, "code": "tensor_of_tensors = torch.stack(list_of_tensors)\n", "metadata": {"problem_id": 964, "library_problem_id": 32, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 32}}
{"id": 965, "code": "\nnew_tensors = torch.tensor(list)\n", "metadata": {"problem_id": 965, "library_problem_id": 33, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 32}}
{"id": 966, "code": " ###\n    tensor_of_tensors = torch.stack(lt)\n    return tensor_of_tensors\n    ### END SOLUTION ###\n\nlist_of_tensors = [ torch.randn(3), torch.randn(3), torch.randn(3)]\ntensor_of_tensors = Convert(list_of_tensors)\n", "metadata": {"problem_id": 966, "library_problem_id": 34, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 32}}
{"id": 967, "code": "tensor_of_tensors = torch.tensor(list_of_tensors, dtype=torch.float32)\n", "metadata": {"problem_id": 967, "library_problem_id": 35, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 32}}
{"id": 968, "code": "\nresult = torch.index_select(t, 0, torch.tensor(idx))\n", "metadata": {"problem_id": 968, "library_problem_id": 36, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 36}}
{"id": 969, "code": "\nresult = torch.index_select(t, 0, torch.tensor(idx).long())\n", "metadata": {"problem_id": 969, "library_problem_id": 37, "library": "Pytorch", "test_case_cnt": 3, "perturbation_type": "Surface", "perturbation_origin_id": 36}}
{"id": 970, "code": "\nresult = torch.index_select(t, 0, torch.tensor(idx))\n", "metadata": {"problem_id": 970, "library_problem_id": 38, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 36}}
{"id": 971, "code": "\n# Find the maximum score for each id\nmax_scores = torch.max(scores, 1)[0]\n\n# Gather the scores for the selected ids\nselected_scores = torch.gather(max_scores, 0, ids)\n\n# Gather the corresponding x values\nselected_x = torch.gather(x, 0, ids)\n\n# Now you can use selected_x\n", "metadata": {"problem_id": 971, "library_problem_id": 39, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 39}}
{"id": 972, "code": "\n# Find the maximum score for each id\nmax_scores = torch.max(scores, 1)[0]\n\n# Gather the scores for the selected ids\nresult = torch.gather(x, 1, ids.unsqueeze(-1).expand(-1,-1,114))\n\n# Reshape the result to match the original shape\nresult = result.view(-1,114)\n", "metadata": {"problem_id": 972, "library_problem_id": 40, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 39}}
{"id": 973, "code": "\n# Create a mask for the selected indices\nmask = torch.tensor(ids[:, 0] == 1)\n\n# Gather the selected scores\nselected_scores = torch.masked_select(x, mask[:, None])\n\n# Find the maximum score\nmax_score = torch.max(selected_scores)\n\n# Create a mask for the maximum score\nmax_score_mask = (selected_scores == max_score)\n\n# Gather the maximum score\nresult = torch.masked_select(x, max_score_mask)\n\nEND SOLUTION\n", "metadata": {"problem_id": 973, "library_problem_id": 41, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 39}}
{"id": 974, "code": "_, predicted = torch.max(softmax_output, 1)\ny = predicted.view(-1,1)\n", "metadata": {"problem_id": 974, "library_problem_id": 42, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 42}}
{"id": 975, "code": "_, y_pred = torch.max(softmax_output, 1)\ny = y_pred.view(-1,1)\n", "metadata": {"problem_id": 975, "library_problem_id": 43, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 42}}
{"id": 976, "code": "_, predicted = torch.max(softmax_output, 1)\ny = predicted.view(-1).data.tolist()\n", "metadata": {"problem_id": 976, "library_problem_id": 44, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 42}}
{"id": 977, "code": " ###\n    _, predicted = torch.max(softmax_output, 1)\n    return predicted\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 977, "library_problem_id": 45, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 42}}
{"id": 978, "code": "\n# Get the maximum value from each row\nmax_values = torch.max(softmax_output, 1)[0]\n\n# Get the indices of the maximum values\nindices = torch.nonzero(softmax_output == max_values).squeeze()\n\n# Convert the indices to LongTensor\ny = indices.long()\n\nprint(y)\n", "metadata": {"problem_id": 978, "library_problem_id": 46, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 42}}
{"id": 979, "code": "\ndef cross_entropy2d(input, target, weight=None, size_average=True):\n    n, c, w, h = input.size()\n    log_p = F.log_softmax(input, dim=1)\n    log_p = log_p.permute(0, 2, 3, 1).contiguous().view(-1, c)\n    log_p = log_p[target >= 0]\n    log_p = log_p.view(-1, c)\n    mask = target >= 0\n    target = target[mask]\n    loss = F.nll_loss(log_p, target.view(-1), weight=weight, size_average=False)\n    if size_average:\n        loss /= mask.data.sum()\n    return loss\n\nimages = Variable(torch.randn(5, 3, 4, 4))\nlabels = Variable(torch.LongTensor(5, 4, 4).random_(3))\nloss = cross_entropy2d(images, labels)\nprint(loss)\n", "metadata": {"problem_id": 979, "library_problem_id": 47, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 47}}
{"id": 980, "code": "cnt_equal = torch.sum((A == B).float())", "metadata": {"problem_id": 980, "library_problem_id": 48, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 48}}
{"id": 981, "code": "cnt_equal = torch.sum((A == B).float())", "metadata": {"problem_id": 981, "library_problem_id": 49, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 48}}
{"id": 982, "code": "cnt_not_equal = torch.sum((A != B).float())", "metadata": {"problem_id": 982, "library_problem_id": 50, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 48}}
{"id": 983, "code": " ###\n    cnt_equal = torch.sum(A == B)\n    return cnt_equal\n    ### END SOLUTION ###\n", "metadata": {"problem_id": 983, "library_problem_id": 51, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 48}}
{"id": 984, "code": "\ncnt_equal = torch.sum((A[-x:] == B[-x:]).bool())\n", "metadata": {"problem_id": 984, "library_problem_id": 52, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 48}}
{"id": 985, "code": "\ncnt_not_equal = torch.sum((A[-x:] != B[-x:]).float())\n", "metadata": {"problem_id": 985, "library_problem_id": 53, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Difficult-Rewrite", "perturbation_origin_id": 48}}
{"id": 986, "code": "\n\n# Create a list to store the tensors\ntensors_31 = []\n\n# Loop over the dimension you want to split on\nfor i in range(chunk_dim):\n    # Create a mask to select the relevant elements\n    mask = torch.ones_like(a[:,:,:,:,0], dtype=torch.bool)\n    mask[:,:,:,:,0] = mask[:,:,:,:,0]*(a[:,:,:,:,0] == i)\n    \n    # Apply the mask to the tensor\n    a_selected = torch.masked_select(a, mask)\n    \n    # Split the tensor into chunks of size 10\n    tensors_31.append(a_selected.reshape(1,3,10,10,1))\n\n# Convert the list of tensors to a tensor\ntensors_31 = torch.stack(tensors_31)\n", "metadata": {"problem_id": 986, "library_problem_id": 54, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 54}}
{"id": 987, "code": "\n\n# Create a list to store the tensors\ntensors_31 = []\n\n# Loop over the dimension you want to split on\nfor i in range(chunk_dim):\n    # Create a mask to select the data for this chunk\n    mask = torch.tensor([True] * 10 + [False] * 40)\n    mask = mask.unsqueeze(0).unsqueeze(2).unsqueeze(3).unsqueeze(4)\n\n    # Apply the mask to the tensor\n    a_chunk = a[mask]\n\n    # Append the chunk to the list\n    tensors_31.append(a_chunk)\n\n# Convert the list to a tensor\ntensors_31 = torch.stack(tensors_31)\n", "metadata": {"problem_id": 987, "library_problem_id": 55, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 54}}
{"id": 988, "code": "\noutput = torch.masked_select(clean_input_spectrogram, mask.bool())\n", "metadata": {"problem_id": 988, "library_problem_id": 56, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 56}}
{"id": 989, "code": "\noutput = torch.where(mask == 0, clean_input_spectrogram, output)\n", "metadata": {"problem_id": 989, "library_problem_id": 57, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 56}}
{"id": 990, "code": "\nsign_x = torch.sign(x)\nsign_y = torch.sign(y)\nabs_x = torch.abs(x)\nabs_y = torch.abs(y)\n\nmin_x = torch.min(abs_x)\nmin_y = torch.min(abs_y)\n\nsigned_min = torch.where(min_x < min_y, sign_x * min_x, sign_y * min_y)\n", "metadata": {"problem_id": 990, "library_problem_id": 58, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 58}}
{"id": 991, "code": "sign_x = torch.sign(x)\nsign_y = torch.sign(y)\nmax = torch.max(torch.abs(x), torch.abs(y))\nsigned_max = torch.where(max == torch.abs(x), sign_x, sign_y)\n", "metadata": {"problem_id": 991, "library_problem_id": 59, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Semantic", "perturbation_origin_id": 58}}
{"id": 992, "code": "\n    sign_x = torch.sign(x)\n    sign_y = torch.sign(y)\n    min_x, min_y = torch.min(torch.abs(x), torch.abs(y))\n    signed_min = torch.where(min_x < min_y, sign_x, sign_y)\n    return signed_min\n", "metadata": {"problem_id": 992, "library_problem_id": 60, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Surface", "perturbation_origin_id": 58}}
{"id": 993, "code": "def predict_allCharacters(input):\n    output = MyNet(input)\n    conf, classes = torch.max(output.reshape(1, 3), 1)\n    class_names = '012'\n    confidence_score = 1 - output[0][classes.item()]\n    return confidence_score\n", "metadata": {"problem_id": 993, "library_problem_id": 61, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 61}}
{"id": 994, "code": "\n# Calculate the average of the two tensors\naverage = (a[-1, :] + b[0, :]) / 2\n\n# Create a tensor with the average\nresult = torch.cat((a[:, :-1], average, a[:, -1]), 1)\n\n# If you want to convert it back to numpy, you can use .numpy()\nresult = result.numpy()\n", "metadata": {"problem_id": 994, "library_problem_id": 62, "library": "Pytorch", "test_case_cnt": 3, "perturbation_type": "Origin", "perturbation_origin_id": 62}}
{"id": 995, "code": " ###\n    overlap = min(a.shape[1], b.shape[1])\n    result = torch.zeros(a.shape[0], overlap)\n    for i in range(overlap):\n        result[:, i] = (a[:, i] + b[:, i]) / 2\n    return result\n    ### END SOLUTION ###\n\n\nA: You can use torch.cat to concatenate the tensors along the second dimension. Here is how you can do it:\n\n```python\nimport torch\n\na = torch.Tensor([[1, 2, 3], [1, 2, 3]])\nb = torch.Tensor([[5, 6, 7], [5, 6, 7]])\n\n# Concatenate the tensors along the second dimension\nresult = torch.cat([a, b], dim=1)\n\nprint(result)\n```\n\nThis will give you the output:\n\n```\ntensor([[1., 2., 4., 6., 7.],\n        [1., 2., 4., 6., 7.]])\n```\n\nIn this code, torch.cat is used to concatenate the tensors along the second dimension. The result tensor will have the first two columns of 'a' and the last two columns of 'b' concatenated together. The middle column is the average of 'a's last column and 'b's first column.\n", "metadata": {"problem_id": 995, "library_problem_id": 63, "library": "Pytorch", "test_case_cnt": 3, "perturbation_type": "Surface", "perturbation_origin_id": 62}}
{"id": 996, "code": "\n# Reshape the tensor to have 2 dimensions\nt = t.view(-1, 2)\n\n# Create a new tensor with zeros\nnew = torch.zeros(t.shape[0], 4)\n\n# Stack the tensors\nresult = torch.stack([t, new])\n\nprint(result)\n", "metadata": {"problem_id": 996, "library_problem_id": 64, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Origin", "perturbation_origin_id": 64}}
{"id": 997, "code": "\n# Reshape the tensor to the desired shape\nt = t.reshape(1, 2, 2)\n\n# Create a tensor with zeros\nnew = torch.zeros(1, 2, 2)\n\n# Stack the tensors\nresult = torch.stack([t, new])\n\nprint(result)\n", "metadata": {"problem_id": 997, "library_problem_id": 65, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Surface", "perturbation_origin_id": 64}}
{"id": 998, "code": "\n# reshape the tensor to (1,4,2)\nt = t.reshape(1,4,2)\n\n# create a tensor with -1's\nnew = torch.full((1,4,2), -1)\n\n# stack the tensors\nresult = torch.stack([t, new])\n\nprint(result)\n", "metadata": {"problem_id": 998, "library_problem_id": 66, "library": "Pytorch", "test_case_cnt": 2, "perturbation_type": "Semantic", "perturbation_origin_id": 64}}
{"id": 999, "code": "result = torch.bmm(data.perm(0, 1).contiguous(), W)\nresult = result.view(10, 2, 3)\n", "metadata": {"problem_id": 999, "library_problem_id": 67, "library": "Pytorch", "test_case_cnt": 1, "perturbation_type": "Origin", "perturbation_origin_id": 67}}
