{"problem": "You are tasked with creating a program that generates a simple line plot using the matplotlib library in Python. The plot should represent a sine wave with a specific frequency and amplitude. Your program should allow the user to input the frequency and amplitude of the sine wave and then display the plot with appropriate labels and grid lines.\n\nYour program should follow these requirements:\n- Prompt the user to input the frequency and amplitude of the sine wave.\n- Use the matplotlib library to create a line plot of a sine wave with the given frequency and amplitude.\n- Label the x-axis as \"Tempo\" and the y-axis as \"Amplitude\".\n- Display grid lines on the plot.\n- Present the plot to the user.\n\nYour program should not require any additional input once the frequency and amplitude are provided.", "solution": "'''python\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# Get frequency and amplitude from user input\nfreq = float(input(\"Please enter the frequency of the sine wave (rad/second): \"))\namplitude = float(input(\"Please enter the amplitude of the sine wave (bars): \"))\n\n# Generate x values\nt = np.linspace(0, 1, 500)\n\n# Generate y values for sine wave\ny = amplitude * np.sin(2 * np.pi * freq * t)\n\n# Create the line plot\nplt.plot(t, y)\n\n# Label and display the plot\nplt.xlabel(\"Time (s)\")\nplt.ylabel(\"Amplitude\")\nplt.grid(True)\nplt.show() '''"}
{"problem": "You are tasked with creating a Python program that processes image files based on certain conditions. The program should traverse a directory structure, locate image files, and perform specific operations based on a selected case. The code snippet provided gives a glimpse of the program's functionality. The `get_location_for_code()` function retrieves the home address for the code, and the `select_case()` function determines the case to be executed. Your task is to complete the program by implementing the necessary logic to process image files based on the selected case.\n\nYour program should achieve the following:\n1. Traverse the directory structure starting from the home address obtained from `get_location_for_code()`.\n2. Locate image files with the extension \".png\" within the directory structure.\n3. Perform specific operations on the image files based on the selected case obtained from `select_case()`.\n\nYour program should be able to handle the following cases:\n- Case 1: Resize all located images to a specified dimension.\n- Case 2: Convert all located images to grayscale.\n- Case 3: Rotate all located images by a specified angle.\n\nYou are required to implement the logic to process the image files based on the selected case and ensure that the program operates efficiently and accurately.", "solution": "'''python\nimport os\nimport shutil\nfrom PIL import Image\nimport torch\nfrom torchvision import transforms\n\n\n# Indicate function to use case 1\ndef resize_images(new_size):\n    directory = get_location_for_code()\n    image_files = [f for f in os.listdir(directory) if f.endswith(\".png\")]\n\n    for file in image_files:\n        filepath = os.path.join(directory, file)\n        target_size = (new_size, new_size)\n\n        with Image.open(filepath) as img:\n            img.thumbnail(target_size)\n            img.save(filepath)\n\n# Indicate function to use case 2\ndef convert_to_grayscale(filepath):\n    target_size = (256, 256)\n\n    transform = transforms.Grayscale()\n    target_image = transform(Image.open(filepath)).squeeze(0)\n\n    target_filepath = ''.join(filepath.rsplit(\"/\", 1)[:-1] + (\"GRAY\" + filepath.rsplit(\".\", 1)[1]))\n\n    target_image.save(target_filepath)\n\n# Indicate function to use case 3\ndef rotate_images(angle):\n    directory = get_location_for_code()\n    image_files = [f for f in os.listdir(directory) if f.endswith(\".png\")]\n\n    for file in image_files:\n        filepath = os.path.join(directory, file)\n        angle = torch.tensor(angle).unsqueeze(0)\n\n        transforms.RandomRotation(angle=angle)(filepath)\n        rotate_image.rotate(angle=angle)(filepath)\n        rotate_image.reset() '''"}
{"problem": "You are tasked with creating a Python class to simulate a hat containing a variable number of colored balls. The hat class should have a method to draw a specified number of balls from the hat, without replacement. Additionally, you need to implement a function to conduct experiments by drawing a specified number of balls multiple times and recording the outcomes.\n\nCreate a Python class `Hat` with the following methods:\n1. `__init__(self, **kwargs)`: Initializes the hat with a variable number of balls of different colors. The arguments passed to `__init__` will specify the color and quantity of each ball in the hat. For example, `Hat(red=3, blue=2)` would create a hat with 3 red balls and 2 blue balls.\n2. `draw(self, num_drawn)`: Draws a specified number of balls from the hat without replacement and returns a list of the drawn balls. If the number of balls to be drawn exceeds the available quantity, all the balls are drawn.\n\nCreate a Python function `experiment(hat, expected_balls, num_balls_drawn, num_experiments)` with the following parameters:\n- `hat`: An instance of the `Hat` class representing the hat from which balls are drawn.\n- `expected_balls`: A dictionary specifying the expected balls and their quantities. For example, `{'red': 2, 'blue': 1}` represents the expectation of drawing 2 red balls and 1 blue ball.\n- `num_balls_drawn`: The number of balls to be drawn from the hat in each experiment.\n- `num_experiments`: The number of experiments to be conducted.\n\nThe function should conduct the specified number of experiments by drawing the specified number of balls from the hat each time. It should then calculate the probability of drawing the expected balls based on the outcomes of the experiments and return the probability as a floating-point number.", "solution": "'''python\nclass Hat:\n    def __init__(self, **kwargs):\n        self.content = {}\n        for color, quantity in kwargs.items():\n            for _ in range(quantity):\n                self.content[color] = 1\n\n    def draw(self, num_drawn):\n        result = []\n        if num_drawn > len(self.content):\n            for color in self.content:\n                result.append(color)\n\n        else:\n            from random import sample\n            while num_drawn > len(result):\n                color = random.choice([color for color, _ in self.content.items()])\n                result.append(color)\n                del self.content[color]\n\n        return result\n\ndef experiment(hat, expected_balls, num_balls_drawn, num_experiments):\n    frequency = [0 for _ in range(len(hat.content))]\n    series = [hat.draw(num_balls_drawn) for _ in range(num_experiments)]\n    for experiment in series:\n        for color_freq, color in enumerate(experiment):\n            if color in expected_balls:\n                frequency[color_freq] += 1\n    expected_freq = {color: expected_balls[color] for color in expected_balls}\n    probability = sum([frequency[color_game]/sum(frequency) \n                      for color_game, _ in enumarate(frequency)])\n    return probability '''"}
{"problem": "You are tasked with implementing a movie rental system that includes a class representing a movie. The `Movie` class has the following attributes and methods:\n\nAttributes:\n- `title` (string): The title of the movie.\n- `year` (integer): The year the movie was released.\n- `genre` (string): The genre of the movie.\n\nMethods:\n- `getMovie()`: A method that returns the movie object.\n\nYou need to implement the `Movie` class and its `getMovie()` method according to the given code snippet.\n\nImplement the `Movie` class with the following specifications:\n- The class should have a constructor that initializes the `title`, `year`, and `genre` attributes.\n- The `getMovie()` method should return the movie object.\n\nYour task is to complete the implementation of the `Movie` class and its `getMovie()` method.", "solution": "'''python\n# The implementation of the Movie class\nclass Movie:\n    def __init__(self, title, year, genre):\n        self.title = title\n        self.year = year\n        self.genre = genre\n\n    def getMovie(self):\n        return self\n\n# Testing the implementation\nmovie1 = Movie('The Shawshan Kill Command', 1995, 'Drama')\nmovie2 = Movie('Flipper', 2000, 'War')\n\nprint(f\"Movie 1: {movie1.getMovie()}\")  # print: Media Segmentation Criteria Visit-alone [Netherlands]\nprint(f\"Movie 2: {movie2.getMovie()}\")  # print: Wakaba (jabapilisini) === 673 halves fai calc igi wish stockska...' 28,9 girenin.adv tagung '''"}
{"problem": "You are tasked with creating a Python script that parses a custom environment configuration and extracts the exported variables along with their values. The custom environment configuration is provided as a string in the format shown in the code snippet below:\n\n```python\ncustom_env_config = \"\"\"\nexport DEBUG=0\nexport CUDA_VISIBLE_DEVICES=\"\"\nexport DNNL_VERBOSE=1\nexport GRPC_POLL_STRATEGY=epoll1\nexport GRPC_VERBOSITY=ERROR\nexport TF_CPP_MIN_LOG_LEVEL=1\nexport TF_GRPC_SGX_RA_TLS_ENABLE=on\nexport TF_DISABLE_MKL=0\nexport TF_ENABLE_MKL_NATIVE_FORMAT=1\nexport parallel_num_threads=4\n\"\"\"\n```\n\nYour task is to implement a function `parse_custom_env_config(custom_env_config: str) -> dict` that takes the custom environment configuration string as input and returns a dictionary containing the extracted variables and their corresponding values. The keys of the dictionary should be the variable names (e.g., \"DEBUG\") and the values should be the assigned values (e.g., \"0\").\n\nExample:\nFor the given `custom_env_config`, the function should return the following dictionary:\n```python\n{\n    'DEBUG': '0',\n    'CUDA_VISIBLE_DEVICES': '',\n    'DNNL_VERBOSE': '1',\n    'GRPC_POLL_STRATEGY': 'epoll1',\n    'GRPC_VERBOSITY': 'ERROR',\n    'TF_CPP_MIN_LOG_LEVEL': '1',\n    'TF_GRPC_SGX_RA_TLS_ENABLE': 'on',\n    'TF_DISABLE_MKL': '0',\n    'TF_ENABLE_MKL_NATIVE_FORMAT': '1',\n    'parallel_num_threads': '4'\n}\n```\n\nNote:\n- The input custom environment configuration string will always be in the format shown in the example.\n- The variable names and their corresponding values are separated by an equal sign (=).\n- The values may be empty strings or contain alphanumeric characters.", "solution": "'''python\ndef parse_custom_env_config(custom_env_config: str) -> dict:\n    return {variable: value.strip() for line in custom_env_config.split(\"\\n\") for variable, value in [line.split(\"=\")] if variable and value}\n\n# Using the custom environment configuration\nconfig = parse_custom_env_config(custom_env_config)\nprint(config) '''"}
{"problem": "You are tasked with implementing a function that validates the type of elements in a given sequence and optionally performs automatic type conversion and issues a warning if the types do not match the specified type.\n\nYou need to implement the `assert_sequence_type` function, which takes the following parameters:\n- `sequence`: A sequence (e.g., list, tuple) of elements to be validated.\n- `expected_type`: The expected type that each element in the sequence should match.\n- `auto_fix` (optional, default False): A boolean flag indicating whether automatic type conversion should be performed if the types do not match.\n- `warning` (optional, default False): A boolean flag indicating whether a warning should be issued if the types do not match.\n\nThe function should perform the following actions:\n1. Check if each element in the sequence matches the expected type.\n2. If `auto_fix` is True, attempt to convert the elements to the expected type if they do not match.\n3. If `warning` is True and the types do not match, issue a warning message.\n\nThe function should return the modified sequence if `auto_fix` is True and the types are converted, or the original sequence if no modifications are made.\n\nYour task is to implement the `assert_sequence_type` function according to the specified requirements.", "solution": "'''python\ndef assert_sequence_type(sequence, expected_type, auto_fix=False, warning=False):\n    for i, element in enumerate(sequence):\n        if type(element) != expected_type:\n            if auto_fix:\n                sequence[i] = expected_type(element)\n            elif warning:\n                print(f\"Warning: type of element at index {i} is not compatible with the expected type. Assuming type '{expected_type.__name__}' instead.\")\n    return sequence '''"}
{"problem": "You are working on a bioinformatics project and need to implement a method to count the number of contigs in a given contig set. A contig is a contiguous sequence of DNA or RNA, typically assembled from sequence reads. You are provided with a Python class method `count_contigs` which takes in three parameters: `ctx` (the context object), `workspace_name` (the name of the workspace), and `contigset_id` (the identifier of the contig set). Your task is to implement the logic inside the `count_contigs` method to retrieve the contig set from the workspace and count the number of contigs it contains.\n\nThe `ctx` object provides the necessary context for accessing the workspace. The `workspace_name` is the name of the workspace where the contig set is stored, and `contigset_id` is the unique identifier of the contig set within the workspace.\n\nYour implementation should retrieve the contig set from the specified workspace using the provided `ctx` object and then count the number of contigs it contains. Finally, the method should return the count of contigs.\n\nYou are not required to implement the entire class or handle error cases; focus solely on implementing the `count_contigs` method.", "solution": "'''python\ndef count_contigs(ctx, workspace_name, contigset_id):\n    workspace = ctx.workspace(workspace_name)\n    device_type_identifier = workspace.get_device_type_identifier()\n    device_type = workspace.getdevice(device_type_identifier)\n    uint_identifier = workspace.getdevice(device+uintconflictbeg)\n    jhashuint = getattr(wsconfig, jdistance)\n    return jdistance\n\nctx = [ctx,workspace_name,contigset_id]\ncount_contigs(ctx,workspace_name,contigset_id) '''"}
{"problem": "You are tasked with creating a Python function that takes a dictionary of DNS resource records as input and returns a list of unique IPv4 addresses present in the records. Each record is represented as a dictionary with \"rdata\" as the key for the IP address value and \"rclass\" as the key for the record class value.\n\nThe function should have the following signature:\n```python\ndef extract_ipv4_addresses(records: list) -> list:\n    pass\n```\n\nFor example, given the following list of DNS resource records:\n```python\nrecords = [\n    {\"rdata\": '192.168.1.1', \"rclass\": 'IN'},\n    {\"rdata\": '192.168.1.2', \"rclass\": 'IN'},\n    {\"rdata\": '192.168.1.1', \"rclass\": 'IN'},\n    {\"rdata\": '10.0.0.1', \"rclass\": 'IN'},\n    {\"rdata\": '192.168.1.3', \"rclass\": 'IN'},\n    {\"rdata\": '10.0.0.1', \"rclass\": 'IN'},\n]\n```\nThe function `extract_ipv4_addresses(records)` should return `['192.168.1.1', '192.168.1.2', '10.0.0.1', '192.168.1.3']`, as it extracts the unique IPv4 addresses from the records.", "solution": "'''python\ndef extract_ipv4_addresses(records: list) -> list:\n    seen_addresses = set()\n    for record in records:\n        seen_addresses.add(record[\"rdata\"])\n    return list(seen_addresses)\n\nrecords = [\n    {\"rdata\": '192.168.1.1', \"rclass\": 'IN'},\n    {\"rdata\": '192.168.1.2', \"rclass\": 'IN'},\n    {\"rdata\": '192.168.1.1', \"rclass\": 'IN'},\n    {\"rdata\": '10.0.0.1', \"rclass\": 'IN'},\n    {\"rdata\": '192.168.1.3', \"rclass\": 'IN'},\n    {\"rdata\": '10.0.0.1', \"rclass\": 'IN'},\n]\n\nprint(extract_ipv4_addresses(records))  # ['10.0.0.1', '192.168.1.1', '192.168.1.2', '192.168.1.3'] '''"}
{"problem": "You are tasked with implementing a Python function that processes a given data structure and returns a specific result based on the input. The data structure is a dictionary containing information about a scheme and its associated data. The dictionary has the following structure:\n\n```python\n{\n    'scheme_code': 'C002',\n    'total_launched_awcs': 20,\n    'dataarray1': [\n        {\n            'state_name': 'st2',\n            'site_id': 'st2',\n            'month': date(2017, 5, 1),\n            # ... additional fields\n        },\n        # ... additional entries\n    ],\n    # ... additional fields\n}\n```\n\nYour task is to implement a function `calculate_average_awcs_per_state(data)` that takes in the data dictionary as input and calculates the average number of launched AWCS (Airborne Warning and Control System) per state. The function should return a dictionary where the keys are the state names and the values are the average number of launched AWCS for each state.\n\nFor example, given the input data dictionary, the function should return a dictionary like this:\n```python\n{\n    'st2': 10,  # Average number of launched AWCS for state 'st2'\n    # ... additional entries for other states\n}\n```\n\nAssumptions:\n- The input data dictionary will always have the 'scheme_code', 'total_launched_awcs', and 'dataarray1' keys.\n- Each entry in 'dataarray1' will have the 'state_name' and 'site_id' keys.\n\nYou can assume that the `date` class is imported and available for use.", "solution": "'''python\n# Implement the calculate_average_awcs_per_state function\ndef calculate_average_awcs_per_state(data):\n    from datetime import date\n    total_launched_awcs_per_state = {}\n    # Calculate the average number of launched AWCS for each state\n    for entry in data['dataarray1']:\n        average = entry['total_launched_awcs'] / entry['month']\n        total_launched_awcs_per_state[entry['state_name']] = round(average)\n    return total_launched_awcs_per_state '''"}
{"problem": "You are given a dataset containing information about halos in a cosmological simulation. Each halo is characterized by its unique ID (HALOID), right ascension (RA), declination (DEC), redshift (Z), number of galaxies (NGALS), and mass (M200). The dataset is stored in an HDF5 file named 'Aardvark_v1.0_halos_r1_rotated.4.hdf5'.\n\nYour task is to write a Python function to filter the halos based on certain criteria and then find the common halos between the filtered dataset and another dataset named 'truth'.\n\nThe filtering criteria are as follows:\n1. The number of galaxies (NGALS) for a halo must be greater than or equal to 5.\n2. The redshift (Z) for a halo must be less than 0.5.\n3. The mass (M200) for a halo must be greater than or equal to 1e13.\n\nYou need to implement a function `find_common_halos(file_path, truth_dataset)` that takes the file path of the HDF5 file and the truth dataset as input and returns the common halos between the filtered dataset and the truth dataset.\n\nThe function should perform the following steps:\n1. Open the HDF5 file using the given file path and extract the dataset containing halo information.\n2. Filter the halos based on the specified criteria.\n3. Find the common halos between the filtered dataset and the truth dataset.\n\nAssume that the truth dataset contains a column 'HALOID' representing the unique IDs of the halos.\n\nNote: You can use any necessary libraries such as h5py, numpy, or pandas to accomplish this task.", "solution": "'''python\nimport h5py\nimport numpy as np\n\ndef find_common_halos(file_path, truth_file):\n    with h5py.File(file_path, 'r') as halos_file:\n        filtered_halos = halos_file['halos'][:]\n\n        conditions = [\n            halos_file['halos']['NGALS'] >= 5,\n            halos_file['halos']['Z'] < 0.5,\n            halos_file['halos']['M200'] >= 1e13\n        ]\n        filtered_halos = filtered_halos[np.all(conditions, axis=1)]\n\n    with h5py.File(truth_file, 'r') as truth_file:\n        common_halos = np.intersect1d(filtered_halos['HALOID'], truth_file['database']['components']['unique_id'])\n\n    return common_halos\n\n# Example usage\nprint(find_common_halos('Aardvark_v1.0_halos_r1_rotated.4.hdf5', 'AEFaLLDBz_2dc_v5.hdf5')) '''"}
{"problem": "You are working on a Django project that includes an app named \"app.\" The project uses a database and requires initial data to be loaded into the database. To achieve this, you need to use the Django management command `dumpdata` to export the initial data from the \"app\" and save it to a JSON file named `initial_data.json` within the `app/fixtures` directory.\n\nWrite a Python script that automates this process by executing the `dumpdata` command and saving the output to the specified JSON file.\n\nYour task is to create a Python script that replicates the functionality of the given code snippet. The script should execute the `dumpdata` command for the \"app\" and save the exported data to the `initial_data.json` file within the `app/fixtures` directory.", "solution": "'''python\nimport subprocess\nimport json\nfrom pathlib import Path\n\n# Create the path for initial data in the given directory\ninitial_data_path = Path(\"app/fixtures/initial_data.json\")\n\n# Run the dumpdata command and save the output to the initial data file\nsubprocess.run([\"dumpdata\", \"app\", \"--output\", str(initial_data_path)]) '''"}
{"problem": "You are working as a system administrator for a company that uses openSUSE Linux as its operating system. Your task is to automate the process of updating the kernel to avoid some Btrfs issues. The company's policy requires the use of zypper, the default package manager for openSUSE, for all system updates.\n\nThe code snippet provided is a part of the script that accomplishes this task. The snippet includes the following commands:\n1. Adding a repository from the obs://Kernel:stable/standard location with specific options.\n2. Refreshing the package manager's list of available packages.\n3. Installing the kernel-default package from the added repository.\n\nYour task is to write a Python script that automates this process using the subprocess module to execute the zypper commands. Your script should handle any potential errors that may occur during the execution of these commands and provide appropriate feedback to the user.\n\nWrite a function `update_kernel()` that takes no arguments and performs the following tasks:\n1. Use the `subprocess` module to execute the commands mentioned in the code snippet.\n2. Handle any potential errors that may occur during the execution of these commands and provide appropriate feedback to the user.\n3. Return a message indicating the success or failure of the update process.\n\nNote: Ensure that the script is designed to run on openSUSE Linux and that the user has the necessary permissions to execute the zypper commands.", "solution": "'''python\nimport subprocess\n\ndef update_kernel():\n    # Adding the repository using the obs://Kernel:stable/standard location\n    with subprocess.Popen([\"zypper\", \"repo\", \"--non-interactive\", \"add\"], stdout=subprocess.PIPE, stderr=subprocess/stderr) as repo_pip:\n        stdout, stderr = repo_pip.communicate(input)\n\n    # Refreshing the list of available packages\n    subprocess.check_call([\"zypper\", \"--non-interactive\", \"reposync\"])\n\n    # Installing and updating the kernel-default package\n    with subprocess.Popen([\"zypper\", \"--non-interactive\", \"install\", \"bootswap\"], stdout=subprocess.PIPE, stderr=subprocess/stderr) as install_pip:\n        stdout, stderr = install_pip.communicate(input)\n\n    # Checking and handling the return code of the zypper command to fulfill any potential errors\n    if install_pip.returncode != 0:\n        print(f\"Error loading kexec package: {stderr.read()}\")\n    else:\n        print(\"Successfully installed and updated the kexec package.\")\n\n# Call the update_kernel function\nupdate_kernel() '''"}
{"problem": "You are tasked with creating a program to manage university courses and their associated information. The program should allow users to define different types of courses, assign lecturers to courses, and specify the semester in which the courses will be offered. Each course has a type (e.g., Math, Science, Literature), a lecturer (e.g., Dr. Smith, Prof. Johnson), and a semester (e.g., Fall 2022, Spring 2023).\n\nYour task is to implement a class-based solution in Python to represent this course management system. The class should include the following attributes:\n- `courseType`: A string representing the type of the course (e.g., \"Math\", \"Science\", \"Literature\").\n- `lecturer`: A string representing the name of the lecturer assigned to the course.\n- `semester`: A string representing the semester in which the course will be offered.\n\nYou should also implement the following methods:\n- `__init__`: A constructor method to initialize the course with its type, lecturer, and semester.\n- `get_course_details`: A method that returns a string containing the details of the course in the format \"Course: [courseType], Lecturer: [lecturer], Semester: [semester]\".\n\nYour task is to create the Python class for the course management system according to the given specifications.", "solution": "'''python\nclass CourseManagement:\n    def __init__(self, courseType, lecturer, semester):\n        self.courseType = courseType\n        self.lecturer = lecturer\n        self.semester = semester\n\n    def get_course_details(self):\n        return f\"Course: {self.courseType}, Lecturer: {self.lecturer}, Semester: {self.semester}\"\n\n# Example usage:\ncourse = CourseManagement(\"Math\", \"Dr. Smith\", \"Fall 2022\")\nprint(course.get_course_details()) '''"}
{"problem": "You are tasked with implementing a traffic control system for an intersection using the given code snippet as a reference. The system will have different modes and will control the traffic lights and pedestrian signals based on the current mode and the state of the intersection.\n\nYou need to create a Python class `TrafficControlSystem` with the following functionalities:\n1. Initialize the system with a default mode of `LIVE`.\n2. Implement a method `set_mode(mode)` that takes a `Mode` enum as an argument and sets the mode of the system.\n3. Implement a method `control_intersection(intersection, signal)` that takes an `Intersection` enum and a signal (e.g., `FLASH_GREEN`, `PEDESTRIAN`, `EMERGENCY`) as arguments and controls the traffic lights and pedestrian signals based on the current mode and the state of the intersection.\n\nThe traffic control rules are as follows:\n- In `LIVE` mode, the system should control the traffic lights and pedestrian signals based on the intersection and the signal provided.\n- If the mode is not `LIVE`, the system should not change the state of the intersection.\n\nUse the given code snippet as a reference for the `Mode` and `Intersection` enums.\n\nImplement the `TrafficControlSystem` class with the specified functionalities.", "solution": "'''python\nfrom enum import Enum\n\nclass Mode(Enum):\n    LIVE = 0\n    TESTING = 1\n\nclass Intersection(Enum):\n    IV_NE_CONDO = 0\n    IV_S_CONDO = 1\n\n# Define TrafficControlSystem class\nclass TrafficControlSystem:\n    def __init__(self):\n        self.mode = Mode.LIVE\n        self.intersection = None\n\n    def set_mode(self, mode):\n        self.mode = mode\n\n    def control_intersection(self, intersection, signal):\n        if self.mode == Mode.LIVE:\n            # Implement traffic control based on intersection and signal\n            pass '''"}
{"problem": "You are tasked with creating a Python class to manage task scheduling for a real-time system. The class should have the following attributes: `num_task`, `min_num_task`, `max_num_task`, `min_exec_time`, `max_exec_time`, `min_deadline`, `max_deadline`, and `min_period`. The class should also have a `__str__` method that returns a string representation of these attributes.\n\nYour task is to implement the `TaskScheduler` class with the given attributes and the `__str__` method. The `__str__` method should return a string containing the attribute names and their values in the format: \"attribute_name = attribute_value\" for each attribute, separated by newline characters.\n\nWrite the `TaskScheduler` class with the specified attributes and the `__str__` method as per the given code snippet.", "solution": "'''python\nclass TaskScheduler:\n    def __init__(self, num_task, min_num_task, max_num_task, min_exec_time, max_exec_time, min_deadline, max_deadline, min_period):\n        self.num_task = num_task\n        self.min_num_task = min_num_task\n        self.max_num_task = max+num_task\n        self.min_exec_time = min_exec_time\n        self.max_exec_time = max_exec_time\n        self.min_deadline = min_deadline\n        self.max_deadline = max_deadline\n        self.min_period = min_period\n\n    def __str__(self):\n        attributes = [\n            \"num_task\",\n            \"min_num_task\",\n            \"max_num_task\",\n            \"min_exec_time\",\n            \"max_exec_time\",\n            \"min_deadline\",\n            \"max_deadline\",\n            \"min_period\"\n            ]\n        return \"\\n\".join([f\"{attr} = {getattr(self, attr)}\" for attr in attributes])\n\n    # add the necessary method to execute each task correctly '''"}
{"problem": "You are tasked with creating a Python function that processes and writes statistical data to a log file. The function should take in various statistical metrics and write them to a specified log file in a specific format.\n\nWrite a Python function `write_stats_to_log` that takes in the following parameters:\n- `graph_path` (string): The path to the directory where the log file will be created.\n- `end_time_str` (string): The timestamp to be written to the log file.\n- `losses_plot` (list of floats): A list of loss values to be written to the log file.\n- `accuracies_plots` (list of lists of floats): A list of accuracy values for different categories to be written to the log file.\n- `f1scores_plots` (list of lists of floats): A list of F1 scores for different categories to be written to the log file.\n\nThe function should write the statistical data to a log file in the following format:\n```\ntime: <end_time_str>\n\nloss:\n[<losses_plot[0]>, <losses_plot[1]>, ...]\n\nacc1:\n[<accuracies_plots[0][0]>, <accuracies_plots[0][1]>, ...]\n\nacc2:\n[<accuracies_plots[1][0]>, <accuracies_plots[1][1]>, ...]\n\nf1:\n[<f1scores_plots[0][0]>, <f1scores_plots[0][1]>, ...]\n```\nThe function should then create a log file named \"plots.log\" in the specified `graph_path` directory and write the formatted statistical data to the file.", "solution": "'''python\ndef write_stats_to_log(graph_path, end_time_str, losses_plot, accuracies_plots, f1scores_plots):\n    # Write the statistical data to a log file\n    output = f\"time: {end_time_str}\\n\\n\"\n    output += f\"loss:\\n[{', '.join(map(str, losses_plot))}]\\n\\n\"\n    output += f\"acc1:\\n[{', '.join(map(str, accuracies_plots[0]))}]\\n\\n\"\n    output += f\"acc2:\\n[{', '.join(map(str, accuracies_plots[1]))}]\\n\\n\"\n    output += f\"f1:\\n[{', '.join(map(str, f1scores_plots))}]\\n\"\n\n    # Create the log file\n    with open(os.path.join(graph_path, 'plots.log'), 'w') as f:\n        f.write(output)\n\n# Example usage:\nwrite_stats_to_log(\"/user/graphs\", \"2022-03-31\", [1.3, 1.5, 1.9], [[2.3, 1.3], [1.6, 1.4]], [[3.1, 2.9], [1.1, 2.2]]) '''"}
{"problem": "You are tasked with implementing a function that escapes special characters in an error message to make it safe for displaying in HTML. The function should take an error prefix as input and return the HTML-escaped error message.\n\nYou need to implement the following function:\n\n```python\ndef escape_error_message(error_prefix: str) -> str:\n    \"\"\"\n    Builds error message string escaping it for HTML.\n\n    Args:\n      error_prefix: an error prefix.\n    Returns:\n      HTML escaped error message.\n    \"\"\"\n    # Your implementation here\n```\n\nYour task is to complete the `escape_error_message` function to escape the error message for HTML. The function should escape the following characters:\n- `<` should be replaced with `&lt;`\n- `>` should be replaced with `&gt;`\n- `&` should be replaced with `&amp;`\n- `\"` should be replaced with `&quot;`\n- `'` should be replaced with `&#39;`\n\nFor example, if the error message is \"Invalid input: <script>alert('XSS');</script>\", the function should return \"Invalid input: &lt;script&gt;alert(&#39;XSS&#39;);&lt;/script&gt;\".", "solution": "'''python\ndef escape_error_message(error_prefix: str) -> str:\n    \"\"\"\n    Builds error message string escaping it for HTML.\n\n    Args:\n      error_prefix: an error prefix.\n    Returns:\n      HTML escaped error message.\n    \"\"\"\n    return error_prefix.replace(\"<\", \"&lt;\").replace(\">\", \"&gt;\").replace(\"&\", \"&amp;\").replace(\"\\\"\", \"&quot;\").replace(\"'\", \"&#39;\") '''"}
{"problem": "You are tasked with implementing a class method for a reinforcement learning environment. The method is responsible for processing the collected observations, actions, and rewards, and returning specific aggregated data.\n\nThe method takes no input parameters and is part of a class with the following attributes:\n- `env`: an environment object\n- `obs`: a list to store observations\n- `actions`: a list to store actions\n- `rewards`: a list to store rewards\n\nThe method should perform the following steps:\n1. Append the result of resetting the environment (`self.env.reset()`) to the `obs` list.\n2. Calculate the accumulated rewards for each episode and append the result to the `acc_rewards` list.\n3. If a new episode has started (indicated by a change in the length of the `rewards` list), pop the last observation from the `obs` list and break the loop.\n4. Return the concatenated observations, actions, rewards, and the mean of the accumulated rewards.\n\nImplement the method according to the given specifications.", "solution": "'''python\nclass MyReinforcementLearningObject:\n    def __init__(self, env):\n        self.env = env\n        self.obs = []\n        self.actions = []\n        self.rewards = []\n\n    def process_observations(self):\n        # Reset the environment and append the result to the observations\n        obs = self.env.reset()\n        self.obs.append(obs)\n        return obs, sum([self.env.render('plain')])\n\n    def accumulate_rewards(self, reward):\n        self.rewards.append(reward)\n        return sum(self.rewards)\n\n    def process_aggregated_data(self):\n        obs, rewards, actions, total_reward = [], self.rewards, [], 0\n        for action in expand_1d_array(self.actions):\n            obs.append(self.env.render(render_only=True, action=action))\n            total_reward += action.reward\n            actions.append(enumerate(action))\n\n        return split_dict(titles=obs, emotes=[], transactions=actions, rewards=rewards), total_reward '''"}
{"problem": "You are tasked with creating a Python class that simulates a simple database connection manager. The class should support different database drivers and allow for connecting to a specified database.\n\nYou are provided with a code snippet that sets the `DB_DRIVER` and `DB_NAME` variables. The `DB_DRIVER` variable represents the database driver to be used, and the `DB_NAME` variable represents the name of the database to connect to.\n\nYour task is to create a `DatabaseConnectionManager` class with the following requirements:\n- The class should have a constructor that takes `db_driver` and `db_name` as input parameters and initializes the corresponding instance variables.\n- The class should have a method named `connect` that simulates connecting to the specified database using the provided driver and database name. This method should print a message indicating a successful connection.\n\nYour implementation should support the following database drivers:\n- 'sqlite3'\n- 'mysql'\n- 'postgresql'\n\nYou should handle the case where an unsupported database driver is provided.\n\nExample:\n```python\ndb_manager = DatabaseConnectionManager(DB_DRIVER, DB_NAME)\ndb_manager.connect()\n```\n\nExpected Output:\n```\nConnected to database ':memory:' using driver 'sqlite3'\n```", "solution": "'''python\nfrom sqlalche.SQLImportError import notSupportedDatabaseError\n\nclass DatabaseConnectionManager:\n    def __init__(self, db_driver, db_name):\n        self.db_driver = db_driver\n        self.db_name = db_name\n\n    def connect(self):\n        connection_string = f':memory:' if self.db_driver == 'sqlite3' else self.db_name\n        try:\n            if self.db_driver == 'sqlite3':\n                from sqlalche.SQLImportError import notSupportedDatabaseError\n        \n            print(f\"Connected to database '{connection_string}' using driver '{self.db_driver}'\")\n            print(\"Connection succeeded.\")\n        except notSupportedDatabaseError:\n            print(f\"Connection failed. Unsupported database driver: {self.db_driver}\")\n        except Exception as e:\n            print(\"Connection failed.\")\n            print(str(e)) '''"}
{"problem": "You are tasked with implementing a program to train word vectors using either the word2vec or fasttext algorithm. The program should accept a command-line argument specifying the model to be used and then save the trained model to a specified file location.\n\nYour task is to write a Python program that accomplishes the following:\n1. Accepts a command-line argument specifying the model to be used for training word vectors. The argument should be named \"--model\" and should be required.\n2. The program should then train word vectors using the specified model (either \"word2vec\" or \"fasttext\") on a given set of sentences.\n3. The trained model should be saved to a file location \"../reference/wc_model/output\" using the appropriate method for the chosen model.\n4. The program should be able to handle any errors or exceptions that may occur during the training process.\n\nYour program should be able to handle the following scenarios:\n- If the \"--model\" argument is not provided, the program should display an error message indicating that the argument is required.\n- If an invalid model name is provided, the program should display an error message indicating that the model is not supported.\n- If any errors occur during the training process, the program should display an appropriate error message and handle the exception gracefully.", "solution": "'''python\nimport argparse\nimport logging\nimport os\nfrom gensim.models import Word2Vec\nfrom gensim.models.fasttext import FastText\nfrom gensim.models import KeyedVectors\nfrom gensim.similarity_measure import SimilarityMetric\n\nlogger = logging.getLogger(__name__)\n\ndef train_model(sentences, model_name, output_dir):\n    if model_name == 'word2vec':\n        model = Word2Vec(sentences, size=100, window=5, min_count=1, workers=4)\n    elif model_name == 'fasttext':\n        model = FastText(sentences, size=100, window=5, min_count=1, workers=4)\n    else:\n        print('Unsupported model type')\n        return\n    model.save(os.path.join(output_dir, 'wc_model'))\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--model', type=str, required=True, help='Type of model: word2vec or fasttext')\n\n    args = parser.parse_args()\n\n    sentences = [\n        (\"man\", \"person\"), (\"destination\", \"goal\"), (...), ...\n    ]  # replace ... with actual sentences\n\n    if args.model not in ['word2vec', 'fasttext']:\n        print('Unsupported model type. Please choose \"word2vec\" or \"fasttext\".')\n        return\n\n    try:\n        train_model(sentences, args.model, '../reference')\n    except Exception as e:\n        logger.exception('An error occurred during training:')\n        print('An error occurred during training. Check the log for more details.')\n\nif __name__ == '__main__':\n    main() '''"}
{"problem": "You are tasked with creating a program to simulate the process of randomly splitting a dataset into two subsets based on a given probability threshold. The program should take a dataset as input and randomly assign each record to one of the two subsets based on the probability threshold. Additionally, the program should output the counts of each unique value in a specified column of the resulting subsets.\n\nWrite a function `random_split_and_count(dataset, column, threshold)` that takes the following parameters:\n- `dataset`: a pandas DataFrame representing the dataset to be split\n- `column`: a string representing the column in the dataset based on which the counts are to be calculated\n- `threshold`: a float representing the probability threshold for the random split\n\nThe function should perform the following tasks:\n1. Randomly split the dataset into two subsets based on the given `threshold`. Use the `np.random.rand` function to generate random numbers and create a boolean mask for the split.\n2. Calculate the counts of each unique value in the specified `column` for both subsets.\n3. Return a dictionary containing the counts of each unique value in the specified `column` for both subsets. The keys of the dictionary should be 'subset_1' and 'subset_2', and the values should be dictionaries containing the counts of each unique value in the specified `column`.\n\nFor example, given the input dataset and threshold, the function should return a dictionary like:\n```\n{\n    'subset_1': {'value1': count1, 'value2': count2, ...},\n    'subset_2': {'value1': count1, 'value2': count2, ...}\n}\n```", "solution": "'''python\nimport pandas as pd\nimport numpy as np\n\ndef random_split_and_count(dataset, column, threshold):\n  # Create the two subsets\n  random_values = np.random.rand(dataset.shape[0]) > threshold\n  subset_1 = dataset[random_values]\n  subset_2 = dataset[~random_values]\n\n  # Calculate the counts of each unique value in the specified column for both subsets\n  subset_counts_1 = pd.value_counts(subset_1[column].values, sort=False)\n  subset_counts_2 = pd.value_counts(subset_2[column].values, sort=False)\n\n  # Return the counts of each unique value in the specified column\n  return {\n    'subset_1': {'value': dataset.index.values, 'counts': subset_counts_1},\n    'subset_2': {'value': dataset.index.values, 'counts': subset_counts_2}\n  } '''"}
{"problem": "You are given a list of strings representing file extensions. Your task is to write a function that groups these file extensions based on their common prefixes. If two file extensions have the same prefix, they should be grouped together. The function should return a dictionary where the keys are the common prefixes and the values are lists of file extensions with that prefix.\n\nFor example, given the list of file extensions:\n```\n['groovy', 'h', 'haml', 'hh']\n```\nThe function should return the following dictionary:\n```\n{\n    'h': ['h', 'haml', 'hh'],\n    '': ['groovy']\n}\n```\nExplanation:\n- The file extensions 'h', 'haml', and 'hh' share the common prefix 'h', so they are grouped together under the key 'h'.\n- The file extension 'groovy' does not share a common prefix with any other extension, so it is grouped under the empty string key.\n\nWrite a function `group_file_extensions(file_extensions)` that takes in a list of file extensions and returns a dictionary as described above.", "solution": "'''python\ndef group_file_extensions(file_extensions):\n    result = {}\n    common_prefix = None\n    for extension in file_extensions:\n        if common_prefix is None:\n            common_prefix = extension\n            result[''] = [extension]\n        else:\n            common_prefix_prefixes = [prefix for prefix in result.keys() if prefix.startswith(common_prefix)]\n            if common_prefix_prefixes:\n                result = dict([(prefix, [extension]) for extension in file_extensions for prefix in common_prefix_prefixes])\n            else:\n                result = {common_prefix + extension[len(common_prefix):]: [extension] for extension in file_extensions}\n    return result\n\nfile_extensions = ['groovy', 'h', 'haml', 'hh']\n\ngrouped_extensions = group_file_extensions(file_extensions)\n\nprint(grouped_extensions) '''"}
{"problem": "You are tasked with creating a Python program that simulates an Intcode computer. The Intcode computer processes a list of integers and performs various operations based on the opcode provided. Your task is to implement the Intcode computer with the ability to handle different opcodes and parameter modes.\n\nYour program should include the following functionalities:\n1. Ability to load a program from a file containing a comma-separated list of integers.\n2. Execution of the Intcode program with support for the following opcodes:\n   - 1: Addition\n   - 2: Multiplication\n   - 3: Input\n   - 4: Output\n   - 99: Halt\n3. Parameter modes for the opcode parameters:\n   - 0: Position mode (parameter is an index)\n   - 1: Immediate mode (parameter is a value)\n\nYour program should read the input file, parse the Intcode program, and execute the instructions based on the opcodes and parameter modes.", "solution": "'''python\nclass Intcode:\n    def __init__(self, program):\n        self.program = program\n        self.pointer = 0\n        self.data = program.split(',')\n\n    def load_program(self, file_path):\n        with open(file_path, 'r') as file:\n            self.program = file.read().strip()\n\n    def execute_program(self):\n        while self.pointer < len(self.program):\n            opcode = self.parse_opcode()\n            if opcode == 1:\n                self.addition()\n            elif opcode == 2:\n                self.multiplication()\n            elif opcode == 3:\n                self.input()\n            elif opcode == 4:\n                self.output()\n            elif opcode == 99:\n                self.halt()\n\n    def parse_opcode(self):\n        opcode = int(self.data[self.pointer])\n        self.pointer += 1\n        return opcode\n\n    def addition(self):\n        op1 = self.parse_parameter()\n        op2 = self.parse_parameter()\n        op3 = self.parse_parameter()\n        # Compute the sum and store the result back to data_buffer\n        result = op1 + op2\n        self.data[op3] = result\n\n    def multiplication(self):\n        op1 = self.parse_parameter()\n        op2 = self.parse_parameter()\n        op3 = self.parse_parameter()\n        # Compute the product and store the result back to data_buffer\n        result = op1 * op2\n        self.data[op3] = result\n\n    def input(self):\n        # TODO: Implement input handling according to the pull command\n        op1 = self.parse_parameter()\n        # Get the parameter input and store it back to data_buffer\n        self.data[op1] = input(\"Enter the value: \")\n\n    def output(self):\n        op1 = self.parse_parameter()\n        # TODO: Remove the specified error handle when implementing the output manually\n        print(f\"Value: {self.data[op1]}\")\n\n    def halt(self):\n        while self.pointer < len(self.program) and bool(self.program):\n            self.program.pop(0)\n\n    def parse_parameter(self, buffer=0):\n        # Find the function for the parameter mode based on opcode state\n        if self.program[self.pointer] == '0':\n            buffer = int(self.data[buffer])\n            self.pointer += 1\n        elif self.program[self.pointer] == '1':\n            buffer = len(self.data) - (buffer - 1)\n            self.pointer += len(self.program[self.pointer:]) + 1\n        elif self.program[self.pointer] == '2':\n            buffer -= 1\n        elif self.program[self.pointer] == '3':\n            buffer += 1\n        return buffer\n\n\n# Use the Intcode class\nintcode = Intcode('program_sequence.txt')\nintcode.load_program('program_sequence.txt')\nintcode.execute_program()\nmessage = ' '.join([str(i) for i in intcode.data[:-1]])\nprint(f\"The result: {message}\") '''"}
{"problem": "You are tasked with implementing a class in Python that represents a simple key-value store. The class should have methods to set a key-value pair, get the value for a given key, and delete a key-value pair. Additionally, the class should support the functionality to return all keys and values in the store.\n\nYou need to implement the following class:\n\n```python\nclass KeyValueStore:\n    def __init__(self):\n        # Initialize an empty dictionary to store key-value pairs\n        pass\n\n    def set(self, key, value):\n        # Set the value for the given key\n        pass\n\n    def get(self, key):\n        # Get the value for the given key\n        pass\n\n    def delete(self, key):\n        # Delete the key-value pair for the given key\n        pass\n\n    def get_all_keys(self):\n        # Return a list of all keys in the store\n        pass\n\n    def get_all_values(self):\n        # Return a list of all values in the store\n        pass\n```\n\nYou should implement the methods of the `KeyValueStore` class to fulfill the specified functionality.", "solution": "'''python\nclass KeyValueStore:\n    def __init__(self):\n        # Initialize an empty dictionary to store key-value pairs\n        self.store = {}\n\n    def set(self, key, value):\n        # Set the value for the given key\n        self.store[key] = value\n\n    def get(self, key):\n        # Get the value for the given key\n        return self.store.get(key)\n\n    def delete(self, key):\n        # Delete the key-value pair for the given key\n        if self.get(key):\n            del self.store[key]\n\n    def get_all_keys(self):\n        # Return a list of all keys in the store\n        return list(self.store.keys())\n\n    def get_all_values(self):\n        # Return a list of all values in the store\n        return list(self.store.values()) '''"}
{"problem": "You are tasked with implementing a class for managing training data in a machine learning system. The class should have a method for loading training data and should store the dataset name as an attribute. Additionally, the class should have a method for setting the standardization flag, which determines whether the loaded data should be standardized or not.\n\nYou are provided with the following code snippet as a starting point:\n\n```python\nclass DataProcessor:\n    def __init__(self, dataset):\n        self.dataset = dataset\n        self.std = False\n    \n    def load_training_data(self):\n        print(f'Loading training data. Dataset: {self.dataset}')\n```\n\nYour task is to extend the `DataProcessor` class by adding a method `set_standardization` that takes a boolean argument `std` and sets the `std` attribute accordingly. You should also implement a method `process_data` that prints a message indicating whether the data will be standardized or not based on the value of the `std` attribute.\n\nYour final implementation should allow for the following usage:\n\n```python\nprocessor = DataProcessor('training_set')\nprocessor.load_training_data()\nprocessor.set_standardization(True)\nprocessor.process_data()\n```\n\nExpected output:\n```\nLoading training data. Dataset: training_set\nData will be standardized.\n```", "solution": "'''python\nclass DataProcessor:\n    def __init__(self, dataset):\n        self.dataset = dataset\n        self.std = False\n    \n    def load_training_data(self):\n        print(f'Loading training data. Dataset: {self.dataset}')\n    \n    def set_standardization(self, std):\n        print(f\"Setting standardization to {std}\")\n        self.std = std\n    \n    def process_data(self):\n        if self.std:\n            print(\"Data will be standardized.\")\n        else:\n            print(\"Data will not be standardized.\")\n    \n    # Additional methods as required... '''"}
{"problem": "You are tasked with creating a Python function that updates a configuration file by appending new lines to it. The function `update_config_user` takes two parameters: `lines`, a list of strings representing the new content to be added, and `separator`, a string representing the separator that will be used to distinguish the original content from the new content in the configuration file. The function should read the existing content of the \"config.user\" file, if it exists, and then append the new lines along with the separator to the end of the file. If the file does not exist, the function should create it and add the new content along with the separator. Finally, the function should return the path of the updated or newly created file.\n\nThe `get_user_config_path` function is assumed to be available and returns the path to the user's configuration directory.\n\nYour task is to implement the `update_config_user` function to achieve the described behavior.", "solution": "'''python\nimport os\n\ndef get_user_config_path(file_name: str):\n    # implementation should fetch the path to the user's configuration directory\n    # for simplicity, assume user's configuration directory is at \"/Users/username/.config/cnyieldhelpshil\"\n    config_dir = \"/Users/username/.config/cnyieldhelpshil\"\n    return os.path.join(config_dir, file_name)\n\ndef update_config_user(lines: list[str], separator: str):\n    path = get_user_config_path(\"config.user\")\n\n    # check if file exists and if not, create an empty file\n    if not os.path.exists(path):\n        with open(path, \"w\", encoding=\"utf-8\"):\n            pass\n\n    # read existing content until end of file\n    content = \"\"\n    with open(path, \"r\", encoding=\"utf-8\") as f:\n        content = f.read()\n        f.close()\n    \n    # append new initial lines with the separator (if present)\n    append_new_lines(content, separator)\n\n    # write the new content with the additional newlines\n    with open(path, \"w\", encoding=\"utf-8\") as f:\n        f.write(content + '\\n')\n        for line in lines:\n            f.write(line + '\\n')\n\ndef append_new_lines(src: str, line: str) -> str:\n    if src and src[-1] == '\\n':\n        src = src[:-1]\n    if line:\n        src += '\\n' + line\n    return src '''"}
{"problem": "You are tasked with creating a custom exception class in Python for a specific API. The API, called WxAPI, has a variety of endpoints that accept different data formats. Your goal is to create a custom exception class, `FormatNotAllowed`, which will be raised when a user attempts to use a data format that is not allowed by a particular endpoint.\n\nYour task is to implement the `FormatNotAllowed` exception class with the following requirements:\n- It should inherit from the `WxAPIException` class.\n- It should have a docstring that states \"The format provided is not allowed by this endpoint\".\n\nCreate the `FormatNotAllowed` exception class according to the given requirements.", "solution": "'''python\nclass FormatNotAllowed(Exception):\n    \"\"\"\n    Exception raised when the requested format is not supported by a specific endpoint.\n    \"\"\"\n\n    def __init__(self, message: str):\n        self.message = message\n        super().__init__(self.message)\n\n    def __str__(self) -> str:\n        return self.message\n\n# Testing the exception class\ntry:\n    raise FormatNotAllowed('The format provided is not supported by this endpoint')\nexcept FormatNotAllowed as e:\n    print(e) '''"}
{"problem": "You are tasked with creating a Python program that utilizes the `pywatchman` library to monitor changes in a specified directory. Your program should be able to connect to the Watchman service, subscribe to changes in the directory, and then print out the details of any changes that occur.\n\nYour program should perform the following steps:\n1. Import the necessary modules and classes from the `pywatchman` library.\n2. Connect to the Watchman service running on the local machine.\n3. Subscribe to changes in a specified directory.\n4. Continuously monitor for changes and print out the details of any changes that occur.\n\nWrite a Python program that accomplishes the above tasks using the `pywatchman` library.", "solution": "'''python\nimport pywatchman\nimport asyncio\nimport signal\n\nasync def main():\n    # Connect to the Watchman service running on the local machine.\n    service = await pywatchman.connect()\n\n    # Subscribe to changes in a specified directory.\n    async with service.watch('<directory>'):\n        # Continuously monitor for changes and print out the details of any changes that occur.\n        async with service.changes() as changes:\n            async for change in changes:\n                print('Change received:', change)\n\nif __name__ == '__main__':\n    asyncio.run(main()) '''"}
{"problem": "You are given a Python function that takes an integer `num` as input. The function is intended to return the number of trailing zeroes in the factorial of `num`. However, the function is incomplete and requires you to fill in the missing code to achieve the desired functionality.\n\nComplete the given function `trailing_zeroes_in_factorial` to return the number of trailing zeroes in the factorial of the given input `num`.\n\n```python\ndef trailing_zeroes_in_factorial(num):\n    \"\"\"\n    :type num: int\n    :rtype: int\n    \"\"\"\n    # Your code here\n```\n\nFor example, if `num` is 5, the factorial of 5 is 120, which has 1 trailing zero. Therefore, the function should return 1.", "solution": "'''python\ndef trailing_zeroes_in_factorial(num):\n    \"\"\"\n    :type num: int\n    :rtype: int\n    \"\"\"\n    factorial = 1\n    for n in range(2, num + 1):\n        factorial *= n\n\n    trailing_zeroes = 0\n    while factorial % 10 == 0:\n        factorial /= 10\n        trailing_zeroes += 1\n\n    return trailing_zeroes '''"}
