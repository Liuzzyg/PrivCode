{"problem": "You are tasked with creating a Python function that processes a list of email addresses and performs a series of operations on them. The function should take a list of email addresses as input and return a dictionary containing the domain names as keys and the corresponding list of usernames as values. If an email address is invalid (i.e., does not contain exactly one \"@\" symbol), it should be ignored.\n\nFunction Signature: `def process_emails(emails: List[str]) -> Dict[str, List[str]]:`\n\nExample:\nInput: `[\"user1@example.com\", \"user2@example.com\", \"user3@gmail.com\", \"invalid_email\", \"user4@yahoo.com\"]`\nOutput: `{\"example.com\": [\"user1\", \"user2\"], \"gmail.com\": [\"user3\"], \"yahoo.com\": [\"user4\"]}`\n\nNote:\n- The input list may contain duplicate email addresses, and the corresponding usernames should be included in the output.\n- If an email address is invalid (i.e., does not contain exactly one \"@\" symbol), it should be ignored and not included in the output.\n- The domain names in the output dictionary should be sorted in ascending order.", "solution": "```python\nfrom typing import List, Dict\n\ndef process_emails(emails: List[str]) -> Dict[str, List[str]]:\n    email_dict = {}\n    for email in emails:\n        if \"@\" in email:\n            username, domain = email.split(\"@\")\n            if domain in email_dict:\n                email_dict[domain].append(username)\n            else:\n                email_dict[domain] = [username]\n    \n    sorted_email_dict = {domain: sorted(usernames) for domain, usernames in email_dict.items()}\n    return dict(sorted(sorted_email_dict.items()))\n```"}
{"problem": "You are tasked with implementing a Python function that filters out hostnames which are just reflected IP addresses. An IP address is considered reflected if it is simply reversed and appears as a hostname. For example, \"1.2.3.4\" and \"4.3.2.1\" are reflected IP addresses. The function should take a list of hostnames as input and return a new list containing only the non-reflected hostnames.\n\nThe function signature is:\n```python\ndef filter_reflected_ips(hostnames: List[str]) -> List[str]:\n    pass\n```\n\nFor example, given the input `[\"google.com\", \"yahoo.com\", \"1.2.3.4\", \"4.3.2.1\", \"example.com\"]`, the function should return `[\"google.com\", \"yahoo.com\", \"example.com\"]`.\n\nAssume that the input list of hostnames will only contain valid hostnames and IP addresses in the format of IPv4.", "solution": "```python\nfrom typing import List\n\ndef filter_reflected_ips(hostnames: List[str]) -> List[str]:\n    non_reflected_hostnames = []\n    for hostname in hostnames:\n        if not all(part.isdigit() for part in hostname.split('.')):\n            non_reflected_hostnames.append(hostname)\n        else:\n            parts = hostname.split('.')\n            if len(parts) == 4 and all(1 <= int(part) <= 255 for part in parts):\n                non_reflected_hostnames.append(hostname)\n    return non_reflected_hostnames\n```\n\nThe `filter_reflected_ips` function iterates through the input list of hostnames and checks if each hostname is a valid non-reflected hostname. It first filters out any hostnames that contain non-numeric characters in their parts. Then, it checks if the hostname is a valid IPv4 address by ensuring that it consists of four parts, each within the range of 1 to 255. If a hostname passes these checks, it is added to the list of non-reflected hostnames, which is then returned as the result."}
{"problem": "You are tasked with creating a Python function that processes a list of strings representing email addresses and returns a dictionary containing the domain names as keys and the number of occurrences of each domain as values. The email addresses may be in different formats, but for the purpose of this problem, we will consider the domain to be the part of the email address after the \"@\" symbol.\n\nCreate a function called `count_email_domains` that takes a list of email addresses as input and returns a dictionary with domain names as keys and their respective counts as values.\n\nFunction Signature: `def count_email_domains(emails: List[str]) -> Dict[str, int]:`\n\nFor example, given the input `[\"user1@example.com\", \"user2@example.com\", \"user3@gmail.com\", \"user4@yahoo.com\", \"user5@example.com\"]`, the function should return `{\"example.com\": 3, \"gmail.com\": 1, \"yahoo.com\": 1}`.\n\nAssume that the input list of email addresses will always contain at least one valid email address.", "solution": "```python\nfrom typing import List, Dict\n\ndef count_email_domains(emails: List[str]) -> Dict[str, int]:\n    domain_counts = {}\n    for email in emails:\n        domain = email.split('@')[-1]\n        domain_counts[domain] = domain_counts.get(domain, 0) + 1\n    return domain_counts\n```\n\nThe `count_email_domains` function iterates through the list of email addresses, extracts the domain name from each email address, and updates the count of each domain in the `domain_counts` dictionary. It uses the `get` method of dictionaries to handle the case when the domain is encountered for the first time. Finally, it returns the dictionary containing the domain names as keys and their respective counts as values."}
{"problem": "You are tasked with creating a PHP class that implements two interfaces: `ConfigurationInterface` and `ResolvedConfigurationInterface`. The class should represent the configuration for accessing a Yahoo email account using IMAP. The provided code snippet serves as a starting point for your task.\n\nYour task is to complete the `Yahoo` class by implementing the required methods and properties to adhere to the interfaces and provide the necessary configuration for accessing a Yahoo email account via IMAP.\n\nYour completed `Yahoo` class should include the following:\n- Constants: `CODE`, `NAME`, and `HOST` representing the code, name, and host for the Yahoo email configuration.\n- Private properties: `username` and `password` to store the credentials for accessing the Yahoo email account.\n- A `getCode` method that returns the code associated with the Yahoo configuration.\n\nComplete the `Yahoo` class to fulfill the requirements of the interfaces and provide the necessary configuration for accessing a Yahoo email account via IMAP.", "solution": "```php\nuse Webkul\\UVDesk\\MailboxBundle\\Utils\\Imap\\ConfigurationInterface;\nuse Webkul\\UVDesk\\MailboxBundle\\Utils\\Imap\\ResolvedConfigurationInterface;\n\nclass Yahoo implements ConfigurationInterface, ResolvedConfigurationInterface\n{\n    const CODE = 'yahoo';\n    const NAME = 'Yahoo';\n    const HOST = '{imap.mail.yahoo.com:993/imap/ssl}INBOX';\n\n    private $username;\n    private $password;\n\n    public function __construct($username, $password)\n    {\n        $this->username = $username;\n        $this->password = $password;\n    }\n\n    public static function getCode()\n    {\n        return self::CODE;\n    }\n\n    public function getHost()\n    {\n        return self::HOST;\n    }\n\n    public function getUsername()\n    {\n        return $this->username;\n    }\n\n    public function getPassword()\n    {\n        return $this->password;\n    }\n}\n```\n\nIn the solution, the `Yahoo` class is completed with the implementation of the required methods and properties to adhere to the `ConfigurationInterface` and `ResolvedConfigurationInterface`. The class includes constants for code, name, and host, as well as private properties for storing the username and password. Additionally, the class includes methods to retrieve the code, host, username, and password for the Yahoo email configuration."}
{"problem": "You are tasked with creating a program that generates unique usernames for a given number of users. Each username will be either a standalone username or an email address, depending on a specified flag. The program should also support the option to use custom email providers for the email addresses.\n\nThe program should take the following inputs:\n- `args.number`: An integer representing the number of usernames to generate.\n- `args.useUsernames`: A boolean flag indicating whether to use standalone usernames only (True) or email addresses as well (False).\n- `email_providers`: A list of strings representing custom email providers to choose from when creating email addresses.\n\nThe program should generate unique usernames based on the following rules:\n- If `args.useUsernames` is True, generate standalone usernames using the `generate_username()` function.\n- If `args.useUsernames` is False, append a random email provider from the `email_providers` list to the generated username.\n\nWrite a function `generate_usernames(args, email_providers)` that takes the inputs described above and returns a list of unique usernames based on the specified rules.\n\nExample:\nInput:\n- args.number = 5\n- args.useUsernames = False\n- email_providers = [\"gmail.com\", \"yahoo.com\", \"outlook.com\"]\n\nOutput:\n[\"username@gmail.com\", \"username@yahoo.com\", \"username@outlook.com\", \"username@gmail.com\", \"username@yahoo.com\"]", "solution": "```python\nimport random\n\ndef generate_username():\n    # Implement the logic to generate a unique username\n    pass  # Placeholder for the actual username generation logic\n\ndef generate_usernames(args, email_providers):\n    usernames = []\n    for i in range(args.number):\n        username = generate_username()\n        if not args.useUsernames:\n            username += \"@\" + random.choice(email_providers)\n        usernames.append(username)\n    return usernames\n```\nIn the solution, the `generate_username()` function is a placeholder for the actual logic to generate a unique username. The `generate_usernames()` function takes the input arguments and email providers list to generate the required usernames based on the specified rules. The function appends the generated usernames to a list and returns the list of unique usernames."}
