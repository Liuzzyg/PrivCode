{"problem": "You are tasked with creating a program that processes a given code snippet to extract the author's name, email, and website. The code snippet is a comment block containing the author's details in a specific format. Your program should be able to parse the comment block and extract the required information.\n\nWrite a function `extract_author_details(code_snippet: str) -> dict` that takes a string `code_snippet` as input and returns a dictionary containing the author's name, email, and website. The code snippet will be in the following format:\n```\n#By Tummy a.k.a <NAME>\t\t                     #\n#<EMAIL>[.]Passaro[@]gmail[.]<EMAIL>\t\t\t\t     #\n#www.vincentpassaro.com\t\t\t\t\t\t     #\n######################################################################\n#_____________________________________________________________________\n```\n- The author's name will be denoted by `<NAME>`.\n- The author's email will be denoted by `<EMAIL>`.\n- The author's website will be denoted by `www.` followed by the website URL.\n\nAssumptions:\n- The code snippet will always follow the given format.\n- The author's name, email, and website will not contain any leading or trailing whitespaces.\n\nExample:\nInput:\n```\ncode_snippet = '''\n#By Tummy a.k.a Vincent Passaro\t\t                     #\n#vincent.passaro@gmail.com\t\t\t\t     #\n#www.vincentpassaro.com\t\t\t\t\t\t     #\n######################################################################\n#_____________________________________________________________________\n'''\n```\nOutput:\n```\n{\n    'name': 'Vincent Passaro',\n    'email': 'vincent.passaro@gmail.com',\n    'website': 'www.vincentpassaro.com'\n}\n```", "solution": "```python\nimport re\n\ndef extract_author_details(code_snippet: str) -> dict:\n    author_details = {}\n    name_match = re.search(r'#By Tummy a.k.a (.+?)\\s*#', code_snippet)\n    email_match = re.search(r'#(.+?)\\s*#', code_snippet.splitlines()[1])\n    website_match = re.search(r'#www\\.(.+?)\\s*#', code_snippet.splitlines()[2])\n\n    if name_match:\n        author_details['name'] = name_match.group(1)\n    if email_match:\n        author_details['email'] = email_match.group(1)\n    if website_match:\n        author_details['website'] = website_match.group(1)\n\n    return author_details\n```"}
{"problem": "You are tasked with creating a program that can extract email addresses from a given text. Your program should take a string as input and return a list of unique email addresses found within the input string. An email address is defined as a string of the form \"username@domain.com\" where both the username and domain can contain letters, numbers, dots, and hyphens. The username cannot start or end with a dot or hyphen, and the domain must contain at least one dot. \n\nYour program should ignore any invalid email addresses or duplicates and return the list of unique valid email addresses in lexicographical order.\n\nFor example, given the input string:\n```\nAuthor   : <NAME>\nEmail    : saurabh.shrivastava54+ccextractorweb[at]gmail.com\nPlease contact me at saurabh.shrivastava54+ccextractorweb[at]gmail.com for any queries.\n```\nThe program should return:\n```\n['saurabh.shrivastava54+ccextractorweb@gmail.com']\n```", "solution": "```python\nimport re\n\ndef extract_emails(input_string):\n    email_regex = r'\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Z|a-z]{2,}\\b'\n    emails = re.findall(email_regex, input_string)\n    unique_emails = list(set(emails))\n    unique_emails.sort()\n    return unique_emails\n```"}
{"problem": "You are tasked with creating a Python function that processes a list of email addresses and performs a series of operations on them. The function should take a list of email addresses as input and return a dictionary containing the domain names as keys and the corresponding list of usernames as values. If an email address is invalid (i.e., does not contain exactly one \"@\" symbol), it should be ignored.\n\nFunction Signature: `def process_emails(emails: List[str]) -> Dict[str, List[str]]:`\n\nExample:\nInput: `[\"user1@example.com\", \"user2@example.com\", \"user3@gmail.com\", \"invalid_email\", \"user4@yahoo.com\"]`\nOutput: `{\"example.com\": [\"user1\", \"user2\"], \"gmail.com\": [\"user3\"], \"yahoo.com\": [\"user4\"]}`\n\nNote:\n- The input list may contain duplicate email addresses, and the corresponding usernames should be included in the output.\n- If an email address is invalid (i.e., does not contain exactly one \"@\" symbol), it should be ignored and not included in the output.\n- The domain names in the output dictionary should be sorted in ascending order.", "solution": "```python\nfrom typing import List, Dict\n\ndef process_emails(emails: List[str]) -> Dict[str, List[str]]:\n    email_dict = {}\n    for email in emails:\n        if \"@\" in email:\n            username, domain = email.split(\"@\")\n            if domain in email_dict:\n                email_dict[domain].append(username)\n            else:\n                email_dict[domain] = [username]\n    \n    sorted_email_dict = {domain: sorted(usernames) for domain, usernames in email_dict.items()}\n    return dict(sorted(sorted_email_dict.items()))\n```"}
{"problem": "You are tasked with creating a Python program to send an email with an attached image using the `smtplib` and `email` libraries. Your program should read an image file from the local directory and send it as an attachment in an email to a specified recipient.\n\nYour program should perform the following steps:\n1. Import the necessary libraries: `smtplib`, `email.mime.multipart`, `email.mime.image`.\n2. Set up the SMTP server details, including the recipient's email address, your email address, and your email password.\n3. Create the container (outer) email message with the sender's and recipient's email addresses.\n4. Attach the image file ('i1.jpg') to the email message.\n5. Send the email using the SMTP server.\n\nWrite a Python program that accomplishes the above tasks and sends the email with the attached image.", "solution": "```python\nimport smtplib\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.image import MIMEImage\nfrom email.mime.text import MIMEText\n\n# Set up SMTP server details\nSMTP_SERVER = 'your_smtp_server'\nSMTP_PORT = 587\nSMTP_USERNAME = 'your_email@gmail.com'\nSMTP_PASSWORD = 'your_email_password'\nSMTP_RECIPIENT = 'recipient_email@example.com'\n\n# Create the container (outer) email message\nTO = SMTP_RECIPIENT\nFROM = SMTP_USERNAME\nmsg = MIMEMultipart()\nmsg['To'] = TO\nmsg['From'] = FROM\nmsg['Subject'] = 'Rpi Sends Image'\n\n# Attach the image\nfp = open('i1.jpg', 'rb')\nimg = MIMEImage(fp.read())\nfp.close()\nimg.add_header('Content-Disposition', 'attachment', filename='i1.jpg')\nmsg.attach(img)\n\n# Connect to the SMTP server and send the email\nserver = smtplib.SMTP(SMTP_SERVER, SMTP_PORT)\nserver.starttls()\nserver.login(SMTP_USERNAME, SMTP_PASSWORD)\nserver.send_message(msg)\nserver.quit()\n```\n\nIn this solution, we first import the necessary libraries and set up the SMTP server details. We then create the email message, attach the image file, and send the email using the SMTP server. This program can be used to send an email with an attached image using Python."}
{"problem": "You are tasked with creating a function that takes a list of email addresses and returns a list of corresponding GitHub usernames. The GitHub usernames are derived from the email addresses by extracting the username part before the \"@\" symbol. If the email address is invalid (i.e., does not contain \"@\"), it should be skipped, and the function should continue processing the remaining email addresses.\n\nWrite a function `extract_github_usernames(emails: List[str]) -> List[str]` that takes a list of email addresses as input and returns a list of corresponding GitHub usernames.\n\nExample:\nInput:\n```python\nemails = [\"alice@example.com\", \"bob@gmail.com\", \"charlie\", \"david@company.com\"]\n```\nOutput:\n```python\n[\"alice\", \"bob\", \"david\"]\n```", "solution": "```python\nfrom typing import List\n\ndef extract_github_usernames(emails: List[str]) -> List[str]:\n    github_usernames = []\n    for email in emails:\n        if \"@\" in email:\n            username = email.split(\"@\")[0]\n            github_usernames.append(username)\n    return github_usernames\n```"}
{"problem": "You are tasked with creating a program that generates a keyboard layout for selecting email addresses. The program should prompt the user to input their preferred email address for receiving new emails, specifically limited to Gmail addresses. The user will then be presented with a keyboard layout containing available email addresses to choose from. \n\nYour task is to implement a function `generate_email_keyboard_layout(emails: List[str]) -> str` that takes a list of available email addresses as input and returns a string representing the keyboard layout. The keyboard layout should display the email addresses in a visually appealing format, such as a grid or a list, to facilitate user selection. Each email address should be clearly visible and distinguishable within the layout.\n\nExample:\nInput:\n```python\nemails = ['example1@gmail.com', 'example2@gmail.com', 'example3@gmail.com']\n```\nOutput:\n```\nexample1@gmail.com  example2@gmail.com\nexample3@gmail.com\n```", "solution": "```python\nfrom typing import List\n\ndef generate_email_keyboard_layout(emails: List[str]) -> str:\n    max_columns = 2  # Maximum number of columns in the keyboard layout\n    keyboard_layout = ''\n    for i, email in enumerate(emails):\n        if i % max_columns == 0 and i != 0:\n            keyboard_layout += '\\n'  # Start a new row for the next set of email addresses\n        keyboard_layout += email.ljust(25)  # Adjust the spacing for each email address\n    return keyboard_layout\n\n# Test the function with the given example\nemails = ['example1@gmail.com', 'example2@gmail.com', 'example3@gmail.com']\nkeyboard = generate_email_keyboard_layout(emails)\nprint(keyboard)\n```\n\nOutput:\n```\nexample1@gmail.com        example2@gmail.com\nexample3@gmail.com\n```\n\nThe `generate_email_keyboard_layout` function takes a list of email addresses and arranges them in a visually appealing keyboard layout with a maximum of 2 columns. Each email address is left-justified and padded with spaces to ensure consistent spacing within the layout."}
{"problem": "You are tasked with creating a Python function that processes a list of email addresses and returns a dictionary containing the domain names as keys and the corresponding list of usernames as values. The function should also handle cases where the email addresses are invalid or do not contain a domain name.\n\nThe function signature should be:\n```python\ndef process_email_addresses(emails: List[str]) -> Dict[str, List[str]]:\n    pass\n```\n\nFor example, given the input `[\"user1@example.com\", \"user2@example.com\", \"user3@gmail.com\", \"invalid_email\", \"user4@domain.com\"]`, the function should return `{\"example.com\": [\"user1\", \"user2\"], \"gmail.com\": [\"user3\"], \"invalid_email\": [], \"domain.com\": [\"user4\"]}`.\n\nEnsure that the function handles the following cases:\n1. Valid email addresses with domain names.\n2. Invalid email addresses without domain names.\n3. Email addresses with domain names but no username.", "solution": "```python\nfrom typing import List, Dict\nimport re\n\ndef process_email_addresses(emails: List[str]) -> Dict[str, List[str]]:\n    email_dict = {}\n    for email in emails:\n        match = re.match(r'^([\\w.-]+)@([\\w.-]+)$', email)\n        if match:\n            username, domain = match.groups()\n            email_dict.setdefault(domain, []).append(username)\n        else:\n            email_dict.setdefault(email, [])\n    return email_dict\n```\n\nThis solution first imports the necessary modules and defines the function `process_email_addresses`. It then iterates through the list of email addresses, using regular expressions to extract the username and domain name. If the email is valid, it adds the username to the corresponding domain's list in the dictionary. If the email is invalid, it adds it to the dictionary with an empty list. Finally, it returns the populated dictionary."}
{"problem": "You are tasked with creating a Python function that validates the login credentials for a Gmail account. The function should take in a list `login` containing the Gmail username at index 0 and the corresponding password at index 1. The function should also take a string `recipient` representing the recipient's email address. Your task is to create a function `validate_gmail_login` that checks if the provided Gmail credentials are valid and if the recipient's email address is the same as the Gmail username. The function should return `True` if the credentials are valid and the recipient's email matches the Gmail username, and `False` otherwise.\n\nFunction Signature: `def validate_gmail_login(login: List[str], recipient: str) -> bool`\n\nExample:\n```python\nlogin = [\"example@gmail.com\", \"password123\"]\nrecipient = \"example@gmail.com\"\nprint(validate_gmail_login(login, recipient))  # Output: True\n```", "solution": "```python\nfrom typing import List\n\ndef validate_gmail_login(login: List[str], recipient: str) -> bool:\n    gmailUser = login[0]\n    gmailPassword = login[1]\n    return gmailUser == recipient and gmailUser.endswith('@gmail.com')  # Check if recipient matches Gmail username and if the username is a Gmail account\n```"}
{"problem": "You are tasked with creating a Python program that sends an email with a PDF attachment using the `smtplib` library. Your program should read the PDF file from the specified location and send it as an attachment via a secure SMTP connection. You need to ensure that the email credentials are securely handled and that the PDF file is properly attached to the email.\n\nYour program should include the following steps:\n1. Import the necessary libraries.\n2. Define the email credentials (email address and password) and the PDF file path.\n3. Establish a secure SMTP connection using `smtplib.SMTP_SSL`.\n4. Login to the SMTP server using the provided email credentials.\n5. Read the PDF file and prepare it as an attachment to the email.\n6. Compose the email with the PDF attachment and send it.\n\nEnsure that the program handles potential exceptions and errors gracefully.", "solution": "```python\nimport smtplib\nfrom email.message import EmailMessage\nimport os\n\n# Email credentials\nEMAIL_ADDRESS = \"your_email@gmail.com\"\nEMAIL_PASSWORD = \"your_email_password\"\n\n# PDF file path\npdf_path = \"/home/shihab4t/Downloads/Profile.pdf\"\n\ndef send_email_with_attachment():\n    try:\n        # Establish a secure SMTP connection\n        with smtplib.SMTP_SSL(\"smtp.gmail.com\", 465) as smtp:\n            # Login to the SMTP server\n            smtp.login(EMAIL_ADDRESS, EMAIL_PASSWORD)\n\n            # Read the PDF file\n            with open(pdf_path, \"rb\") as file:\n                pdf_data = file.read()\n\n            # Compose the email\n            msg = EmailMessage()\n            msg[\"From\"] = EMAIL_ADDRESS\n            msg[\"To\"] = \"recipient_email@example.com\"\n            msg[\"Subject\"] = \"PDF Attachment\"\n            msg.set_content(\"Please find the attached PDF file.\")\n\n            # Attach the PDF file\n            msg.add_attachment(pdf_data, maintype=\"application\", subtype=\"pdf\", filename=os.path.basename(pdf_path))\n\n            # Send the email\n            smtp.send_message(msg)\n\n        print(\"Email with PDF attachment sent successfully.\")\n\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nsend_email_with_attachment()\n```"}
{"problem": "You are tasked with creating a Python function that processes a list of strings representing email addresses and returns a dictionary containing the domain names as keys and the number of occurrences of each domain as values. The email addresses may be in different formats, but for the purpose of this problem, we will consider the domain to be the part of the email address after the \"@\" symbol.\n\nCreate a function called `count_email_domains` that takes a list of email addresses as input and returns a dictionary with domain names as keys and their respective counts as values.\n\nFunction Signature: `def count_email_domains(emails: List[str]) -> Dict[str, int]:`\n\nFor example, given the input `[\"user1@example.com\", \"user2@example.com\", \"user3@gmail.com\", \"user4@yahoo.com\", \"user5@example.com\"]`, the function should return `{\"example.com\": 3, \"gmail.com\": 1, \"yahoo.com\": 1}`.\n\nAssume that the input list of email addresses will always contain at least one valid email address.", "solution": "```python\nfrom typing import List, Dict\n\ndef count_email_domains(emails: List[str]) -> Dict[str, int]:\n    domain_counts = {}\n    for email in emails:\n        domain = email.split('@')[-1]\n        domain_counts[domain] = domain_counts.get(domain, 0) + 1\n    return domain_counts\n```\n\nThe `count_email_domains` function iterates through the list of email addresses, extracts the domain name from each email address, and updates the count of each domain in the `domain_counts` dictionary. It uses the `get` method of dictionaries to handle the case when the domain is encountered for the first time. Finally, it returns the dictionary containing the domain names as keys and their respective counts as values."}
{"problem": "You are tasked with implementing a function to validate the format of email addresses. The function should take a list of email addresses as input and return a list of valid email addresses according to the specified format rules.\n\nThe format rules for a valid email address are as follows:\n1. The email address must contain a username and a domain name separated by an \"@\" symbol.\n2. The username can only contain alphanumeric characters (letters and numbers), dots (.), hyphens (-), and underscores (_).\n3. The domain name must consist of a domain and a top-level domain (TLD) separated by a dot (.).\n4. The domain and TLD can only contain alphanumeric characters.\n\nYou should implement the function `validate_email_addresses(emails)` where:\n- `emails` is a list of strings representing email addresses.\n\nThe function should return a list of valid email addresses based on the format rules.\n\nExample:\nInput\n```python\nvalidate_email_addresses([\"john.doe@example.com\", \"jane_doe123@gmail.com\", \"invalid.email@com\", \"missing@domaincom\"])\n```\nOutput\n```\n['john.doe@example.com', 'jane_doe123@gmail.com']\n```", "solution": "```python\nimport re\n\ndef validate_email_addresses(emails):\n    valid_emails = []\n    for email in emails:\n        if re.match(r'^[\\w.-]+@[a-zA-Z0-9]+\\.[a-zA-Z]{2,}$', email):\n            valid_emails.append(email)\n    return valid_emails\n```\n\nThe `validate_email_addresses` function uses the `re` module to match each email address against the specified format rules using a regular expression. If the email address matches the format, it is added to the list of valid email addresses, which is then returned."}
{"problem": "You are tasked with creating a program to manage user roles within an event management system. The system should allow for the creation of user objects with specific roles and provide functionality to update user roles based on certain conditions.\n\nYou are given a code snippet that initializes a user object with the following properties:\n- Name: A string representing the user's name\n- Email: A string representing the user's email address\n- Role: An enum representing the user's role, with possible values of UserRole.Attendee, UserRole.Organizer, and UserRole.Speaker\n\nYour task is to implement a method that takes a list of user objects and updates the role of each user based on the following conditions:\n- If the user's email domain is \"example.com\", their role should be updated to UserRole.Organizer\n- If the user's name starts with \"Speaker_\", their role should be updated to UserRole.Speaker\n\nYou should then return the updated list of user objects with the modified roles.\n\nWrite a function with the following signature:\n```csharp\npublic List<UserTO> UpdateUserRoles(List<UserTO> users)\n```\n\nThe UserTO class is defined as follows:\n```csharp\npublic class UserTO\n{\n    public string Name { get; set; }\n    public string Email { get; set; }\n    public UserRole Role { get; set; }\n}\n\npublic enum UserRole\n{\n    Attendee,\n    Organizer,\n    Speaker\n}\n```\n\nFor example, given the input list of user objects:\n```\n[\n    {\n        Name = \"John\",\n        Email = \"john@example.com\",\n        Role = UserRole.Attendee\n    },\n    {\n        Name = \"Speaker_Mary\",\n        Email = \"mary@gmail.com\",\n        Role = UserRole.Attendee\n    }\n]\n```\nThe function should update the roles based on the conditions and return the modified list:\n```\n[\n    {\n        Name = \"John\",\n        Email = \"john@example.com\",\n        Role = UserRole.Organizer\n    },\n    {\n        Name = \"Speaker_Mary\",\n        Email = \"mary@gmail.com\",\n        Role = UserRole.Speaker\n    }\n]", "solution": "public List<UserTO> UpdateUserRoles(List<UserTO> users)\n{\n    foreach (var user in users)\n    {\n        if (user.Email.EndsWith(\"example.com\"))\n        {\n            user.Role = UserRole.Organizer;\n        }\n        if (user.Name.StartsWith(\"Speaker_\"))\n        {\n            user.Role = UserRole.Speaker;\n        }\n    }\n    return users;\n}\n```"}
{"problem": "You are tasked with creating a Python script to automate the generation and emailing of a daily report of blocked GeoIPs from a pfSense firewall using pfBlockerNG. The report should include the list of blocked GeoIPs and be sent via email to a specified recipient. \n\nThe script should perform the following tasks:\n1. Connect to the pfSense firewall using SSH.\n2. Execute a command to retrieve the list of blocked GeoIPs using pfBlockerNG.\n3. Format the list of blocked GeoIPs into a report.\n4. Send the report via email to a specified recipient.\n\nYour task is to implement the Python script to achieve the above requirements. You should ensure that the script securely handles the SSH connection and email credentials, and that it follows best practices for error handling and code organization.", "solution": "```python\nimport paramiko\nimport smtplib\nfrom email.message import EmailMessage\n\n# SSH connection parameters\nssh_host = 'pfSense_IP'\nssh_port = 22\nssh_username = 'your_ssh_username'\nssh_password = 'your_ssh_password'\n\n# Email parameters\nemail_sender = 'your_email@gmail.com'\nemail_password = 'your_email_password'\nemail_recipient = 'recipient_email@example.com'\n\n# Connect to pfSense firewall via SSH and retrieve blocked GeoIPs\nssh_client = paramiko.SSHClient()\nssh_client.set_missing_host_key_policy(paramiko.AutoAddPolicy())\nssh_client.connect(ssh_host, port=ssh_port, username=ssh_username, password=ssh_password)\n\nstdin, stdout, stderr = ssh_client.exec_command('pfctl -t blockedGeoIPs -T show')\n\nblocked_geoips = stdout.read().decode('utf-8')\n\nssh_client.close()\n\n# Format the blocked GeoIPs into a report\nreport = \"Blocked GeoIPs:\\n\" + blocked_geoips\n\n# Send the report via email\nmsg = EmailMessage()\nmsg.set_content(report)\nmsg['Subject'] = 'Daily Blocked GeoIPs Report'\nmsg['From'] = email_sender\nmsg['To'] = email_recipient\n\nwith smtplib.SMTP_SSL('smtp.gmail.com', 465) as smtp:\n    smtp.login(email_sender, email_password)\n    smtp.send_message(msg)\n\nprint(\"Report sent successfully.\")\n```\n\nIn this solution, we use the `paramiko` library to establish an SSH connection to the pfSense firewall and retrieve the list of blocked GeoIPs. We then format the list into a report and send it via email using the `smtplib` library. The script securely handles the SSH and email credentials and follows best practices for error handling and code organization."}
{"problem": "You are tasked with creating a Python program to automate the process of sending personalized emails to a list of recipients using the `smtplib` library. Your program should read a CSV file containing recipient information and use it to populate the email content. Additionally, the program should handle any potential errors that may occur during the email sending process.\n\nThe CSV file will have the following format:\n```\nName, Email, Subject, Body\nJohn Doe, johndoe@example.com, Special Offer, Dear John, we are pleased to offer you a special discount on our products.\n```\n\nYour program should perform the following steps:\n1. Read the recipient information from the CSV file.\n2. For each recipient, create a personalized email with the provided subject and body.\n3. Send the email using a secure connection to the SMTP server at `smtp.gmail.com` with the provided credentials.\n\nEnsure that your program handles potential errors, such as authentication failures or network issues, and provides appropriate feedback to the user.", "solution": "```python\nimport csv\nimport smtplib\nfrom email.mime.text import MIMEText\nfrom email.mime.multipart import MIMEMultipart\nimport ssl\n\ndef send_personalized_emails(csv_file, admin_user, password, port):\n    context = ssl.create_default_context()\n    \n    with open(csv_file, 'r') as file:\n        reader = csv.reader(file)\n        next(reader)  # Skip header row\n        for row in reader:\n            name, email, subject, body = row\n            message = MIMEMultipart()\n            message['From'] = admin_user\n            message['To'] = email\n            message['Subject'] = subject\n            message.attach(MIMEText(body, 'plain'))\n            \n            try:\n                with smtplib.SMTP_SSL('smtp.gmail.com', port, context=context) as server:\n                    server.login(admin_user, password)\n                    server.sendmail(admin_user, email, message.as_string())\n                    print(f\"Successfully sent email to {email}\")\n                except smtplib.SMTPAuthenticationError:\n                    print(f\"Failed to authenticate for {email}\")\n                except smtplib.SMTPException as e:\n                    print(f\"Failed to send email to {email}: {e}\")\n                except Exception as e:\n                    print(f\"An error occurred for {email}: {e}\")\n\n# Example usage\ncsv_file = 'recipients.csv'\nadmin_user = 'your_email@gmail.com'\npassword = 'your_password'\nport = 465\nsend_personalized_emails(csv_file, admin_user, password, port)\n```"}
{"problem": "You are tasked with implementing a function that parses a given JSON object and returns a list of all the keys present in the object. The JSON object may contain nested objects and arrays, and the function should be able to handle these nested structures to extract all the keys present.\n\nYou are given a code snippet representing a portion of a JSON object in the form of a Python dictionary. The snippet is as follows:\n\n```python\n'links': {\n```\n\nWrite a function `extract_keys(json_obj)` that takes a JSON object as input and returns a list of all the keys present in the object. The function should handle nested objects and arrays within the JSON object.\n\nFunction Signature: `def extract_keys(json_obj: dict) -> List[str]:`\n\nExample:\n```python\njson_obj = {\n    \"name\": \"John\",\n    \"age\": 30,\n    \"address\": {\n        \"street\": \"123 Street\",\n        \"city\": \"New York\"\n    },\n    \"emails\": [\"john@example.com\", \"john@gmail.com\"]\n}\n\nprint(extract_keys(json_obj))\n```\nOutput:\n```\n['name', 'age', 'address', 'street', 'city', 'emails']\n```", "solution": "```python\nfrom typing import List\n\ndef extract_keys(json_obj: dict) -> List[str]:\n    keys = []\n    for key, value in json_obj.items():\n        keys.append(key)\n        if isinstance(value, dict):\n            keys.extend(extract_keys(value))\n        elif isinstance(value, list):\n            for item in value:\n                if isinstance(item, dict):\n                    keys.extend(extract_keys(item))\n    return keys\n```"}
{"problem": "You are tasked with creating a Node.js script that utilizes the installed npm packages to send an email containing the geographical location of a user connecting to a WebSocket server. The script should use the `nodemailer` package to send the email and the `websocket` and `geoip-lite` packages to obtain the user's IP address and geographical location.\n\nYour task is to implement a function `sendLocationEmail(emailAddress, clientIP)` that takes the `emailAddress` of the recipient and the `clientIP` of the user connecting to the WebSocket server. The function should use the `geoip-lite` package to determine the geographical location of the `clientIP`, and then use the `nodemailer` package to send an email to the specified `emailAddress` containing the geographical location information.\n\nYou can assume that the necessary npm packages (`nodemailer`, `websocket`, and `geoip-lite`) have been installed using the provided code snippet.\n\nExample:\n```javascript\n// This is just an example, the actual implementation will be different\nsendLocationEmail('recipient@example.com', '192.168.1.1');\n```", "solution": "```javascript\nconst nodemailer = require('nodemailer');\nconst geoip = require('geoip-lite');\n\n// Function to send email with geographical location\nfunction sendLocationEmail(emailAddress, clientIP) {\n  // Get geographical location from clientIP\n  const geo = geoip.lookup(clientIP);\n  const locationInfo = `${geo.city}, ${geo.region}, ${geo.country}`;\n\n  // Create a nodemailer transporter\n  const transporter = nodemailer.createTransport({\n    service: 'gmail',\n    auth: {\n      user: 'your-email@gmail.com',\n      pass: 'your-email-password'\n    }\n  });\n\n  // Email content\n  const mailOptions = {\n    from: 'your-email@gmail.com',\n    to: emailAddress,\n    subject: 'Geographical Location Information',\n    text: `The user's geographical location is: ${locationInfo}`\n  };\n\n  // Send email\n  transporter.sendMail(mailOptions, function(error, info) {\n    if (error) {\n      console.log(error);\n    } else {\n      console.log('Email sent: ' + info.response);\n    }\n  });\n}\n\n// Example usage\nsendLocationEmail('recipient@example.com', '192.168.1.1');\n```\n\nIn this solution, the `sendLocationEmail` function uses the `geoip-lite` package to obtain the geographical location of the client's IP address. It then uses the `nodemailer` package to send an email containing the geographical location information to the specified recipient email address. The nodemailer transporter is configured with the sender's email credentials, and the email content includes the geographical location information obtained from the client's IP address."}
{"problem": "You are tasked with implementing a custom string validation extension in Swift. The extension should be able to validate whether a given string is a valid email address. The validation should follow the standard email format rules, including the presence of an \"@\" symbol, a domain name, and a top-level domain (TLD). Additionally, the extension should be able to validate whether a given string represents a valid name. For the purpose of this problem, a valid name is defined as a string that contains only alphabetic characters and spaces, with a length between 2 and 50 characters.\n\nYour task is to complete the implementation of the `String` extension in Swift to provide the required validation functionalities. You should implement the `isValidEmail` and `isValidName` properties, which should return `true` if the string meets the respective validation criteria, and `false` otherwise.\n\nYou are provided with a starting code snippet that includes a test case for validating an email address using the `isValidEmail` property. Your task is to complete the implementation of the `String` extension to satisfy the given validation requirements.\n\n```swift\nclass ValidatorStringTests: XCTestCase {\n    \n    func testEmail() {\n        XCTAssertEqual(\"erikfloresq@gmail.com\".isValidEmail, true)\n    }\n    \n    func testValidName() {\n        // Your implementation of the test case for validating a valid name goes here\n    }\n}\n```", "solution": "```swift\nextension String {\n    var isValidEmail: Bool {\n        let emailRegex = \"[A-Z0-9a-z._%+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,64}\"\n        let emailPredicate = NSPredicate(format: \"SELF MATCHES %@\", emailRegex)\n        return emailPredicate.evaluate(with: self)\n    }\n    \n    var isValidName: Bool {\n        let nameRegex = \"^[a-zA-Z ]{2,50}$\"\n        return NSPredicate(format: \"SELF MATCHES %@\", nameRegex).evaluate(with: self)\n    }\n}\n```\n\nThe solution provides the implementation of the `String` extension in Swift to validate email addresses and names. The `isValidEmail` property uses a regular expression to check if the string matches the standard email format. The `isValidName` property uses a regular expression to validate that the string contains only alphabetic characters and spaces, with a length between 2 and 50 characters."}
{"problem": "You are tasked with creating a program that generates unique usernames for a given number of users. Each username will be either a standalone username or an email address, depending on a specified flag. The program should also support the option to use custom email providers for the email addresses.\n\nThe program should take the following inputs:\n- `args.number`: An integer representing the number of usernames to generate.\n- `args.useUsernames`: A boolean flag indicating whether to use standalone usernames only (True) or email addresses as well (False).\n- `email_providers`: A list of strings representing custom email providers to choose from when creating email addresses.\n\nThe program should generate unique usernames based on the following rules:\n- If `args.useUsernames` is True, generate standalone usernames using the `generate_username()` function.\n- If `args.useUsernames` is False, append a random email provider from the `email_providers` list to the generated username.\n\nWrite a function `generate_usernames(args, email_providers)` that takes the inputs described above and returns a list of unique usernames based on the specified rules.\n\nExample:\nInput:\n- args.number = 5\n- args.useUsernames = False\n- email_providers = [\"gmail.com\", \"yahoo.com\", \"outlook.com\"]\n\nOutput:\n[\"username@gmail.com\", \"username@yahoo.com\", \"username@outlook.com\", \"username@gmail.com\", \"username@yahoo.com\"]", "solution": "```python\nimport random\n\ndef generate_username():\n    # Implement the logic to generate a unique username\n    pass  # Placeholder for the actual username generation logic\n\ndef generate_usernames(args, email_providers):\n    usernames = []\n    for i in range(args.number):\n        username = generate_username()\n        if not args.useUsernames:\n            username += \"@\" + random.choice(email_providers)\n        usernames.append(username)\n    return usernames\n```\nIn the solution, the `generate_username()` function is a placeholder for the actual logic to generate a unique username. The `generate_usernames()` function takes the input arguments and email providers list to generate the required usernames based on the specified rules. The function appends the generated usernames to a list and returns the list of unique usernames."}
{"problem": "You are tasked with creating a function to validate email addresses based on a given set of criteria. The function should take an email address as input and return a boolean value indicating whether the email address is valid or not.\n\nAn email address is considered valid if it meets the following criteria:\n1. It contains a single \"@\" symbol.\n2. The \"@\" symbol is not the first or last character in the email address.\n3. The domain part of the email address (after the \"@\") contains at least one \".\" character.\n4. The characters before and after the \"@\" symbol are alphanumeric and may also include periods, hyphens, and underscores.\n\nYou are provided with a code snippet that includes an HTML form for entering an email address. Your task is to create a function in a programming language of your choice that validates email addresses according to the specified criteria.", "solution": "```python\nimport re\n\ndef validate_email(email):\n    # Regular expression pattern for validating email addresses\n    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$'\n    \n    # Use the re.match function to check if the email matches the pattern\n    if re.match(pattern, email):\n        return True\n    else:\n        return False\n\n# Test the function with sample email addresses\nprint(validate_email(\"user@example.com\"))  # Output: True\nprint(validate_email(\"user123@gmail\"))      # Output: False\nprint(validate_email(\"invalid.email@domain\"))  # Output: False\nprint(validate_email(\"user@domain.co.uk\"))  # Output: True\n```\n\nIn the solution, a regular expression pattern is used to define the criteria for a valid email address. The `re.match` function is then used to check if the input email address matches the defined pattern, returning `True` if it does and `False` otherwise. The function is tested with sample email addresses to demonstrate its functionality."}
{"problem": "You are tasked with creating a Python program to send personalized emails to a list of recipients using the `smtplib` library. The program should read the email content from an HTML file and the recipient list from a CSV file. Each email should be personalized with the recipient's name and include specific content based on their preferences.\n\nThe CSV file, named `mail_list.csv`, contains the following columns: `email`, `name`, and `preference`. The `email` column contains the recipient's email address, the `name` column contains the recipient's name, and the `preference` column contains a specific preference (e.g., \"business\" or \"personal\").\n\nThe HTML file, named `mail.html`, contains the email template with placeholders for the recipient's name and preference. For example:\n```html\n<!DOCTYPE html>\n<html>\n<body>\n    <p>Dear {name},</p>\n    <p>We have tailored this email specifically for your {preference} needs.</p>\n    <p>Thank you for your continued support.</p>\n</body>\n</html>\n```\nYour task is to complete the Python program to read the recipient list from the CSV file, personalize the email content based on the recipient's information, and send the personalized emails using a Gmail account through SMTP. Ensure that the program handles potential errors, such as SMTP authentication errors, and provides informative messages to the user.", "solution": "```python\nimport smtplib\nimport csv\nfrom email.mime.multipart import MIMEMultipart\nfrom email.mime.text import MIMEText\nfrom string import Template\nimport os\n\n# Read email template from HTML file\nwith open('mail.html', 'r', encoding=\"utf8\") as file:\n    email_template = Template(file.read())\n\n# Read recipient list from CSV file\nrecipients = []\nwith open(\"mail_list.csv\", newline='') as file:\n    reader = csv.DictReader(file)\n    for row in reader:\n        recipients.append(row)\n\n# Gmail SMTP configuration\nsmtp_host = 'smtp.gmail.com'\nsmtp_port = 587\nsender_email = 'your_email@gmail.com'\nsender_password = 'your_password'\n\n# Create SMTP connection\ntry:\n    server = smtplib.SMTP(smtp_host, smtp_port)\n    server.starttls()\n    server.login(sender_email, sender_password)\nexcept smtplib.SMTPAuthenticationError as e:\n    print(\"Please check your credentials, or make sure gmail lesser app is enabled.\")\n    exit()\n\n# Send personalized emails to recipients\nfor recipient in recipients:\n    message = MIMEMultipart()\n    message['From'] = sender_email\n    message['To'] = recipient['email']\n    message['Subject'] = 'Personalized Email'\n\n    # Personalize email content\n    personalized_content = email_template.substitute(name=recipient['name'], preference=recipient['preference'])\n    message.attach(MIMEText(personalized_content, 'html'))\n\n    # Send email\n    server.send_message(message)\n\n# Close SMTP connection\nserver.quit()\n```"}
